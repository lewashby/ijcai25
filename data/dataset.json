[{"id": "5356936999971199584", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size eleven.", "output": "size(11).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size eleven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5711904392950129988", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size fourteen.", "output": "size(14).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size fourteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "682720093334882974", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size ten.", "output": "size(10).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size ten.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1578666923874221566", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1931501258909892849", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size twelve.", "output": "size(12).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3056057177329475363", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7887624092675439613", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size ten.", "output": "size(10).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size ten.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6474424325860908103", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size twelve.", "output": "size(12).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3023347938732435550", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size twelve.", "output": "size(12).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7840008310059189210", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size fourteen.", "output": "size(14).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size fourteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1148933123435946458", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size nine.", "output": "size(9).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size nine.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "79980797753349529", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size ten.", "output": "size(10).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size ten.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9107916382955425243", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1976793844658391725", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size fourteen.", "output": "size(14).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size fourteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6758000943107945317", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size ten.", "output": "size(10).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size ten.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "287839716303119023", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size ten.", "output": "size(10).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size ten.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4324933567585668433", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size eleven.", "output": "size(11).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size eleven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3090682344591854224", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size eleven.", "output": "size(11).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size eleven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2436634251301710801", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7582126575923723183", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size nine.", "output": "size(9).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size nine.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8682186886195973388", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size eleven.", "output": "size(11).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size eleven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7967217859651287147", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size nine.", "output": "size(9).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size nine.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5206913693013469601", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size eleven.", "output": "size(11).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size eleven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2960696381799642028", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4617519896886629173", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "787615140753160630", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size fourteen.", "output": "size(14).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size fourteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7959182895692719639", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size twelve.", "output": "size(12).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3103974107775386902", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size twelve.", "output": "size(12).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "523567974619913544", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size ten.", "output": "size(10).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size ten.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3130006884541261025", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "The region provided has size thirteen.", "output": "size(13).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```The region provided has size thirteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8524164331784318742", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "There is a square region of size twelve.", "output": "size(12).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```There is a square region of size twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6727572230801163204", "problem_id": "36", "problem_name": "Connected Maximum-density Still Life", "description": "A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)", "format": "We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.", "text": "Find the maximum density of a connected still life on a region with size eleven.", "output": "size(11).", "prompt": "Given the following problem description between triple backtips: \n ```A still life is a set of connected live cells from a grid that is fixed under the transition function of John Horton Conway 1970's Game of Life: 1. Any cell with 3 neighbours becomes a live cell. 2. Any live cell with 2-3 live neighbours lives on. 3. Any live cell with <2 or >3 live neighbours dies. The Connected Maximum-density Still Life problem is the task of fitting a given region of the grid with a maximally dense still life, i.e., a maximum number of live cells. (Most work has only looked at pseudo still lifes where the connectedness criterion is dropped.)```\nGiven the following specification for the predicates format: \n```We here consider square shaped regions. The size n of the region is provided by an instance of the predicate size/1. Cells connect horizontally, vertically, and diagonally.```\nExtract the datalog facts from this text: \n```Find the maximum density of a connected still life on a region with size eleven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8779858577206074494", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. The graph has four layer/s. Vertices n12 and n24 are connected. There is a connection between n14 and n21. Layers 0, 1, 2 and 3 contains eight nodes. There is a connection between n15 and n21. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n1 and n10 are connected. Nodes n10 and n26 are connected by an edge. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. There is a connection between n11 and n26. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is an edge between nodes n13 and n20. Nodes n12 and n20 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n10). edge(n10,n26). edge(n11,n26). edge(n12,n20). edge(n12,n24). edge(n13,n20). edge(n14,n21). edge(n15,n21). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. The graph has four layer/s. Vertices n12 and n24 are connected. There is a connection between n14 and n21. Layers 0, 1, 2 and 3 contains eight nodes. There is a connection between n15 and n21. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n1 and n10 are connected. Nodes n10 and n26 are connected by an edge. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. There is a connection between n11 and n26. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is an edge between nodes n13 and n20. Nodes n12 and n20 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6613150339931553369", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n1 and n13. There is a connection between n12 and n19. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. The graph has six layer/s. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a link between nodes n11 and n23. Vertices n1 and n12 are connected. Vertices n11 and n18 are connected. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a connection between n10 and n17. Nodes n1 and n10 are connected by an edge. There is an edge between nodes n12 and n18.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(5,n41). in_layer(5,n42). in_layer(5,n43). in_layer(5,n44). in_layer(5,n45). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n10). edge(n1,n12). edge(n1,n13). edge(n10,n17). edge(n11,n18). edge(n11,n23). edge(n12,n18). edge(n12,n19). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n1 and n13. There is a connection between n12 and n19. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. The graph has six layer/s. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a link between nodes n11 and n23. Vertices n1 and n12 are connected. Vertices n11 and n18 are connected. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a connection between n10 and n17. Nodes n1 and n10 are connected by an edge. There is an edge between nodes n12 and n18.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7527971020339196400", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Nodes n12 and n22 are connected by an edge. There is an edge between nodes n10 and n19. Layers 0, 1, 2 and 3 contains eight nodes. Vertices n1 and n20 are connected. The graph consist of four layer/s. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Nodes n11 and n25 are connected by an edge. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. There is a link between nodes n11 and n22. Vertices n11 and n30 are connected. There is an edge between nodes n10 and n13. Nodes n12 and n23 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n10). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(1,n18). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(2,n27). in_layer(2,n28). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(3,n36). in_layer(3,n37). in_layer(3,n38). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n20). edge(n10,n13). edge(n10,n19). edge(n11,n22). edge(n11,n25). edge(n11,n30). edge(n12,n22). edge(n12,n23). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Nodes n12 and n22 are connected by an edge. There is an edge between nodes n10 and n19. Layers 0, 1, 2 and 3 contains eight nodes. Vertices n1 and n20 are connected. The graph consist of four layer/s. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Nodes n11 and n25 are connected by an edge. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. There is a link between nodes n11 and n22. Vertices n11 and n30 are connected. There is an edge between nodes n10 and n13. Nodes n12 and n23 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5152449617103546141", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is/are four layer/s in the graph. There is an edge between nodes n10 and n20. There is a link between nodes n10 and n21. Nodes n11 and n17 are connected by an edge. Vertices n1 and n11 are connected. Vertices n1 and n12 are connected. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is a link between nodes n12 and n23. Layers 0, 1, 2 and 3 contains eight nodes. There is a connection between n13 and n18. There is a connection between n11 and n18. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n11). edge(n1,n12). edge(n10,n20). edge(n10,n21). edge(n11,n17). edge(n11,n18). edge(n12,n23). edge(n13,n18). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is/are four layer/s in the graph. There is an edge between nodes n10 and n20. There is a link between nodes n10 and n21. Nodes n11 and n17 are connected by an edge. Vertices n1 and n11 are connected. Vertices n1 and n12 are connected. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is a link between nodes n12 and n23. Layers 0, 1, 2 and 3 contains eight nodes. There is a connection between n13 and n18. There is a connection between n11 and n18. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4944410533331864589", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is an edge between nodes n1 and n10. There is a link between nodes n13 and n23. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Nodes n11 and n24 are connected by an edge. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. There is a connection between n12 and n23. There is a connection between n1 and n18. Nodes n12 and n19 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layers 0, 1, 2, 3 and 4 contains eight nodes. The graph has five layer/s. Vertices n10 and n23 are connected. Nodes n14 and n23 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) edge(n1,n10). edge(n1,n18). edge(n10,n23). edge(n11,n24). edge(n12,n19). edge(n12,n23). edge(n13,n23). edge(n14,n23). layers(5).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is an edge between nodes n1 and n10. There is a link between nodes n13 and n23. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Nodes n11 and n24 are connected by an edge. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. There is a connection between n12 and n23. There is a connection between n1 and n18. Nodes n12 and n19 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layers 0, 1, 2, 3 and 4 contains eight nodes. The graph has five layer/s. Vertices n10 and n23 are connected. Nodes n14 and n23 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "593408138783759312", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n10 and n18. Vertices n13 and n21 are connected. Layers 0, 1 and 2 contains eight nodes. The graph has three layer/s. Nodes n11 and n27 are connected by an edge. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Vertices n1 and n19 are connected. There is a link between nodes n10 and n11. There is a connection between n1 and n18. There is an edge between nodes n12 and n29. Nodes n11 and n25 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n10). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(1,n18). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(2,n27). in_layer(2,n28). width(0,8) width(1,8) width(2,8) edge(n1,n18). edge(n1,n19). edge(n10,n11). edge(n10,n18). edge(n11,n25). edge(n11,n27). edge(n12,n29). edge(n13,n21). layers(3).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n10 and n18. Vertices n13 and n21 are connected. Layers 0, 1 and 2 contains eight nodes. The graph has three layer/s. Nodes n11 and n27 are connected by an edge. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Vertices n1 and n19 are connected. There is a link between nodes n10 and n11. There is a connection between n1 and n18. There is an edge between nodes n12 and n29. Nodes n11 and n25 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1625106104185216815", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is an edge between nodes n10 and n21. Vertices n16 and n21 are connected. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Vertices n11 and n18 are connected. There is a link between nodes n13 and n18. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is an edge between nodes n16 and n19. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is an edge between nodes n10 and n17. There is a link between nodes n13 and n22. Layers 0, 1, 2 and 3 contains eight nodes. The graph has four layer/s. There is a connection between n15 and n19.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). width(0,8) width(1,8) width(2,8) width(3,8) edge(n10,n17). edge(n10,n21). edge(n11,n18). edge(n13,n18). edge(n13,n22). edge(n15,n19). edge(n16,n19). edge(n16,n21). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is an edge between nodes n10 and n21. Vertices n16 and n21 are connected. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Vertices n11 and n18 are connected. There is a link between nodes n13 and n18. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is an edge between nodes n16 and n19. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is an edge between nodes n10 and n17. There is a link between nodes n13 and n22. Layers 0, 1, 2 and 3 contains eight nodes. The graph has four layer/s. There is a connection between n15 and n19.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7999570055078002855", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n1 and n14. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a link between nodes n16 and n19. There is an edge between nodes n12 and n24. Nodes n10 and n19 are connected by an edge. There is a link between nodes n11 and n20. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layers 0, 1, 2, 3 and 4 contains eight nodes. Vertices n1 and n16 are connected. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n14 and n22 are connected. There is/are five layer/s in the graph. There is a link between nodes n1 and n12. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) edge(n1,n12). edge(n1,n14). edge(n1,n16). edge(n10,n19). edge(n11,n20). edge(n12,n24). edge(n14,n22). edge(n16,n19). layers(5).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n1 and n14. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a link between nodes n16 and n19. There is an edge between nodes n12 and n24. Nodes n10 and n19 are connected by an edge. There is a link between nodes n11 and n20. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layers 0, 1, 2, 3 and 4 contains eight nodes. Vertices n1 and n16 are connected. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n14 and n22 are connected. There is/are five layer/s in the graph. There is a link between nodes n1 and n12. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "716578894817104971", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n1 and n13. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. There is a link between nodes n1 and n10. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Nodes n12 and n22 are connected by an edge. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. There is a link between nodes n12 and n20. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Vertices n13 and n22 are connected. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Nodes n14 and n17 are connected by an edge. The graph consist of seven layer/s. Vertices n12 and n19 are connected. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes. Nodes n1 and n15 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(5,n41). in_layer(5,n42). in_layer(5,n43). in_layer(5,n44). in_layer(5,n45). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(6,n49). in_layer(6,n50). in_layer(6,n51). in_layer(6,n52). in_layer(6,n53). in_layer(6,n54). in_layer(6,n55). in_layer(6,n56). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) width(6,8) edge(n1,n10). edge(n1,n13). edge(n1,n15). edge(n12,n19). edge(n12,n20). edge(n12,n22). edge(n13,n22). edge(n14,n17). layers(7).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n1 and n13. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. There is a link between nodes n1 and n10. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Nodes n12 and n22 are connected by an edge. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. There is a link between nodes n12 and n20. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Vertices n13 and n22 are connected. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Nodes n14 and n17 are connected by an edge. The graph consist of seven layer/s. Vertices n12 and n19 are connected. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes. Nodes n1 and n15 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3409351051828349543", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is an edge between nodes n12 and n22. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n1 and n13. Nodes n11 and n27 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is a connection between n12 and n20. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. The graph consist of four layer/s. Vertices n11 and n25 are connected. There is a connection between n14 and n19. Layers 0, 1, 2 and 3 contains eight nodes. There is a connection between n11 and n21. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Vertices n13 and n20 are connected.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n13). edge(n11,n21). edge(n11,n25). edge(n11,n27). edge(n12,n20). edge(n12,n22). edge(n13,n20). edge(n14,n19). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is an edge between nodes n12 and n22. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n1 and n13. Nodes n11 and n27 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is a connection between n12 and n20. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. The graph consist of four layer/s. Vertices n11 and n25 are connected. There is a connection between n14 and n19. Layers 0, 1, 2 and 3 contains eight nodes. There is a connection between n11 and n21. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Vertices n13 and n20 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9072407399345975440", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a link between nodes n10 and n23. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. There is an edge between nodes n1 and n10. Vertices n12 and n21 are connected. There is a connection between n10 and n19. Nodes n10 and n24 are connected by an edge. There is a link between nodes n12 and n20. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is/are six layer/s in the graph. Nodes n1 and n18 are connected by an edge. Nodes n10 and n27 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(5,n49). in_layer(5,n50). in_layer(5,n51). in_layer(5,n52). in_layer(5,n53). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n10). edge(n1,n18). edge(n10,n19). edge(n10,n23). edge(n10,n24). edge(n10,n27). edge(n12,n20). edge(n12,n21). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a link between nodes n10 and n23. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. There is an edge between nodes n1 and n10. Vertices n12 and n21 are connected. There is a connection between n10 and n19. Nodes n10 and n24 are connected by an edge. There is a link between nodes n12 and n20. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is/are six layer/s in the graph. Nodes n1 and n18 are connected by an edge. Nodes n10 and n27 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "102450201450163932", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Vertices n12 and n23 are connected. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. Nodes n11 and n30 are connected by an edge. Nodes n1 and n13 are connected by an edge. Layers 0, 1 and 2 contains eight nodes. The graph has three layer/s. There is a link between nodes n10 and n11. Vertices n10 and n15 are connected. There is a link between nodes n10 and n19. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Nodes n10 and n20 are connected by an edge. There is a link between nodes n12 and n26.", "output": "in_layer(0,n1). in_layer(0,n10). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(1,n18). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(2,n27). in_layer(2,n28). width(0,8) width(1,8) width(2,8) edge(n1,n13). edge(n10,n11). edge(n10,n15). edge(n10,n19). edge(n10,n20). edge(n11,n30). edge(n12,n23). edge(n12,n26). layers(3).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Vertices n12 and n23 are connected. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. Nodes n11 and n30 are connected by an edge. Nodes n1 and n13 are connected by an edge. Layers 0, 1 and 2 contains eight nodes. The graph has three layer/s. There is a link between nodes n10 and n11. Vertices n10 and n15 are connected. There is a link between nodes n10 and n19. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Nodes n10 and n20 are connected by an edge. There is a link between nodes n12 and n26.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2833727423850849814", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n12 and n23. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Nodes n11 and n22 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n1 and n14. Vertices n11 and n26 are connected. There is a link between nodes n1 and n13. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. There is a link between nodes n1 and n11. Vertices n12 and n19 are connected. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. The graph has six layer/s. There is a link between nodes n10 and n20. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(5,n49). in_layer(5,n50). in_layer(5,n51). in_layer(5,n52). in_layer(5,n53). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n11). edge(n1,n13). edge(n1,n14). edge(n10,n20). edge(n11,n22). edge(n11,n26). edge(n12,n19). edge(n12,n23). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n12 and n23. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Nodes n11 and n22 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n1 and n14. Vertices n11 and n26 are connected. There is a link between nodes n1 and n13. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. There is a link between nodes n1 and n11. Vertices n12 and n19 are connected. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. The graph has six layer/s. There is a link between nodes n10 and n20. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "722323643163409624", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. There is a connection between n1 and n16. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a connection between n12 and n18. There is a connection between n11 and n20. The graph has seven layer/s. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a connection between n13 and n22. Vertices n10 and n23 are connected. There is an edge between nodes n10 and n18. Nodes n11 and n19 are connected by an edge. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. There is an edge between nodes n11 and n24. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(5,n41). in_layer(5,n42). in_layer(5,n43). in_layer(5,n44). in_layer(5,n45). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(6,n49). in_layer(6,n50). in_layer(6,n51). in_layer(6,n52). in_layer(6,n53). in_layer(6,n54). in_layer(6,n55). in_layer(6,n56). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) width(6,8) edge(n1,n16). edge(n10,n18). edge(n10,n23). edge(n11,n19). edge(n11,n20). edge(n11,n24). edge(n12,n18). edge(n13,n22). layers(7).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. There is a connection between n1 and n16. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a connection between n12 and n18. There is a connection between n11 and n20. The graph has seven layer/s. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a connection between n13 and n22. Vertices n10 and n23 are connected. There is an edge between nodes n10 and n18. Nodes n11 and n19 are connected by an edge. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. There is an edge between nodes n11 and n24. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "101452051224934528", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Nodes n1 and n15 are connected by an edge. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n10 and n25 are connected by an edge. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. There is a link between nodes n1 and n14. Nodes n11 and n21 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Vertices n11 and n20 are connected. There is an edge between nodes n10 and n21. Vertices n1 and n13 are connected. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. The graph has six layer/s. Vertices n10 and n19 are connected.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(5,n49). in_layer(5,n50). in_layer(5,n51). in_layer(5,n52). in_layer(5,n53). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n13). edge(n1,n14). edge(n1,n15). edge(n10,n19). edge(n10,n21). edge(n10,n25). edge(n11,n20). edge(n11,n21). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Nodes n1 and n15 are connected by an edge. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n10 and n25 are connected by an edge. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. There is a link between nodes n1 and n14. Nodes n11 and n21 are connected by an edge. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Vertices n11 and n20 are connected. There is an edge between nodes n10 and n21. Vertices n1 and n13 are connected. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. The graph has six layer/s. Vertices n10 and n19 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8340347374383624416", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n11 and n21. Nodes n12 and n20 are connected by an edge. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Nodes n1 and n10 are connected by an edge. There is a link between nodes n1 and n11. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a connection between n12 and n18. There is an edge between nodes n10 and n20. There is an edge between nodes n10 and n19. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is an edge between nodes n1 and n15. Layers 0, 1, 2, 3 and 4 contains eight nodes. The graph consist of five layer/s.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) edge(n1,n10). edge(n1,n11). edge(n1,n15). edge(n10,n19). edge(n10,n20). edge(n11,n21). edge(n12,n18). edge(n12,n20). layers(5).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n11 and n21. Nodes n12 and n20 are connected by an edge. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Nodes n1 and n10 are connected by an edge. There is a link between nodes n1 and n11. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a connection between n12 and n18. There is an edge between nodes n10 and n20. There is an edge between nodes n10 and n19. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is an edge between nodes n1 and n15. Layers 0, 1, 2, 3 and 4 contains eight nodes. The graph consist of five layer/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4329582360651537948", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Nodes n1 and n10 are connected by an edge. There is a link between nodes n15 and n17. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a connection between n12 and n23. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes. The graph consist of seven layer/s. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. There is a link between nodes n15 and n21. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. Vertices n11 and n19 are connected. Vertices n13 and n22 are connected. Nodes n11 and n18 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Nodes n15 and n23 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(5,n41). in_layer(5,n42). in_layer(5,n43). in_layer(5,n44). in_layer(5,n45). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(6,n49). in_layer(6,n50). in_layer(6,n51). in_layer(6,n52). in_layer(6,n53). in_layer(6,n54). in_layer(6,n55). in_layer(6,n56). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) width(6,8) edge(n1,n10). edge(n11,n18). edge(n11,n19). edge(n12,n23). edge(n13,n22). edge(n15,n17). edge(n15,n21). edge(n15,n23). layers(7).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Nodes n1 and n10 are connected by an edge. There is a link between nodes n15 and n17. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a connection between n12 and n23. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes. The graph consist of seven layer/s. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. There is a link between nodes n15 and n21. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. Vertices n11 and n19 are connected. Vertices n13 and n22 are connected. Nodes n11 and n18 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Nodes n15 and n23 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1659639459937277601", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is an edge between nodes n11 and n22. The graph consist of four layer/s. Vertices n10 and n17 are connected. There is an edge between nodes n10 and n24. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a link between nodes n12 and n21. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Vertices n12 and n19 are connected. There is an edge between nodes n10 and n21. Layers 0, 1, 2 and 3 contains eight nodes. Vertices n11 and n21 are connected. Vertices n1 and n12 are connected. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n12). edge(n10,n17). edge(n10,n21). edge(n10,n24). edge(n11,n21). edge(n11,n22). edge(n12,n19). edge(n12,n21). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is an edge between nodes n11 and n22. The graph consist of four layer/s. Vertices n10 and n17 are connected. There is an edge between nodes n10 and n24. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is a link between nodes n12 and n21. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Vertices n12 and n19 are connected. There is an edge between nodes n10 and n21. Layers 0, 1, 2 and 3 contains eight nodes. Vertices n11 and n21 are connected. Vertices n1 and n12 are connected. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6543482346255643054", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Vertices n10 and n27 are connected. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Vertices n1 and n18 are connected. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is a link between nodes n11 and n24. There is an edge between nodes n10 and n20. There is a link between nodes n11 and n19. The graph consist of six layer/s. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. There is an edge between nodes n10 and n25. There is an edge between nodes n10 and n24. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n12 and n21 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(5,n49). in_layer(5,n50). in_layer(5,n51). in_layer(5,n52). in_layer(5,n53). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n18). edge(n10,n20). edge(n10,n24). edge(n10,n25). edge(n10,n27). edge(n11,n19). edge(n11,n24). edge(n12,n21). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Vertices n10 and n27 are connected. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Vertices n1 and n18 are connected. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is a link between nodes n11 and n24. There is an edge between nodes n10 and n20. There is a link between nodes n11 and n19. The graph consist of six layer/s. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. There is an edge between nodes n10 and n25. There is an edge between nodes n10 and n24. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n12 and n21 are connected by an edge. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6683227841345451388", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a link between nodes n1 and n18. There is a link between nodes n11 and n26. Layers 0, 1, 2 and 3 contains eight nodes. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. There is an edge between nodes n12 and n23. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Vertices n11 and n30 are connected. There is an edge between nodes n11 and n22. Vertices n12 and n28 are connected. There is/are four layer/s in the graph. Vertices n11 and n25 are connected. There is an edge between nodes n10 and n20. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28.", "output": "in_layer(0,n1). in_layer(0,n10). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(1,n18). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(2,n27). in_layer(2,n28). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(3,n36). in_layer(3,n37). in_layer(3,n38). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n18). edge(n10,n20). edge(n11,n22). edge(n11,n25). edge(n11,n26). edge(n11,n30). edge(n12,n23). edge(n12,n28). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a link between nodes n1 and n18. There is a link between nodes n11 and n26. Layers 0, 1, 2 and 3 contains eight nodes. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. There is an edge between nodes n12 and n23. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Vertices n11 and n30 are connected. There is an edge between nodes n11 and n22. Vertices n12 and n28 are connected. There is/are four layer/s in the graph. Vertices n11 and n25 are connected. There is an edge between nodes n10 and n20. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2802092624383712584", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "The graph has six layer/s. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. There is a connection between n13 and n21. There is a link between nodes n11 and n24. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n10 and n20 are connected by an edge. Vertices n12 and n27 are connected. There is a connection between n1 and n18. There is an edge between nodes n11 and n21. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Vertices n10 and n21 are connected. There is a link between nodes n1 and n15. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(5,n49). in_layer(5,n50). in_layer(5,n51). in_layer(5,n52). in_layer(5,n53). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n15). edge(n1,n18). edge(n10,n20). edge(n10,n21). edge(n11,n21). edge(n11,n24). edge(n12,n27). edge(n13,n21). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```The graph has six layer/s. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. There is a connection between n13 and n21. There is a link between nodes n11 and n24. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n10 and n20 are connected by an edge. Vertices n12 and n27 are connected. There is a connection between n1 and n18. There is an edge between nodes n11 and n21. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Vertices n10 and n21 are connected. There is a link between nodes n1 and n15. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3126985522276730045", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. Nodes n10 and n20 are connected by an edge. Nodes n11 and n24 are connected by an edge. There is/are six layer/s in the graph. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Nodes n1 and n16 are connected by an edge. Nodes n11 and n19 are connected by an edge. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. There is an edge between nodes n11 and n21. Vertices n10 and n21 are connected. Vertices n1 and n13 are connected. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is a connection between n1 and n10. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(5,n49). in_layer(5,n50). in_layer(5,n51). in_layer(5,n52). in_layer(5,n53). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n1,n10). edge(n1,n13). edge(n1,n16). edge(n10,n20). edge(n10,n21). edge(n11,n19). edge(n11,n21). edge(n11,n24). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer five contains nodes n46, n47, n48, n49, n50, n51, n52 and n53. Nodes n10 and n20 are connected by an edge. Nodes n11 and n24 are connected by an edge. There is/are six layer/s in the graph. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Nodes n1 and n16 are connected by an edge. Nodes n11 and n19 are connected by an edge. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. There is an edge between nodes n11 and n21. Vertices n10 and n21 are connected. Vertices n1 and n13 are connected. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. There is a connection between n1 and n10. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "383327090666035157", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is an edge between nodes n12 and n18. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a connection between n13 and n23. There is a connection between n1 and n13. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n12 and n19 are connected. There is a link between nodes n12 and n23. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. There is a connection between n11 and n19. There is a connection between n11 and n20. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. Vertices n12 and n22 are connected. The graph has seven layer/s. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(5,n41). in_layer(5,n42). in_layer(5,n43). in_layer(5,n44). in_layer(5,n45). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). in_layer(6,n49). in_layer(6,n50). in_layer(6,n51). in_layer(6,n52). in_layer(6,n53). in_layer(6,n54). in_layer(6,n55). in_layer(6,n56). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) width(6,8) edge(n1,n13). edge(n11,n19). edge(n11,n20). edge(n12,n18). edge(n12,n19). edge(n12,n22). edge(n12,n23). edge(n13,n23). layers(7).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is an edge between nodes n12 and n18. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is a connection between n13 and n23. There is a connection between n1 and n13. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n12 and n19 are connected. There is a link between nodes n12 and n23. Layers 0, 1, 2, 3, 4, 5 and 6 contains eight nodes. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. There is a connection between n11 and n19. There is a connection between n11 and n20. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. Layer six contains nodes n49, n50, n51, n52, n53, n54, n55 and n56. Vertices n12 and n22 are connected. The graph has seven layer/s. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7249112449718715710", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is an edge between nodes n12 and n19. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. The graph has six layer/s. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Nodes n11 and n19 are connected by an edge. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n12 and n21 are connected by an edge. Nodes n10 and n18 are connected by an edge. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. There is a connection between n12 and n18. Vertices n13 and n20 are connected. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n11 and n22 are connected. There is an edge between nodes n11 and n24.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(5,n41). in_layer(5,n42). in_layer(5,n43). in_layer(5,n44). in_layer(5,n45). in_layer(5,n46). in_layer(5,n47). in_layer(5,n48). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) width(5,8) edge(n10,n18). edge(n11,n19). edge(n11,n22). edge(n11,n24). edge(n12,n18). edge(n12,n19). edge(n12,n21). edge(n13,n20). layers(6).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is an edge between nodes n12 and n19. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. The graph has six layer/s. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. Nodes n11 and n19 are connected by an edge. Layer five contains nodes n41, n42, n43, n44, n45, n46, n47 and n48. Layers 0, 1, 2, 3, 4 and 5 contains eight nodes. Nodes n12 and n21 are connected by an edge. Nodes n10 and n18 are connected by an edge. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. There is a connection between n12 and n18. Vertices n13 and n20 are connected. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Vertices n11 and n22 are connected. There is an edge between nodes n11 and n24.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5539345225928698496", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is an edge between nodes n13 and n18. Nodes n13 and n17 are connected by an edge. There is a connection between n1 and n15. Layers 0, 1, 2, 3 and 4 contains eight nodes. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is/are five layer/s in the graph. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. There is a connection between n10 and n24. Nodes n11 and n23 are connected by an edge. Vertices n1 and n9 are connected. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Vertices n10 and n23 are connected. There is a connection between n13 and n20.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(4,n33). in_layer(4,n34). in_layer(4,n35). in_layer(4,n36). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) edge(n1,n15). edge(n1,n9). edge(n10,n23). edge(n10,n24). edge(n11,n23). edge(n13,n17). edge(n13,n18). edge(n13,n20). layers(5).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. There is an edge between nodes n13 and n18. Nodes n13 and n17 are connected by an edge. There is a connection between n1 and n15. Layers 0, 1, 2, 3 and 4 contains eight nodes. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is/are five layer/s in the graph. Layer four contains nodes n33, n34, n35, n36, n37, n38, n39 and n40. There is a connection between n10 and n24. Nodes n11 and n23 are connected by an edge. Vertices n1 and n9 are connected. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. Vertices n10 and n23 are connected. There is a connection between n13 and n20.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "849103334969600007", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n10 and n27. There is a link between nodes n10 and n25. Nodes n13 and n20 are connected by an edge. There is/are four layer/s in the graph. There is a link between nodes n10 and n22. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Vertices n14 and n19 are connected. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. There is a connection between n13 and n22. Layers 0, 1, 2 and 3 contains eight nodes. Nodes n11 and n25 are connected by an edge. There is a link between nodes n11 and n19.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). width(0,8) width(1,8) width(2,8) width(3,8) edge(n10,n22). edge(n10,n25). edge(n10,n27). edge(n11,n19). edge(n11,n25). edge(n13,n20). edge(n13,n22). edge(n14,n19). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n10 and n27. There is a link between nodes n10 and n25. Nodes n13 and n20 are connected by an edge. There is/are four layer/s in the graph. There is a link between nodes n10 and n22. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Vertices n14 and n19 are connected. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. There is a connection between n13 and n22. Layers 0, 1, 2 and 3 contains eight nodes. Nodes n11 and n25 are connected by an edge. There is a link between nodes n11 and n19.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "481781844756585699", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Nodes n1 and n15 are connected by an edge. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Nodes n1 and n11 are connected by an edge. There is a connection between n1 and n10. Layers 0, 1 and 2 contains eight nodes. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. There is a connection between n10 and n23. There is a connection between n1 and n18. There is a connection between n10 and n25. There is/are three layer/s in the graph. Nodes n1 and n14 are connected by an edge. There is a connection between n1 and n13. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). width(0,8) width(1,8) width(2,8) edge(n1,n10). edge(n1,n11). edge(n1,n13). edge(n1,n14). edge(n1,n15). edge(n1,n18). edge(n10,n23). edge(n10,n25). layers(3).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Nodes n1 and n15 are connected by an edge. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Nodes n1 and n11 are connected by an edge. There is a connection between n1 and n10. Layers 0, 1 and 2 contains eight nodes. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. There is a connection between n10 and n23. There is a connection between n1 and n18. There is a connection between n10 and n25. There is/are three layer/s in the graph. Nodes n1 and n14 are connected by an edge. There is a connection between n1 and n13. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8204858868197846263", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a link between nodes n15 and n22. There is an edge between nodes n1 and n11. Layers 0, 1, 2 and 3 contains eight nodes. There is a link between nodes n15 and n19. Nodes n13 and n22 are connected by an edge. Nodes n13 and n17 are connected by an edge. Vertices n11 and n24 are connected. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is an edge between nodes n12 and n24. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is/are four layer/s in the graph. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Nodes n14 and n20 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n9). in_layer(2,n17). in_layer(2,n18). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(3,n25). in_layer(3,n26). in_layer(3,n27). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n11). edge(n11,n24). edge(n12,n24). edge(n13,n17). edge(n13,n22). edge(n14,n20). edge(n15,n19). edge(n15,n22). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a link between nodes n15 and n22. There is an edge between nodes n1 and n11. Layers 0, 1, 2 and 3 contains eight nodes. There is a link between nodes n15 and n19. Nodes n13 and n22 are connected by an edge. Nodes n13 and n17 are connected by an edge. Vertices n11 and n24 are connected. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n9. There is an edge between nodes n12 and n24. Layer two contains nodes n17, n18, n19, n20, n21, n22, n23 and n24. There is/are four layer/s in the graph. Layer three contains nodes n25, n26, n27, n28, n29, n30, n31 and n32. Nodes n14 and n20 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4797009918786125519", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "There is a connection between n10 and n18. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. There is an edge between nodes n10 and n12. There is an edge between nodes n10 and n13. Layers 0, 1, 2 and 3 contains eight nodes. Nodes n13 and n21 are connected by an edge. Vertices n12 and n29 are connected. There is an edge between nodes n11 and n23. Vertices n12 and n25 are connected. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. There is a link between nodes n11 and n30. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. The graph has four layer/s.", "output": "in_layer(0,n1). in_layer(0,n10). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(1,n18). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(2,n27). in_layer(2,n28). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(3,n36). in_layer(3,n37). in_layer(3,n38). width(0,8) width(1,8) width(2,8) width(3,8) edge(n10,n12). edge(n10,n13). edge(n10,n18). edge(n11,n23). edge(n11,n30). edge(n12,n25). edge(n12,n29). edge(n13,n21). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```There is a connection between n10 and n18. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. There is an edge between nodes n10 and n12. There is an edge between nodes n10 and n13. Layers 0, 1, 2 and 3 contains eight nodes. Nodes n13 and n21 are connected by an edge. Vertices n12 and n29 are connected. There is an edge between nodes n11 and n23. Vertices n12 and n25 are connected. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. There is a link between nodes n11 and n30. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. The graph has four layer/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6077208768118326857", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Vertices n11 and n24 are connected. Vertices n1 and n17 are connected. There is a link between nodes n12 and n26. Nodes n12 and n22 are connected by an edge. There is a connection between n12 and n27. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. The graph has four layer/s. Layers 0, 1, 2 and 3 contains eight nodes. There is a link between nodes n10 and n17. There is a connection between n12 and n28. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. There is an edge between nodes n11 and n21.", "output": "in_layer(0,n1). in_layer(0,n10). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(1,n18). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(2,n27). in_layer(2,n28). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(3,n36). in_layer(3,n37). in_layer(3,n38). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n17). edge(n10,n17). edge(n11,n21). edge(n11,n24). edge(n12,n22). edge(n12,n26). edge(n12,n27). edge(n12,n28). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Vertices n11 and n24 are connected. Vertices n1 and n17 are connected. There is a link between nodes n12 and n26. Nodes n12 and n22 are connected by an edge. There is a connection between n12 and n27. Layer one contains nodes n11, n12, n13, n14, n15, n16, n17 and n18. The graph has four layer/s. Layers 0, 1, 2 and 3 contains eight nodes. There is a link between nodes n10 and n17. There is a connection between n12 and n28. Layer three contains nodes n31, n32, n33, n34, n35, n36, n37 and n38. Layer two contains nodes n21, n22, n23, n24, n25, n26, n27 and n28. Layer zero contains nodes n1, n10, n2, n3, n4, n5, n6 and n7. There is an edge between nodes n11 and n21.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1370786124110360088", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Nodes n1 and n13 are connected by an edge. There is a connection between n1 and n16. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. There is/are four layer/s in the graph. There is a connection between n12 and n27. Nodes n13 and n26 are connected by an edge. Nodes n14 and n21 are connected by an edge. Vertices n12 and n20 are connected. There is a connection between n12 and n19. There is a link between nodes n13 and n23. Layers 0, 1, 2 and 3 contains eight nodes.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). width(0,8) width(1,8) width(2,8) width(3,8) edge(n1,n13). edge(n1,n16). edge(n12,n19). edge(n12,n20). edge(n12,n27). edge(n13,n23). edge(n13,n26). edge(n14,n21). layers(4).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Nodes n1 and n13 are connected by an edge. There is a connection between n1 and n16. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. There is/are four layer/s in the graph. There is a connection between n12 and n27. Nodes n13 and n26 are connected by an edge. Nodes n14 and n21 are connected by an edge. Vertices n12 and n20 are connected. There is a connection between n12 and n19. There is a link between nodes n13 and n23. Layers 0, 1, 2 and 3 contains eight nodes.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3103586899459415620", "problem_id": "0", "problem_name": "Crossing Minimization", "description": "The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.", "format": "The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).", "text": "The graph consist of five layer/s. There is an edge between nodes n12 and n20. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n13 and n22. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Nodes n1 and n17 are connected by an edge. Layers 0, 1, 2, 3 and 4 contains eight nodes. There is an edge between nodes n15 and n22. Nodes n15 and n24 are connected by an edge. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Nodes n10 and n22 are connected by an edge. There is a connection between n12 and n26. Nodes n14 and n23 are connected by an edge.", "output": "in_layer(0,n1). in_layer(0,n2). in_layer(0,n3). in_layer(0,n4). in_layer(0,n5). in_layer(0,n6). in_layer(0,n7). in_layer(0,n8). in_layer(1,n10). in_layer(1,n11). in_layer(1,n12). in_layer(1,n13). in_layer(1,n14). in_layer(1,n15). in_layer(1,n16). in_layer(1,n17). in_layer(2,n19). in_layer(2,n20). in_layer(2,n21). in_layer(2,n22). in_layer(2,n23). in_layer(2,n24). in_layer(2,n25). in_layer(2,n26). in_layer(3,n28). in_layer(3,n29). in_layer(3,n30). in_layer(3,n31). in_layer(3,n32). in_layer(3,n33). in_layer(3,n34). in_layer(3,n35). in_layer(4,n37). in_layer(4,n38). in_layer(4,n39). in_layer(4,n40). in_layer(4,n41). in_layer(4,n42). in_layer(4,n43). in_layer(4,n44). width(0,8) width(1,8) width(2,8) width(3,8) width(4,8) edge(n1,n17). edge(n10,n22). edge(n12,n20). edge(n12,n26). edge(n13,n22). edge(n14,n23). edge(n15,n22). edge(n15,n24). layers(5).", "prompt": "Given the following problem description between triple backtips: \n ```The standard approach for drawing hierarchical network diagrams is a three phase approach in which\n1. nodes in the graph are assigned levels producing a k-level graph;\n2. nodes are assigned an order so as to minimize edge crossings in the k-level graph; and\n3. the edge routes and node positions are computed.\n\nThere has been considerable research into step 2 which is called k-level crossing minimization. Unfortunately this step is NP-hard for even two layers (k = 2) where the ordering on one layer is given. Thus, research has focussed on developing heuristics to solve it. In practice the approach is to iterate through the levels, re-ordering the nodes on each level using heuristic techniques such as the barycentric method. Recently it was shown that modern optimization technology can tackle the complete k-level crossing minimization problem at least for small to medium sized graphs, generating optimal crossings.\n\nA crossing in a graph occurs if there are:\n1. nodes N1, N2 on layer i, and\n2. nodes N3, N4 on layer j, (j <> i), and\n3. edges e1 = (N1,N3), e2 = (N2,N4), and\n4. the position of N1 is antecedent of the position of N2, and\n5. the position of N4 is antecedent of the position of N3.```\nGiven the following specification for the predicates format: \n```The predicates layers/1 and in_layer/2 give the partitioning of nodes into layers. For convenience, width/2 gives the number of nodes in a layer. For example\nlayers(2). width(0, 2). in_layer(0,n1). in_layer(0,n2). width(1, 1). in_layer(1,n3).\ndefines two layers, layer 0 containing nodes {n1, n2} and layer 1 containing {n3}.\nThe predicate edge/2 defines edges between nodes. For example\nedge(n1,n3). edge(n2,n3).```\nExtract the datalog facts from this text: \n```The graph consist of five layer/s. There is an edge between nodes n12 and n20. Layer one contains nodes n10, n11, n12, n13, n14, n15, n16 and n17. Layer zero contains nodes n1, n2, n3, n4, n5, n6, n7 and n8. There is a link between nodes n13 and n22. Layer four contains nodes n37, n38, n39, n40, n41, n42, n43 and n44. Layer three contains nodes n28, n29, n30, n31, n32, n33, n34 and n35. Nodes n1 and n17 are connected by an edge. Layers 0, 1, 2, 3 and 4 contains eight nodes. There is an edge between nodes n15 and n22. Nodes n15 and n24 are connected by an edge. Layer two contains nodes n19, n20, n21, n22, n23, n24, n25 and n26. Nodes n10 and n22 are connected by an edge. There is a connection between n12 and n26. Nodes n14 and n23 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8589789403385113414", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 1 and 3. There is a connection between 1 and 4. There is a connection between 1 and 2. There is an edge between nodes 1 and 5. There is an edge between nodes 10 and 14. There is a link between nodes 10 and 11. There is a link between nodes 10 and 12. There is an edge between nodes 11 and 12.", "output": "edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(10,11). edge(10,12). edge(10,14). edge(11,12).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 3. There is a connection between 1 and 4. There is a connection between 1 and 2. There is an edge between nodes 1 and 5. There is an edge between nodes 10 and 14. There is a link between nodes 10 and 11. There is a link between nodes 10 and 12. There is an edge between nodes 11 and 12.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3870214020413624371", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Vertices 1 and 2 are connected. There is an edge between nodes 10 and 14. Vertices 11 and 12 are connected. There is a link between nodes 10 and 11. Vertices 1 and 3 are connected. Nodes 10 and 12 are connected by an edge. There is a link between nodes 1 and 5. Nodes 1 and 4 are connected by an edge.", "output": "edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(10,11). edge(10,12). edge(10,14). edge(11,12).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Vertices 1 and 2 are connected. There is an edge between nodes 10 and 14. Vertices 11 and 12 are connected. There is a link between nodes 10 and 11. Vertices 1 and 3 are connected. Nodes 10 and 12 are connected by an edge. There is a link between nodes 1 and 5. Nodes 1 and 4 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4405826507276399403", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Nodes 12 and 13 are connected by an edge. There is an edge between nodes 12 and 27. Vertices 1 and 2 are connected. There is an edge between nodes 1 and 27. There is a link between nodes 11 and 12. Vertices 11 and 27 are connected. There is a link between nodes 10 and 11. Nodes 10 and 27 are connected by an edge.", "output": "edge(1,2). edge(1,27). edge(10,11). edge(10,27). edge(11,12). edge(11,27). edge(12,13). edge(12,27).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Nodes 12 and 13 are connected by an edge. There is an edge between nodes 12 and 27. Vertices 1 and 2 are connected. There is an edge between nodes 1 and 27. There is a link between nodes 11 and 12. Vertices 11 and 27 are connected. There is a link between nodes 10 and 11. Nodes 10 and 27 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6452101299807394345", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 1 and 5. There is a link between nodes 10 and 17. There is a link between nodes 11 and 12. There is an edge between nodes 1 and 2. There is a link between nodes 1 and 17. There is an edge between nodes 11 and 15. There is a connection between 10 and 14. There is a connection between 10 and 11.", "output": "edge(1,17). edge(1,2). edge(1,5). edge(10,11). edge(10,14). edge(10,17). edge(11,12). edge(11,15).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 5. There is a link between nodes 10 and 17. There is a link between nodes 11 and 12. There is an edge between nodes 1 and 2. There is a link between nodes 1 and 17. There is an edge between nodes 11 and 15. There is a connection between 10 and 14. There is a connection between 10 and 11.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2388619498378745612", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a connection between 1 and 31. There is a connection between 12 and 13. There is an edge between nodes 11 and 31. There is an edge between nodes 1 and 2. There is a link between nodes 10 and 31. There is a connection between 11 and 12. There is an edge between nodes 12 and 31. There is an edge between nodes 10 and 1.", "output": "edge(1,2). edge(1,31). edge(10,1). edge(10,31). edge(11,12). edge(11,31). edge(12,13). edge(12,31).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 31. There is a connection between 12 and 13. There is an edge between nodes 11 and 31. There is an edge between nodes 1 and 2. There is a link between nodes 10 and 31. There is a connection between 11 and 12. There is an edge between nodes 12 and 31. There is an edge between nodes 10 and 1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "761817642913962803", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Nodes 10 and 6 are connected by an edge. There is an edge between nodes 10 and 15. Nodes 11 and 16 are connected by an edge. Nodes 1 and 6 are connected by an edge. There is a link between nodes 1 and 2. Nodes 11 and 12 are connected by an edge. There is a connection between 12 and 17. There is an edge between nodes 12 and 13.", "output": "edge(1,2). edge(1,6). edge(10,15). edge(10,6). edge(11,12). edge(11,16). edge(12,13). edge(12,17).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Nodes 10 and 6 are connected by an edge. There is an edge between nodes 10 and 15. Nodes 11 and 16 are connected by an edge. Nodes 1 and 6 are connected by an edge. There is a link between nodes 1 and 2. Nodes 11 and 12 are connected by an edge. There is a connection between 12 and 17. There is an edge between nodes 12 and 13.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8710683628498104315", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 10 and 12. Vertices 1 and 4 are connected. There is an edge between nodes 1 and 2. There is an edge between nodes 1 and 7. There is an edge between nodes 1 and 3. There is a connection between 1 and 5. Nodes 10 and 11 are connected by an edge. There is an edge between nodes 1 and 6.", "output": "edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(1,6). edge(1,7). edge(10,11). edge(10,12).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 10 and 12. Vertices 1 and 4 are connected. There is an edge between nodes 1 and 2. There is an edge between nodes 1 and 7. There is an edge between nodes 1 and 3. There is a connection between 1 and 5. Nodes 10 and 11 are connected by an edge. There is an edge between nodes 1 and 6.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5464592994962836808", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Nodes 2 and 10 are connected by an edge. Nodes 2 and 9 are connected by an edge. There is a connection between 1 and 2. There is a connection between 1 and 10. There is a connection between 2 and 11. Vertices 2 and 3 are connected. Vertices 1 and 11 are connected. Nodes 1 and 9 are connected by an edge.", "output": "edge(1,10). edge(1,11). edge(1,2). edge(1,9). edge(2,10). edge(2,11). edge(2,3). edge(2,9).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Nodes 2 and 10 are connected by an edge. Nodes 2 and 9 are connected by an edge. There is a connection between 1 and 2. There is a connection between 1 and 10. There is a connection between 2 and 11. Vertices 2 and 3 are connected. Vertices 1 and 11 are connected. Nodes 1 and 9 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1214162821078293794", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 2 and 3. There is a connection between 1 and 3. There is an edge between nodes 1 and 4. There is a link between nodes 1 and 5. Vertices 2 and 5 are connected. There is a link between nodes 1 and 6. There is an edge between nodes 1 and 2. There is an edge between nodes 2 and 4.", "output": "edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(1,6). edge(2,3). edge(2,4). edge(2,5).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 2 and 3. There is a connection between 1 and 3. There is an edge between nodes 1 and 4. There is a link between nodes 1 and 5. Vertices 2 and 5 are connected. There is a link between nodes 1 and 6. There is an edge between nodes 1 and 2. There is an edge between nodes 2 and 4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8056303387797224166", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 2 and 3. Nodes 1 and 2 are connected by an edge. There is a link between nodes 1 and 12. There is a link between nodes 1 and 10. There is a link between nodes 1 and 11. Vertices 2 and 10 are connected. Vertices 2 and 12 are connected. There is a connection between 2 and 11.", "output": "edge(1,10). edge(1,11). edge(1,12). edge(1,2). edge(2,10). edge(2,11). edge(2,12). edge(2,3).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 2 and 3. Nodes 1 and 2 are connected by an edge. There is a link between nodes 1 and 12. There is a link between nodes 1 and 10. There is a link between nodes 1 and 11. Vertices 2 and 10 are connected. Vertices 2 and 12 are connected. There is a connection between 2 and 11.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3624606165947364862", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 1 and 4. There is an edge between nodes 1 and 11. There is a link between nodes 10 and 15. Vertices 11 and 12 are connected. There is an edge between nodes 1 and 6. Vertices 1 and 5 are connected. There is a connection between 1 and 2. Vertices 1 and 3 are connected.", "output": "edge(1,11). edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(1,6). edge(10,15). edge(11,12).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 4. There is an edge between nodes 1 and 11. There is a link between nodes 10 and 15. Vertices 11 and 12 are connected. There is an edge between nodes 1 and 6. Vertices 1 and 5 are connected. There is a connection between 1 and 2. Vertices 1 and 3 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8194909351910160792", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 10 and 11. There is a link between nodes 10 and 14. Nodes 1 and 2 are connected by an edge. There is an edge between nodes 1 and 4. There is an edge between nodes 1 and 3. Vertices 10 and 12 are connected. Vertices 1 and 5 are connected. Nodes 11 and 12 are connected by an edge.", "output": "edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(10,11). edge(10,12). edge(10,14). edge(11,12).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 10 and 11. There is a link between nodes 10 and 14. Nodes 1 and 2 are connected by an edge. There is an edge between nodes 1 and 4. There is an edge between nodes 1 and 3. Vertices 10 and 12 are connected. Vertices 1 and 5 are connected. Nodes 11 and 12 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7300927476492574663", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 12 and 13. Nodes 11 and 16 are connected by an edge. There is an edge between nodes 12 and 17. There is a connection between 1 and 6. There is an edge between nodes 1 and 2. There is a connection between 10 and 6. There is a link between nodes 11 and 12. Vertices 10 and 15 are connected.", "output": "edge(1,2). edge(1,6). edge(10,15). edge(10,6). edge(11,12). edge(11,16). edge(12,13). edge(12,17).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 12 and 13. Nodes 11 and 16 are connected by an edge. There is an edge between nodes 12 and 17. There is a connection between 1 and 6. There is an edge between nodes 1 and 2. There is a connection between 10 and 6. There is a link between nodes 11 and 12. Vertices 10 and 15 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5757112112714506275", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 10 and 11. There is a link between nodes 1 and 5. There is a link between nodes 1 and 6. There is a link between nodes 1 and 2. There is a connection between 1 and 3. There is an edge between nodes 1 and 7. There is an edge between nodes 1 and 8. There is an edge between nodes 1 and 4.", "output": "edge(1,2). edge(1,3). edge(1,4). edge(1,5). edge(1,6). edge(1,7). edge(1,8). edge(10,11).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 10 and 11. There is a link between nodes 1 and 5. There is a link between nodes 1 and 6. There is a link between nodes 1 and 2. There is a connection between 1 and 3. There is an edge between nodes 1 and 7. There is an edge between nodes 1 and 8. There is an edge between nodes 1 and 4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "836945168027952920", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 10 and 13. There is a link between nodes 1 and 4. There is a connection between 11 and 14. There is a connection between 12 and 15. There is a connection between 12 and 10. There is a link between nodes 1 and 2. There is a link between nodes 10 and 11. There is a connection between 11 and 12.", "output": "edge(1,2). edge(1,4). edge(10,11). edge(10,13). edge(11,12). edge(11,14). edge(12,10). edge(12,15).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 10 and 13. There is a link between nodes 1 and 4. There is a connection between 11 and 14. There is a connection between 12 and 15. There is a connection between 12 and 10. There is a link between nodes 1 and 2. There is a link between nodes 10 and 11. There is a connection between 11 and 12.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "418549404389463628", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Vertices 3 and 7 are connected. There is an edge between nodes 2 and 7. There is a link between nodes 3 and 4. Nodes 2 and 3 are connected by an edge. There is a link between nodes 2 and 8. There is an edge between nodes 1 and 2. There is a link between nodes 1 and 8. Vertices 1 and 7 are connected.", "output": "edge(1,2). edge(1,7). edge(1,8). edge(2,3). edge(2,7). edge(2,8). edge(3,4). edge(3,7).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Vertices 3 and 7 are connected. There is an edge between nodes 2 and 7. There is a link between nodes 3 and 4. Nodes 2 and 3 are connected by an edge. There is a link between nodes 2 and 8. There is an edge between nodes 1 and 2. There is a link between nodes 1 and 8. Vertices 1 and 7 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "326313925397778817", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a connection between 10 and 17. There is an edge between nodes 12 and 19. There is a link between nodes 1 and 8. There is a link between nodes 11 and 12. Nodes 12 and 13 are connected by an edge. There is a link between nodes 1 and 2. There is an edge between nodes 10 and 11. There is an edge between nodes 11 and 18.", "output": "edge(1,2). edge(1,8). edge(10,11). edge(10,17). edge(11,12). edge(11,18). edge(12,13). edge(12,19).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a connection between 10 and 17. There is an edge between nodes 12 and 19. There is a link between nodes 1 and 8. There is a link between nodes 11 and 12. Nodes 12 and 13 are connected by an edge. There is a link between nodes 1 and 2. There is an edge between nodes 10 and 11. There is an edge between nodes 11 and 18.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1937197294964542493", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a connection between 0 and 1. There is an edge between nodes 0 and 12. Nodes 0 and 16 are connected by an edge. There is a link between nodes 0 and 13. There is an edge between nodes 0 and 15. Vertices 0 and 11 are connected. Vertices 0 and 14 are connected. There is a link between nodes 0 and 10.", "output": "edge(0,1). edge(0,10). edge(0,11). edge(0,12). edge(0,13). edge(0,14). edge(0,15). edge(0,16).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a connection between 0 and 1. There is an edge between nodes 0 and 12. Nodes 0 and 16 are connected by an edge. There is a link between nodes 0 and 13. There is an edge between nodes 0 and 15. Vertices 0 and 11 are connected. Vertices 0 and 14 are connected. There is a link between nodes 0 and 10.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4439992195864848472", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Nodes 10 and 15 are connected by an edge. There is a connection between 1 and 6. Vertices 10 and 6 are connected. There is a connection between 12 and 17. There is an edge between nodes 11 and 16. There is a connection between 12 and 13. There is an edge between nodes 11 and 12. Nodes 1 and 2 are connected by an edge.", "output": "edge(1,2). edge(1,6). edge(10,15). edge(10,6). edge(11,12). edge(11,16). edge(12,13). edge(12,17).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Nodes 10 and 15 are connected by an edge. There is a connection between 1 and 6. Vertices 10 and 6 are connected. There is a connection between 12 and 17. There is an edge between nodes 11 and 16. There is a connection between 12 and 13. There is an edge between nodes 11 and 12. Nodes 1 and 2 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6375683148848044494", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Vertices 10 and 11 are connected. Vertices 11 and 12 are connected. There is a link between nodes 1 and 7. There is an edge between nodes 10 and 19. There is an edge between nodes 1 and 2. Vertices 10 and 16 are connected. There is a link between nodes 1 and 19. Nodes 11 and 17 are connected by an edge.", "output": "edge(1,19). edge(1,2). edge(1,7). edge(10,11). edge(10,16). edge(10,19). edge(11,12). edge(11,17).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Vertices 10 and 11 are connected. Vertices 11 and 12 are connected. There is a link between nodes 1 and 7. There is an edge between nodes 10 and 19. There is an edge between nodes 1 and 2. Vertices 10 and 16 are connected. There is a link between nodes 1 and 19. Nodes 11 and 17 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5545984782293312151", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 1 and 28. There is an edge between nodes 10 and 28. Nodes 11 and 28 are connected by an edge. Nodes 12 and 13 are connected by an edge. There is a connection between 12 and 28. There is a link between nodes 11 and 12. Nodes 1 and 2 are connected by an edge. Vertices 10 and 11 are connected.", "output": "edge(1,2). edge(1,28). edge(10,11). edge(10,28). edge(11,12). edge(11,28). edge(12,13). edge(12,28).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 28. There is an edge between nodes 10 and 28. Nodes 11 and 28 are connected by an edge. Nodes 12 and 13 are connected by an edge. There is a connection between 12 and 28. There is a link between nodes 11 and 12. Nodes 1 and 2 are connected by an edge. Vertices 10 and 11 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "637547769068227357", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 1 and 22. There is a connection between 11 and 22. Nodes 11 and 12 are connected by an edge. There is an edge between nodes 12 and 22. There is an edge between nodes 10 and 11. Vertices 12 and 13 are connected. There is a connection between 1 and 2. Vertices 10 and 22 are connected.", "output": "edge(1,2). edge(1,22). edge(10,11). edge(10,22). edge(11,12). edge(11,22). edge(12,13). edge(12,22).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 22. There is a connection between 11 and 22. Nodes 11 and 12 are connected by an edge. There is an edge between nodes 12 and 22. There is an edge between nodes 10 and 11. Vertices 12 and 13 are connected. There is a connection between 1 and 2. Vertices 10 and 22 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "388409953695830613", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 1 and 5. There is a link between nodes 12 and 16. Vertices 11 and 15 are connected. There is a connection between 1 and 2. Nodes 10 and 11 are connected by an edge. Vertices 11 and 12 are connected. Vertices 12 and 9 are connected. There is an edge between nodes 10 and 14.", "output": "edge(1,2). edge(1,5). edge(10,11). edge(10,14). edge(11,12). edge(11,15). edge(12,16). edge(12,9).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 5. There is a link between nodes 12 and 16. Vertices 11 and 15 are connected. There is a connection between 1 and 2. Nodes 10 and 11 are connected by an edge. Vertices 11 and 12 are connected. Vertices 12 and 9 are connected. There is an edge between nodes 10 and 14.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8104955752866478002", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Nodes 0 and 15 are connected by an edge. Nodes 0 and 10 are connected by an edge. There is a connection between 0 and 12. Nodes 0 and 14 are connected by an edge. Nodes 0 and 1 are connected by an edge. Nodes 0 and 11 are connected by an edge. There is a link between nodes 0 and 13. There is an edge between nodes 0 and 2.", "output": "edge(0,1). edge(0,10). edge(0,11). edge(0,12). edge(0,13). edge(0,14). edge(0,15). edge(0,2).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Nodes 0 and 15 are connected by an edge. Nodes 0 and 10 are connected by an edge. There is a connection between 0 and 12. Nodes 0 and 14 are connected by an edge. Nodes 0 and 1 are connected by an edge. Nodes 0 and 11 are connected by an edge. There is a link between nodes 0 and 13. There is an edge between nodes 0 and 2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8217862406528005540", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is an edge between nodes 12 and 25. There is a connection between 10 and 11. There is a connection between 11 and 25. Vertices 10 and 25 are connected. Vertices 1 and 2 are connected. There is an edge between nodes 12 and 13. There is an edge between nodes 11 and 12. There is an edge between nodes 1 and 25.", "output": "edge(1,2). edge(1,25). edge(10,11). edge(10,25). edge(11,12). edge(11,25). edge(12,13). edge(12,25).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is an edge between nodes 12 and 25. There is a connection between 10 and 11. There is a connection between 11 and 25. Vertices 10 and 25 are connected. Vertices 1 and 2 are connected. There is an edge between nodes 12 and 13. There is an edge between nodes 11 and 12. There is an edge between nodes 1 and 25.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6852169433820890241", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 1 and 8. Nodes 2 and 8 are connected by an edge. Nodes 1 and 9 are connected by an edge. Vertices 2 and 9 are connected. There is a connection between 1 and 7. There is a link between nodes 2 and 3. There is a link between nodes 2 and 7. There is a link between nodes 1 and 2.", "output": "edge(1,2). edge(1,7). edge(1,8). edge(1,9). edge(2,3). edge(2,7). edge(2,8). edge(2,9).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 8. Nodes 2 and 8 are connected by an edge. Nodes 1 and 9 are connected by an edge. Vertices 2 and 9 are connected. There is a connection between 1 and 7. There is a link between nodes 2 and 3. There is a link between nodes 2 and 7. There is a link between nodes 1 and 2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2856846239801056541", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a connection between 12 and 18. There is an edge between nodes 10 and 16. There is an edge between nodes 12 and 7. There is a link between nodes 1 and 7. There is a connection between 11 and 12. There is a connection between 1 and 2. Vertices 10 and 11 are connected. Vertices 11 and 17 are connected.", "output": "edge(1,2). edge(1,7). edge(10,11). edge(10,16). edge(11,12). edge(11,17). edge(12,18). edge(12,7).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a connection between 12 and 18. There is an edge between nodes 10 and 16. There is an edge between nodes 12 and 7. There is a link between nodes 1 and 7. There is a connection between 11 and 12. There is a connection between 1 and 2. Vertices 10 and 11 are connected. Vertices 11 and 17 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8860077154207780973", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Vertices 1 and 29 are connected. Nodes 12 and 29 are connected by an edge. There is an edge between nodes 11 and 12. Nodes 11 and 29 are connected by an edge. There is an edge between nodes 1 and 2. Nodes 10 and 29 are connected by an edge. Vertices 12 and 13 are connected. Nodes 10 and 11 are connected by an edge.", "output": "edge(1,2). edge(1,29). edge(10,11). edge(10,29). edge(11,12). edge(11,29). edge(12,13). edge(12,29).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Vertices 1 and 29 are connected. Nodes 12 and 29 are connected by an edge. There is an edge between nodes 11 and 12. Nodes 11 and 29 are connected by an edge. There is an edge between nodes 1 and 2. Nodes 10 and 29 are connected by an edge. Vertices 12 and 13 are connected. Nodes 10 and 11 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1046593530687583150", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "There is a link between nodes 0 and 6. Nodes 0 and 7 are connected by an edge. Nodes 0 and 3 are connected by an edge. Nodes 0 and 4 are connected by an edge. There is a connection between 0 and 1. Vertices 0 and 2 are connected. There is an edge between nodes 0 and 8. There is a connection between 0 and 5.", "output": "edge(0,1). edge(0,2). edge(0,3). edge(0,4). edge(0,5). edge(0,6). edge(0,7). edge(0,8).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```There is a link between nodes 0 and 6. Nodes 0 and 7 are connected by an edge. Nodes 0 and 3 are connected by an edge. Nodes 0 and 4 are connected by an edge. There is a connection between 0 and 1. Vertices 0 and 2 are connected. There is an edge between nodes 0 and 8. There is a connection between 0 and 5.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3858014354974892667", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Nodes 1 and 7 are connected by an edge. There is a link between nodes 2 and 10. Vertices 2 and 3 are connected. There is a link between nodes 1 and 8. There is an edge between nodes 2 and 7. There is an edge between nodes 1 and 2. Nodes 1 and 10 are connected by an edge. There is a connection between 1 and 9.", "output": "edge(1,10). edge(1,2). edge(1,7). edge(1,8). edge(1,9). edge(2,10). edge(2,3). edge(2,7).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Nodes 1 and 7 are connected by an edge. There is a link between nodes 2 and 10. Vertices 2 and 3 are connected. There is a link between nodes 1 and 8. There is an edge between nodes 2 and 7. There is an edge between nodes 1 and 2. Nodes 1 and 10 are connected by an edge. There is a connection between 1 and 9.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9031849425867166553", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Vertices 1 and 13 are connected. Nodes 1 and 2 are connected by an edge. There is a link between nodes 10 and 13. Nodes 11 and 13 are connected by an edge. There is a link between nodes 1 and 14. Nodes 10 and 14 are connected by an edge. Nodes 10 and 11 are connected by an edge. There is a connection between 11 and 12.", "output": "edge(1,13). edge(1,14). edge(1,2). edge(10,11). edge(10,13). edge(10,14). edge(11,12). edge(11,13).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Vertices 1 and 13 are connected. Nodes 1 and 2 are connected by an edge. There is a link between nodes 10 and 13. Nodes 11 and 13 are connected by an edge. There is a link between nodes 1 and 14. Nodes 10 and 14 are connected by an edge. Nodes 10 and 11 are connected by an edge. There is a connection between 11 and 12.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8758692024894524599", "problem_id": "37", "problem_name": "Graceful Graphs", "description": "A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.", "format": "The edges of the graph are provided by instances of the predicate edge/2.", "text": "Vertices 1 and 2 are connected. There is a connection between 10 and 11. There is a link between nodes 12 and 16. Vertices 1 and 5 are connected. There is a connection between 11 and 12. Nodes 11 and 15 are connected by an edge. There is a connection between 10 and 14. There is an edge between nodes 12 and 9.", "output": "edge(1,2). edge(1,5). edge(10,11). edge(10,14). edge(11,12). edge(11,15). edge(12,16). edge(12,9).", "prompt": "Given the following problem description between triple backtips: \n ```A graph (V,E) is called a graceful graph if its vertices V can be labelled with distinct integers from 0 to |E| such that, when each edge is labelled with the absolute difference between its vertex labels, the resulting edge labels are all distinct. The task is to determine the existence of a graceful labelling of a graph.```\nGiven the following specification for the predicates format: \n```The edges of the graph are provided by instances of the predicate edge/2.```\nExtract the datalog facts from this text: \n```Vertices 1 and 2 are connected. There is a connection between 10 and 11. There is a link between nodes 12 and 16. Vertices 1 and 5 are connected. There is a connection between 11 and 12. Nodes 11 and 15 are connected by an edge. There is a connection between 10 and 14. There is an edge between nodes 12 and 9.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5806072744259091836", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 100 is linked to node 104, node 111, node 113, node 124, node 13, node 16, node 17 and node 21. There are fifty-four nodes: node 20, node 58, node 93, node 8, node 29, node 111, node 32, node 17, node 124, node 37, node 112, node 127, node 116, node 2, node 21, node 104, node 23, node 113, node 22, node 75, node 117, node 83, node 1, node 43, node 46, node 4, node 84, node 24, node 50, node 15, node 101, node 130, node 121, node 88, node 16, node 119, node 134, node 120, node 10, node 13, node 100, node 125, node 45, node 53, node 25, node 5, node 131, node 102, node 103, node 36, node 115, node 105, node 27 and node 99. Node 104 is linked to node 100, node 116, node 134, node 36, node 37, node 43, node 5 and node 58. Node 105 is linked to node 101, node 113, node 115, node 116, node 125, node 131, node 24 and node 4. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 1 is linked to node 113, node 125, node 13, node 2, node 21, node 22, node 27 and node 29. Node 10 is linked to node 119, node 20, node 23, node 4, node 84, node 88, node 93 and node 99. Node 102 is linked to node 112, node 117, node 125, node 130, node 15, node 50, node 75 and node 8. Node 103 is linked to node 127, node 25, node 27, node 45, node 46, node 53, node 75 and node 83. Node 101 is linked to node 105, node 111, node 117, node 120, node 121, node 134, node 20 and node 32.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,113) link(1,125) link(1,13) link(1,2) link(1,21) link(1,22) link(1,27) link(1,29) link(10,119) link(10,20) link(10,23) link(10,4) link(10,84) link(10,88) link(10,93) link(10,99) link(100,104) link(100,111) link(100,113) link(100,124) link(100,13) link(100,16) link(100,17) link(100,21) link(101,105) link(101,111) link(101,117) link(101,120) link(101,121) link(101,134) link(101,20) link(101,32) link(102,112) link(102,117) link(102,125) link(102,130) link(102,15) link(102,50) link(102,75) link(102,8) link(103,127) link(103,25) link(103,27) link(103,45) link(103,46) link(103,53) link(103,75) link(103,83) link(104,100) link(104,116) link(104,134) link(104,36) link(104,37) link(104,43) link(104,5) link(104,58) link(105,101) link(105,113) link(105,115) link(105,116) link(105,125) link(105,131) link(105,24) link(105,4) node(20). node(58). node(93). node(8). node(29). node(111). node(32). node(17). node(124). node(37). node(112). node(127). node(116). node(2). node(21). node(104). node(23). node(113). node(22). node(75). node(117). node(83). node(1). node(43). node(46). node(4). node(84). node(24). node(50). node(15). node(101). node(130). node(121). node(88). node(16). node(119). node(134). node(120). node(10). node(13). node(100). node(125). node(45). node(53). node(25). node(5). node(131). node(102). node(103). node(36). node(115). node(105). node(27). node(99).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 100 is linked to node 104, node 111, node 113, node 124, node 13, node 16, node 17 and node 21. There are fifty-four nodes: node 20, node 58, node 93, node 8, node 29, node 111, node 32, node 17, node 124, node 37, node 112, node 127, node 116, node 2, node 21, node 104, node 23, node 113, node 22, node 75, node 117, node 83, node 1, node 43, node 46, node 4, node 84, node 24, node 50, node 15, node 101, node 130, node 121, node 88, node 16, node 119, node 134, node 120, node 10, node 13, node 100, node 125, node 45, node 53, node 25, node 5, node 131, node 102, node 103, node 36, node 115, node 105, node 27 and node 99. Node 104 is linked to node 100, node 116, node 134, node 36, node 37, node 43, node 5 and node 58. Node 105 is linked to node 101, node 113, node 115, node 116, node 125, node 131, node 24 and node 4. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 1 is linked to node 113, node 125, node 13, node 2, node 21, node 22, node 27 and node 29. Node 10 is linked to node 119, node 20, node 23, node 4, node 84, node 88, node 93 and node 99. Node 102 is linked to node 112, node 117, node 125, node 130, node 15, node 50, node 75 and node 8. Node 103 is linked to node 127, node 25, node 27, node 45, node 46, node 53, node 75 and node 83. Node 101 is linked to node 105, node 111, node 117, node 120, node 121, node 134, node 20 and node 32.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "264795368659028870", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 105 is linked to node 100, node 111, node 118, node 125, node 14, node 29, node 3 and node 37. Node 103 is linked to node 115, node 128, node 129, node 40, node 48, node 67, node 69 and node 70. There are fifty-one nodes: node 67, node 38, node 29, node 111, node 114, node 37, node 82, node 112, node 127, node 28, node 116, node 133, node 2, node 21, node 30, node 14, node 104, node 23, node 113, node 106, node 1, node 128, node 11, node 24, node 109, node 63, node 15, node 101, node 48, node 69, node 123, node 118, node 16, node 119, node 120, node 10, node 100, node 45, node 125, node 31, node 129, node 131, node 102, node 19, node 36, node 103, node 70, node 40, node 3, node 115 and node 105. Node 101 is linked to node 11, node 112, node 114, node 120, node 123, node 131, node 21 and node 23. Node 104 is linked to node 116, node 118, node 28, node 38 and node 82. Node 102 is linked to node 106, node 109, node 113, node 119, node 133, node 15, node 28 and node 31. Node 100 is linked to node 1, node 105, node 114, node 133, node 16, node 2, node 30 and node 40. Node 1 is linked to node 100, node 119, node 125, node 19, node 23, node 24, node 28 and node 31. Node 10 is linked to node 116, node 127, node 128, node 21, node 29, node 36, node 45 and node 63. The present colors are: blue0, cyan0, green0, red0 and yellow0.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,100) link(1,119) link(1,125) link(1,19) link(1,23) link(1,24) link(1,28) link(1,31) link(10,116) link(10,127) link(10,128) link(10,21) link(10,29) link(10,36) link(10,45) link(10,63) link(100,1) link(100,105) link(100,114) link(100,133) link(100,16) link(100,2) link(100,30) link(100,40) link(101,11) link(101,112) link(101,114) link(101,120) link(101,123) link(101,131) link(101,21) link(101,23) link(102,106) link(102,109) link(102,113) link(102,119) link(102,133) link(102,15) link(102,28) link(102,31) link(103,115) link(103,128) link(103,129) link(103,40) link(103,48) link(103,67) link(103,69) link(103,70) link(104,116) link(104,118) link(104,28) link(104,38) link(104,82) link(105,100) link(105,111) link(105,118) link(105,125) link(105,14) link(105,29) link(105,3) link(105,37) node(67). node(38). node(29). node(111). node(114). node(37). node(82). node(112). node(127). node(28). node(116). node(133). node(2). node(21). node(30). node(14). node(104). node(23). node(113). node(106). node(1). node(128). node(11). node(24). node(109). node(63). node(15). node(101). node(48). node(69). node(123). node(118). node(16). node(119). node(120). node(10). node(100). node(45). node(125). node(31). node(129). node(131). node(102). node(19). node(36). node(103). node(70). node(40). node(3). node(115). node(105).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 105 is linked to node 100, node 111, node 118, node 125, node 14, node 29, node 3 and node 37. Node 103 is linked to node 115, node 128, node 129, node 40, node 48, node 67, node 69 and node 70. There are fifty-one nodes: node 67, node 38, node 29, node 111, node 114, node 37, node 82, node 112, node 127, node 28, node 116, node 133, node 2, node 21, node 30, node 14, node 104, node 23, node 113, node 106, node 1, node 128, node 11, node 24, node 109, node 63, node 15, node 101, node 48, node 69, node 123, node 118, node 16, node 119, node 120, node 10, node 100, node 45, node 125, node 31, node 129, node 131, node 102, node 19, node 36, node 103, node 70, node 40, node 3, node 115 and node 105. Node 101 is linked to node 11, node 112, node 114, node 120, node 123, node 131, node 21 and node 23. Node 104 is linked to node 116, node 118, node 28, node 38 and node 82. Node 102 is linked to node 106, node 109, node 113, node 119, node 133, node 15, node 28 and node 31. Node 100 is linked to node 1, node 105, node 114, node 133, node 16, node 2, node 30 and node 40. Node 1 is linked to node 100, node 119, node 125, node 19, node 23, node 24, node 28 and node 31. Node 10 is linked to node 116, node 127, node 128, node 21, node 29, node 36, node 45 and node 63. The present colors are: blue0, cyan0, green0, red0 and yellow0.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8205500516427173003", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "There are fifty-two nodes: node 29, node 114, node 124, node 56, node 112, node 133, node 28, node 116, node 14, node 142, node 104, node 23, node 26, node 12, node 1, node 43, node 128, node 145, node 33, node 11, node 24, node 109, node 107, node 122, node 101, node 135, node 138, node 121, node 16, node 148, node 140, node 39, node 119, node 51, node 120, node 10, node 100, node 134, node 144, node 31, node 139, node 25, node 136, node 108, node 102, node 103, node 55, node 49, node 146, node 105, node 110 and node 27. Node 103 is linked to node 102, node 120, node 121, node 122, node 124, node 128, node 140 and node 145. Node 105 is linked to node 11, node 110, node 116, node 12, node 122, node 124, node 136 and node 14. Node 104 is linked to node 112, node 133, node 134, node 142, node 146, node 148, node 29 and node 39. Node 10 is linked to node 107, node 109, node 12, node 121, node 138, node 139, node 16 and node 27. Node 100 is linked to node 1, node 119, node 121, node 124, node 128, node 136, node 25 and node 55. Node 102 is linked to node 103, node 12, node 144, node 26, node 28, node 43, node 51 and node 56. Node 101 is linked to node 1, node 108, node 114, node 140, node 142, node 24, node 31 and node 33. Node 1 is linked to node 100, node 101, node 107, node 120, node 135, node 23, node 28 and node 49. The present colors are: blue0, cyan0, green0, red0 and yellow0.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,100) link(1,101) link(1,107) link(1,120) link(1,135) link(1,23) link(1,28) link(1,49) link(10,107) link(10,109) link(10,12) link(10,121) link(10,138) link(10,139) link(10,16) link(10,27) link(100,1) link(100,119) link(100,121) link(100,124) link(100,128) link(100,136) link(100,25) link(100,55) link(101,1) link(101,108) link(101,114) link(101,140) link(101,142) link(101,24) link(101,31) link(101,33) link(102,103) link(102,12) link(102,144) link(102,26) link(102,28) link(102,43) link(102,51) link(102,56) link(103,102) link(103,120) link(103,121) link(103,122) link(103,124) link(103,128) link(103,140) link(103,145) link(104,112) link(104,133) link(104,134) link(104,142) link(104,146) link(104,148) link(104,29) link(104,39) link(105,11) link(105,110) link(105,116) link(105,12) link(105,122) link(105,124) link(105,136) link(105,14) node(29). node(114). node(124). node(56). node(112). node(133). node(28). node(116). node(14). node(142). node(104). node(23). node(26). node(12). node(1). node(43). node(128). node(145). node(33). node(11). node(24). node(109). node(107). node(122). node(101). node(135). node(138). node(121). node(16). node(148). node(140). node(39). node(119). node(51). node(120). node(10). node(100). node(134). node(144). node(31). node(139). node(25). node(136). node(108). node(102). node(103). node(55). node(49). node(146). node(105). node(110). node(27).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```There are fifty-two nodes: node 29, node 114, node 124, node 56, node 112, node 133, node 28, node 116, node 14, node 142, node 104, node 23, node 26, node 12, node 1, node 43, node 128, node 145, node 33, node 11, node 24, node 109, node 107, node 122, node 101, node 135, node 138, node 121, node 16, node 148, node 140, node 39, node 119, node 51, node 120, node 10, node 100, node 134, node 144, node 31, node 139, node 25, node 136, node 108, node 102, node 103, node 55, node 49, node 146, node 105, node 110 and node 27. Node 103 is linked to node 102, node 120, node 121, node 122, node 124, node 128, node 140 and node 145. Node 105 is linked to node 11, node 110, node 116, node 12, node 122, node 124, node 136 and node 14. Node 104 is linked to node 112, node 133, node 134, node 142, node 146, node 148, node 29 and node 39. Node 10 is linked to node 107, node 109, node 12, node 121, node 138, node 139, node 16 and node 27. Node 100 is linked to node 1, node 119, node 121, node 124, node 128, node 136, node 25 and node 55. Node 102 is linked to node 103, node 12, node 144, node 26, node 28, node 43, node 51 and node 56. Node 101 is linked to node 1, node 108, node 114, node 140, node 142, node 24, node 31 and node 33. Node 1 is linked to node 100, node 101, node 107, node 120, node 135, node 23, node 28 and node 49. The present colors are: blue0, cyan0, green0, red0 and yellow0.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5324547657571388158", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 102 is linked to node 105, node 106, node 110, node 111, node 133, node 25, node 3 and node 31. There are fifty-eight nodes: node 20, node 38, node 74, node 111, node 124, node 82, node 127, node 28, node 133, node 2, node 14, node 81, node 104, node 23, node 42, node 113, node 75, node 106, node 1, node 18, node 33, node 46, node 24, node 109, node 50, node 107, node 15, node 101, node 35, node 121, node 91, node 54, node 60, node 80, node 85, node 39, node 119, node 120, node 100, node 10, node 125, node 31, node 129, node 25, node 108, node 65, node 34, node 102, node 19, node 103, node 49, node 40, node 47, node 7, node 3, node 105, node 110 and node 27. Node 101 is linked to node 15, node 19, node 46, node 65, node 74, node 75, node 85 and node 91. Node 1 is linked to node 109, node 119, node 127, node 33, node 54, node 80, node 81 and node 82. Node 100 is linked to node 113, node 2, node 24, node 25, node 28, node 60 and node 7. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 105 is linked to node 102, node 103, node 111, node 23, node 27, node 35, node 38 and node 42. Node 103 is linked to node 105, node 106, node 109, node 110, node 125, node 33, node 40 and node 46. Node 104 is linked to node 107, node 108, node 124, node 14, node 39, node 47, node 49 and node 50. Node 10 is linked to node 108, node 119, node 120, node 121, node 129, node 18, node 20 and node 34.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,109) link(1,119) link(1,127) link(1,33) link(1,54) link(1,80) link(1,81) link(1,82) link(10,108) link(10,119) link(10,120) link(10,121) link(10,129) link(10,18) link(10,20) link(10,34) link(100,113) link(100,2) link(100,24) link(100,25) link(100,28) link(100,60) link(100,7) link(101,15) link(101,19) link(101,46) link(101,65) link(101,74) link(101,75) link(101,85) link(101,91) link(102,105) link(102,106) link(102,110) link(102,111) link(102,133) link(102,25) link(102,3) link(102,31) link(103,105) link(103,106) link(103,109) link(103,110) link(103,125) link(103,33) link(103,40) link(103,46) link(104,107) link(104,108) link(104,124) link(104,14) link(104,39) link(104,47) link(104,49) link(104,50) link(105,102) link(105,103) link(105,111) link(105,23) link(105,27) link(105,35) link(105,38) link(105,42) node(20). node(38). node(74). node(111). node(124). node(82). node(127). node(28). node(133). node(2). node(14). node(81). node(104). node(23). node(42). node(113). node(75). node(106). node(1). node(18). node(33). node(46). node(24). node(109). node(50). node(107). node(15). node(101). node(35). node(121). node(91). node(54). node(60). node(80). node(85). node(39). node(119). node(120). node(100). node(10). node(125). node(31). node(129). node(25). node(108). node(65). node(34). node(102). node(19). node(103). node(49). node(40). node(47). node(7). node(3). node(105). node(110). node(27).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 102 is linked to node 105, node 106, node 110, node 111, node 133, node 25, node 3 and node 31. There are fifty-eight nodes: node 20, node 38, node 74, node 111, node 124, node 82, node 127, node 28, node 133, node 2, node 14, node 81, node 104, node 23, node 42, node 113, node 75, node 106, node 1, node 18, node 33, node 46, node 24, node 109, node 50, node 107, node 15, node 101, node 35, node 121, node 91, node 54, node 60, node 80, node 85, node 39, node 119, node 120, node 100, node 10, node 125, node 31, node 129, node 25, node 108, node 65, node 34, node 102, node 19, node 103, node 49, node 40, node 47, node 7, node 3, node 105, node 110 and node 27. Node 101 is linked to node 15, node 19, node 46, node 65, node 74, node 75, node 85 and node 91. Node 1 is linked to node 109, node 119, node 127, node 33, node 54, node 80, node 81 and node 82. Node 100 is linked to node 113, node 2, node 24, node 25, node 28, node 60 and node 7. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 105 is linked to node 102, node 103, node 111, node 23, node 27, node 35, node 38 and node 42. Node 103 is linked to node 105, node 106, node 109, node 110, node 125, node 33, node 40 and node 46. Node 104 is linked to node 107, node 108, node 124, node 14, node 39, node 47, node 49 and node 50. Node 10 is linked to node 108, node 119, node 120, node 121, node 129, node 18, node 20 and node 34.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1683249112697663716", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 102 is linked to node 108, node 112, node 125, node 128, node 129, node 134, node 22 and node 36. Node 101 is linked to node 104, node 107, node 11, node 111, node 120, node 122, node 130 and node 136. There are fifty-three nodes: node 111, node 66, node 114, node 112, node 133, node 116, node 21, node 104, node 23, node 26, node 22, node 12, node 117, node 1, node 128, node 145, node 46, node 11, node 6, node 24, node 63, node 107, node 122, node 101, node 135, node 138, node 130, node 123, node 60, node 147, node 118, node 16, node 134, node 120, node 100, node 10, node 125, node 13, node 129, node 25, node 108, node 136, node 150, node 131, node 139, node 102, node 103, node 36, node 3, node 115, node 105, node 126 and node 27. Node 10 is linked to node 108, node 11, node 118, node 135, node 138, node 16, node 24 and node 25. Node 1 is linked to node 111, node 115, node 12, node 147, node 21, node 23, node 24 and node 26. Node 100 is linked to node 116, node 125, node 135, node 46, node 6, node 60, node 63 and node 66. Node 105 is linked to node 114, node 131, node 133, node 139, node 16, node 21, node 36 and node 46. Node 103 is linked to node 111, node 122, node 123, node 133, node 136, node 145, node 27 and node 3. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 104 is linked to node 101, node 117, node 122, node 123, node 126, node 13, node 147 and node 150.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,111) link(1,115) link(1,12) link(1,147) link(1,21) link(1,23) link(1,24) link(1,26) link(10,108) link(10,11) link(10,118) link(10,135) link(10,138) link(10,16) link(10,24) link(10,25) link(100,116) link(100,125) link(100,135) link(100,46) link(100,6) link(100,60) link(100,63) link(100,66) link(101,104) link(101,107) link(101,11) link(101,111) link(101,120) link(101,122) link(101,130) link(101,136) link(102,108) link(102,112) link(102,125) link(102,128) link(102,129) link(102,134) link(102,22) link(102,36) link(103,111) link(103,122) link(103,123) link(103,133) link(103,136) link(103,145) link(103,27) link(103,3) link(104,101) link(104,117) link(104,122) link(104,123) link(104,126) link(104,13) link(104,147) link(104,150) link(105,114) link(105,131) link(105,133) link(105,139) link(105,16) link(105,21) link(105,36) link(105,46) node(111). node(66). node(114). node(112). node(133). node(116). node(21). node(104). node(23). node(26). node(22). node(12). node(117). node(1). node(128). node(145). node(46). node(11). node(6). node(24). node(63). node(107). node(122). node(101). node(135). node(138). node(130). node(123). node(60). node(147). node(118). node(16). node(134). node(120). node(100). node(10). node(125). node(13). node(129). node(25). node(108). node(136). node(150). node(131). node(139). node(102). node(103). node(36). node(3). node(115). node(105). node(126). node(27).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 102 is linked to node 108, node 112, node 125, node 128, node 129, node 134, node 22 and node 36. Node 101 is linked to node 104, node 107, node 11, node 111, node 120, node 122, node 130 and node 136. There are fifty-three nodes: node 111, node 66, node 114, node 112, node 133, node 116, node 21, node 104, node 23, node 26, node 22, node 12, node 117, node 1, node 128, node 145, node 46, node 11, node 6, node 24, node 63, node 107, node 122, node 101, node 135, node 138, node 130, node 123, node 60, node 147, node 118, node 16, node 134, node 120, node 100, node 10, node 125, node 13, node 129, node 25, node 108, node 136, node 150, node 131, node 139, node 102, node 103, node 36, node 3, node 115, node 105, node 126 and node 27. Node 10 is linked to node 108, node 11, node 118, node 135, node 138, node 16, node 24 and node 25. Node 1 is linked to node 111, node 115, node 12, node 147, node 21, node 23, node 24 and node 26. Node 100 is linked to node 116, node 125, node 135, node 46, node 6, node 60, node 63 and node 66. Node 105 is linked to node 114, node 131, node 133, node 139, node 16, node 21, node 36 and node 46. Node 103 is linked to node 111, node 122, node 123, node 133, node 136, node 145, node 27 and node 3. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 104 is linked to node 101, node 117, node 122, node 123, node 126, node 13, node 147 and node 150.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4346214229902489753", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 105 is linked to node 108, node 112, node 122, node 126, node 22, node 4, node 46 and node 48. There are fifty-two nodes: node 20, node 67, node 17, node 114, node 112, node 133, node 127, node 2, node 30, node 104, node 22, node 106, node 12, node 117, node 1, node 18, node 46, node 4, node 11, node 109, node 107, node 122, node 101, node 135, node 48, node 137, node 35, node 121, node 123, node 118, node 16, node 140, node 85, node 134, node 120, node 125, node 13, node 100, node 10, node 45, node 25, node 108, node 131, node 102, node 19, node 103, node 40, node 115, node 105, node 126, node 56 and node 87. Node 10 is linked to node 102, node 120, node 121, node 125, node 13, node 135, node 140 and node 20. Node 102 is linked to node 10, node 122, node 123, node 127, node 134, node 135, node 137 and node 16. Node 104 is linked to node 106, node 115, node 117, node 122, node 17, node 22, node 35 and node 40. Node 101 is linked to node 11, node 114, node 16, node 18, node 20, node 22, node 30 and node 56. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 1 is linked to node 108, node 12, node 13, node 135, node 16, node 19, node 2 and node 30. Node 103 is linked to node 114, node 131, node 45, node 48, node 56, node 67, node 85 and node 87. Node 100 is linked to node 106, node 107, node 109, node 112, node 117, node 118, node 133 and node 25.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,108) link(1,12) link(1,13) link(1,135) link(1,16) link(1,19) link(1,2) link(1,30) link(10,102) link(10,120) link(10,121) link(10,125) link(10,13) link(10,135) link(10,140) link(10,20) link(100,106) link(100,107) link(100,109) link(100,112) link(100,117) link(100,118) link(100,133) link(100,25) link(101,11) link(101,114) link(101,16) link(101,18) link(101,20) link(101,22) link(101,30) link(101,56) link(102,10) link(102,122) link(102,123) link(102,127) link(102,134) link(102,135) link(102,137) link(102,16) link(103,114) link(103,131) link(103,45) link(103,48) link(103,56) link(103,67) link(103,85) link(103,87) link(104,106) link(104,115) link(104,117) link(104,122) link(104,17) link(104,22) link(104,35) link(104,40) link(105,108) link(105,112) link(105,122) link(105,126) link(105,22) link(105,4) link(105,46) link(105,48) node(20). node(67). node(17). node(114). node(112). node(133). node(127). node(2). node(30). node(104). node(22). node(106). node(12). node(117). node(1). node(18). node(46). node(4). node(11). node(109). node(107). node(122). node(101). node(135). node(48). node(137). node(35). node(121). node(123). node(118). node(16). node(140). node(85). node(134). node(120). node(125). node(13). node(100). node(10). node(45). node(25). node(108). node(131). node(102). node(19). node(103). node(40). node(115). node(105). node(126). node(56). node(87).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 105 is linked to node 108, node 112, node 122, node 126, node 22, node 4, node 46 and node 48. There are fifty-two nodes: node 20, node 67, node 17, node 114, node 112, node 133, node 127, node 2, node 30, node 104, node 22, node 106, node 12, node 117, node 1, node 18, node 46, node 4, node 11, node 109, node 107, node 122, node 101, node 135, node 48, node 137, node 35, node 121, node 123, node 118, node 16, node 140, node 85, node 134, node 120, node 125, node 13, node 100, node 10, node 45, node 25, node 108, node 131, node 102, node 19, node 103, node 40, node 115, node 105, node 126, node 56 and node 87. Node 10 is linked to node 102, node 120, node 121, node 125, node 13, node 135, node 140 and node 20. Node 102 is linked to node 10, node 122, node 123, node 127, node 134, node 135, node 137 and node 16. Node 104 is linked to node 106, node 115, node 117, node 122, node 17, node 22, node 35 and node 40. Node 101 is linked to node 11, node 114, node 16, node 18, node 20, node 22, node 30 and node 56. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 1 is linked to node 108, node 12, node 13, node 135, node 16, node 19, node 2 and node 30. Node 103 is linked to node 114, node 131, node 45, node 48, node 56, node 67, node 85 and node 87. Node 100 is linked to node 106, node 107, node 109, node 112, node 117, node 118, node 133 and node 25.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1655555861299930173", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 13 is linked to node 10, node 11, node 12, node 14, node 15, node 16, node 20 and node 21. Node 10 is linked to node 1, node 11, node 12, node 13, node 14, node 15, node 16 and node 17. Node 11 is linked to node 10, node 12, node 13, node 14, node 15, node 16, node 18 and node 19. Node 12 is linked to node 10, node 11, node 13, node 14, node 15, node 16, node 19 and node 20. There are twenty-one nodes: node 20, node 17, node 28, node 2, node 14, node 21, node 23, node 22, node 12, node 1, node 18, node 33, node 11, node 24, node 15, node 16, node 10, node 13, node 25, node 19 and node 3. Node 16 is linked to node 10, node 11, node 12, node 13, node 14, node 15, node 23 and node 24. Node 1 is linked to node 10, node 17, node 19, node 2, node 25, node 28, node 3 and node 33. The present colors are: c1, c2, c3, c4, c5, c6, c7 and c8. Node 15 is linked to node 10, node 11, node 12, node 13, node 14, node 16, node 22 and node 23. Node 14 is linked to node 10, node 11, node 12, node 13, node 15, node 16, node 21 and node 22.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). colour(c7). colour(c8). link(1,10) link(1,17) link(1,19) link(1,2) link(1,25) link(1,28) link(1,3) link(1,33) link(10,1) link(10,11) link(10,12) link(10,13) link(10,14) link(10,15) link(10,16) link(10,17) link(11,10) link(11,12) link(11,13) link(11,14) link(11,15) link(11,16) link(11,18) link(11,19) link(12,10) link(12,11) link(12,13) link(12,14) link(12,15) link(12,16) link(12,19) link(12,20) link(13,10) link(13,11) link(13,12) link(13,14) link(13,15) link(13,16) link(13,20) link(13,21) link(14,10) link(14,11) link(14,12) link(14,13) link(14,15) link(14,16) link(14,21) link(14,22) link(15,10) link(15,11) link(15,12) link(15,13) link(15,14) link(15,16) link(15,22) link(15,23) link(16,10) link(16,11) link(16,12) link(16,13) link(16,14) link(16,15) link(16,23) link(16,24) node(20). node(17). node(28). node(2). node(14). node(21). node(23). node(22). node(12). node(1). node(18). node(33). node(11). node(24). node(15). node(16). node(10). node(13). node(25). node(19). node(3).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 13 is linked to node 10, node 11, node 12, node 14, node 15, node 16, node 20 and node 21. Node 10 is linked to node 1, node 11, node 12, node 13, node 14, node 15, node 16 and node 17. Node 11 is linked to node 10, node 12, node 13, node 14, node 15, node 16, node 18 and node 19. Node 12 is linked to node 10, node 11, node 13, node 14, node 15, node 16, node 19 and node 20. There are twenty-one nodes: node 20, node 17, node 28, node 2, node 14, node 21, node 23, node 22, node 12, node 1, node 18, node 33, node 11, node 24, node 15, node 16, node 10, node 13, node 25, node 19 and node 3. Node 16 is linked to node 10, node 11, node 12, node 13, node 14, node 15, node 23 and node 24. Node 1 is linked to node 10, node 17, node 19, node 2, node 25, node 28, node 3 and node 33. The present colors are: c1, c2, c3, c4, c5, c6, c7 and c8. Node 15 is linked to node 10, node 11, node 12, node 13, node 14, node 16, node 22 and node 23. Node 14 is linked to node 10, node 11, node 12, node 13, node 15, node 16, node 21 and node 22.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "387107511835475077", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 104 is linked to node 27, node 39, node 46, node 61, node 81, node 85, node 95 and node 97. Node 103 is linked to node 123, node 13, node 17, node 21, node 23, node 50, node 54 and node 64. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 101 is linked to node 120, node 14, node 16, node 18, node 24, node 28, node 40 and node 46. Node 100 is linked to node 107, node 124, node 27, node 32, node 44, node 57, node 6 and node 61. Node 1 is linked to node 18, node 21, node 22, node 27, node 3, node 50, node 54 and node 60. There are fifty-four nodes: node 8, node 111, node 32, node 17, node 124, node 95, node 28, node 14, node 21, node 104, node 81, node 23, node 42, node 22, node 117, node 12, node 18, node 1, node 52, node 92, node 46, node 6, node 24, node 50, node 63, node 107, node 101, node 123, node 54, node 60, node 16, node 44, node 85, node 97, node 39, node 119, node 51, node 120, node 100, node 10, node 45, node 61, node 13, node 108, node 102, node 64, node 103, node 41, node 40, node 3, node 115, node 105, node 27 and node 57. Node 102 is linked to node 117, node 119, node 123, node 17, node 50, node 51, node 61 and node 63. Node 105 is linked to node 108, node 115, node 117, node 12, node 22, node 41, node 52 and node 92. Node 10 is linked to node 111, node 16, node 22, node 39, node 42, node 45, node 64 and node 8.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,18) link(1,21) link(1,22) link(1,27) link(1,3) link(1,50) link(1,54) link(1,60) link(10,111) link(10,16) link(10,22) link(10,39) link(10,42) link(10,45) link(10,64) link(10,8) link(100,107) link(100,124) link(100,27) link(100,32) link(100,44) link(100,57) link(100,6) link(100,61) link(101,120) link(101,14) link(101,16) link(101,18) link(101,24) link(101,28) link(101,40) link(101,46) link(102,117) link(102,119) link(102,123) link(102,17) link(102,50) link(102,51) link(102,61) link(102,63) link(103,123) link(103,13) link(103,17) link(103,21) link(103,23) link(103,50) link(103,54) link(103,64) link(104,27) link(104,39) link(104,46) link(104,61) link(104,81) link(104,85) link(104,95) link(104,97) link(105,108) link(105,115) link(105,117) link(105,12) link(105,22) link(105,41) link(105,52) link(105,92) node(8). node(111). node(32). node(17). node(124). node(95). node(28). node(14). node(21). node(104). node(81). node(23). node(42). node(22). node(117). node(12). node(18). node(1). node(52). node(92). node(46). node(6). node(24). node(50). node(63). node(107). node(101). node(123). node(54). node(60). node(16). node(44). node(85). node(97). node(39). node(119). node(51). node(120). node(100). node(10). node(45). node(61). node(13). node(108). node(102). node(64). node(103). node(41). node(40). node(3). node(115). node(105). node(27). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 104 is linked to node 27, node 39, node 46, node 61, node 81, node 85, node 95 and node 97. Node 103 is linked to node 123, node 13, node 17, node 21, node 23, node 50, node 54 and node 64. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 101 is linked to node 120, node 14, node 16, node 18, node 24, node 28, node 40 and node 46. Node 100 is linked to node 107, node 124, node 27, node 32, node 44, node 57, node 6 and node 61. Node 1 is linked to node 18, node 21, node 22, node 27, node 3, node 50, node 54 and node 60. There are fifty-four nodes: node 8, node 111, node 32, node 17, node 124, node 95, node 28, node 14, node 21, node 104, node 81, node 23, node 42, node 22, node 117, node 12, node 18, node 1, node 52, node 92, node 46, node 6, node 24, node 50, node 63, node 107, node 101, node 123, node 54, node 60, node 16, node 44, node 85, node 97, node 39, node 119, node 51, node 120, node 100, node 10, node 45, node 61, node 13, node 108, node 102, node 64, node 103, node 41, node 40, node 3, node 115, node 105, node 27 and node 57. Node 102 is linked to node 117, node 119, node 123, node 17, node 50, node 51, node 61 and node 63. Node 105 is linked to node 108, node 115, node 117, node 12, node 22, node 41, node 52 and node 92. Node 10 is linked to node 111, node 16, node 22, node 39, node 42, node 45, node 64 and node 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5243134921010722969", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 100 is linked to node 110, node 18, node 33, node 34, node 36, node 51, node 54 and node 61. There are twenty-eight nodes: node 74, node 32, node 95, node 104, node 12, node 1, node 18, node 33, node 84, node 73, node 101, node 72, node 54, node 51, node 100, node 61, node 10, node 13, node 77, node 34, node 102, node 103, node 36, node 70, node 98, node 105, node 110 and node 57. Node 105 is linked to node 18 and node 74. Node 104 is linked to node 12, node 61 and node 95. Node 1 is linked to node 36. Node 103 is linked to node 13, node 18 and node 36. Node 10 is linked to node 95 and node 98. Node 101 is linked to node 32, node 57, node 70, node 72, node 73 and node 77. The present colors are: c1, c10, c11, c2, c3, c4, c5 and c6. Node 102 is linked to node 72 and node 84.", "output": "colour(c1). colour(c10). colour(c11). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). link(1,36) link(10,95) link(10,98) link(100,110) link(100,18) link(100,33) link(100,34) link(100,36) link(100,51) link(100,54) link(100,61) link(101,32) link(101,57) link(101,70) link(101,72) link(101,73) link(101,77) link(102,72) link(102,84) link(103,13) link(103,18) link(103,36) link(104,12) link(104,61) link(104,95) link(105,18) link(105,74) node(74). node(32). node(95). node(104). node(12). node(1). node(18). node(33). node(84). node(73). node(101). node(72). node(54). node(51). node(100). node(61). node(10). node(13). node(77). node(34). node(102). node(103). node(36). node(70). node(98). node(105). node(110). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 100 is linked to node 110, node 18, node 33, node 34, node 36, node 51, node 54 and node 61. There are twenty-eight nodes: node 74, node 32, node 95, node 104, node 12, node 1, node 18, node 33, node 84, node 73, node 101, node 72, node 54, node 51, node 100, node 61, node 10, node 13, node 77, node 34, node 102, node 103, node 36, node 70, node 98, node 105, node 110 and node 57. Node 105 is linked to node 18 and node 74. Node 104 is linked to node 12, node 61 and node 95. Node 1 is linked to node 36. Node 103 is linked to node 13, node 18 and node 36. Node 10 is linked to node 95 and node 98. Node 101 is linked to node 32, node 57, node 70, node 72, node 73 and node 77. The present colors are: c1, c10, c11, c2, c3, c4, c5 and c6. Node 102 is linked to node 72 and node 84.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1126933403755321644", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "There are fifty-seven nodes: node 20, node 67, node 38, node 111, node 17, node 114, node 62, node 124, node 56, node 112, node 116, node 14, node 21, node 30, node 104, node 89, node 23, node 42, node 113, node 22, node 52, node 12, node 43, node 1, node 46, node 4, node 33, node 11, node 73, node 24, node 109, node 107, node 15, node 101, node 79, node 35, node 121, node 123, node 54, node 118, node 16, node 97, node 119, node 51, node 120, node 100, node 10, node 45, node 65, node 102, node 64, node 103, node 3, node 105, node 110, node 27 and node 57. Node 101 is linked to node 114, node 119, node 15, node 30, node 42, node 46, node 57 and node 64. Node 104 is linked to node 124, node 35, node 43, node 62, node 67, node 79, node 89 and node 97. Node 102 is linked to node 105, node 109, node 110, node 118, node 123, node 20, node 21 and node 27. Node 100 is linked to node 107, node 109, node 12, node 121, node 16, node 17, node 4 and node 45. Node 10 is linked to node 121, node 124, node 14, node 3, node 30, node 42, node 51 and node 52. Node 105 is linked to node 102, node 11, node 113, node 15, node 22, node 23, node 27 and node 38. Node 103 is linked to node 112, node 114, node 116, node 120, node 24, node 33, node 52 and node 56. Node 1 is linked to node 111, node 120, node 43, node 54, node 65, node 73 and node 97. The present colors are: blue0, cyan0, green0, red0 and yellow0.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,111) link(1,120) link(1,43) link(1,54) link(1,65) link(1,73) link(1,97) link(10,121) link(10,124) link(10,14) link(10,3) link(10,30) link(10,42) link(10,51) link(10,52) link(100,107) link(100,109) link(100,12) link(100,121) link(100,16) link(100,17) link(100,4) link(100,45) link(101,114) link(101,119) link(101,15) link(101,30) link(101,42) link(101,46) link(101,57) link(101,64) link(102,105) link(102,109) link(102,110) link(102,118) link(102,123) link(102,20) link(102,21) link(102,27) link(103,112) link(103,114) link(103,116) link(103,120) link(103,24) link(103,33) link(103,52) link(103,56) link(104,124) link(104,35) link(104,43) link(104,62) link(104,67) link(104,79) link(104,89) link(104,97) link(105,102) link(105,11) link(105,113) link(105,15) link(105,22) link(105,23) link(105,27) link(105,38) node(20). node(67). node(38). node(111). node(17). node(114). node(62). node(124). node(56). node(112). node(116). node(14). node(21). node(30). node(104). node(89). node(23). node(42). node(113). node(22). node(52). node(12). node(43). node(1). node(46). node(4). node(33). node(11). node(73). node(24). node(109). node(107). node(15). node(101). node(79). node(35). node(121). node(123). node(54). node(118). node(16). node(97). node(119). node(51). node(120). node(100). node(10). node(45). node(65). node(102). node(64). node(103). node(3). node(105). node(110). node(27). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```There are fifty-seven nodes: node 20, node 67, node 38, node 111, node 17, node 114, node 62, node 124, node 56, node 112, node 116, node 14, node 21, node 30, node 104, node 89, node 23, node 42, node 113, node 22, node 52, node 12, node 43, node 1, node 46, node 4, node 33, node 11, node 73, node 24, node 109, node 107, node 15, node 101, node 79, node 35, node 121, node 123, node 54, node 118, node 16, node 97, node 119, node 51, node 120, node 100, node 10, node 45, node 65, node 102, node 64, node 103, node 3, node 105, node 110, node 27 and node 57. Node 101 is linked to node 114, node 119, node 15, node 30, node 42, node 46, node 57 and node 64. Node 104 is linked to node 124, node 35, node 43, node 62, node 67, node 79, node 89 and node 97. Node 102 is linked to node 105, node 109, node 110, node 118, node 123, node 20, node 21 and node 27. Node 100 is linked to node 107, node 109, node 12, node 121, node 16, node 17, node 4 and node 45. Node 10 is linked to node 121, node 124, node 14, node 3, node 30, node 42, node 51 and node 52. Node 105 is linked to node 102, node 11, node 113, node 15, node 22, node 23, node 27 and node 38. Node 103 is linked to node 112, node 114, node 116, node 120, node 24, node 33, node 52 and node 56. Node 1 is linked to node 111, node 120, node 43, node 54, node 65, node 73 and node 97. The present colors are: blue0, cyan0, green0, red0 and yellow0.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1048511644314016249", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 105 is linked to node 127, node 135, node 145, node 17, node 19, node 42, node 59 and node 85. There are fifty-eight nodes: node 111, node 29, node 17, node 114, node 112, node 133, node 127, node 104, node 42, node 22, node 106, node 52, node 117, node 1, node 18, node 128, node 145, node 92, node 33, node 11, node 132, node 122, node 101, node 69, node 138, node 79, node 15, node 130, node 135, node 121, node 60, node 118, node 140, node 85, node 39, node 134, node 119, node 59, node 10, node 100, node 125, node 45, node 13, node 129, node 139, node 131, node 65, node 108, node 102, node 141, node 103, node 19, node 49, node 40, node 143, node 105, node 110 and node 144. Node 101 is linked to node 108, node 110, node 122, node 138, node 143, node 33, node 39 and node 45. Node 10 is linked to node 104, node 111, node 118, node 121, node 125, node 128, node 131 and node 132. Node 103 is linked to node 106, node 125, node 13, node 131, node 133, node 15, node 45 and node 60. Node 100 is linked to node 134, node 22, node 29, node 40, node 52, node 69, node 79 and node 92. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 1 is linked to node 119, node 125, node 139, node 140, node 141, node 144, node 49 and node 65. Node 102 is linked to node 11, node 110, node 117, node 118, node 119, node 129, node 134 and node 143. Node 104 is linked to node 10, node 11, node 112, node 114, node 130, node 139, node 15 and node 18.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,119) link(1,125) link(1,139) link(1,140) link(1,141) link(1,144) link(1,49) link(1,65) link(10,104) link(10,111) link(10,118) link(10,121) link(10,125) link(10,128) link(10,131) link(10,132) link(100,134) link(100,22) link(100,29) link(100,40) link(100,52) link(100,69) link(100,79) link(100,92) link(101,108) link(101,110) link(101,122) link(101,138) link(101,143) link(101,33) link(101,39) link(101,45) link(102,11) link(102,110) link(102,117) link(102,118) link(102,119) link(102,129) link(102,134) link(102,143) link(103,106) link(103,125) link(103,13) link(103,131) link(103,133) link(103,15) link(103,45) link(103,60) link(104,10) link(104,11) link(104,112) link(104,114) link(104,130) link(104,139) link(104,15) link(104,18) link(105,127) link(105,135) link(105,145) link(105,17) link(105,19) link(105,42) link(105,59) link(105,85) node(111). node(29). node(17). node(114). node(112). node(133). node(127). node(104). node(42). node(22). node(106). node(52). node(117). node(1). node(18). node(128). node(145). node(92). node(33). node(11). node(132). node(122). node(101). node(69). node(138). node(79). node(15). node(130). node(135). node(121). node(60). node(118). node(140). node(85). node(39). node(134). node(119). node(59). node(10). node(100). node(125). node(45). node(13). node(129). node(139). node(131). node(65). node(108). node(102). node(141). node(103). node(19). node(49). node(40). node(143). node(105). node(110). node(144).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 105 is linked to node 127, node 135, node 145, node 17, node 19, node 42, node 59 and node 85. There are fifty-eight nodes: node 111, node 29, node 17, node 114, node 112, node 133, node 127, node 104, node 42, node 22, node 106, node 52, node 117, node 1, node 18, node 128, node 145, node 92, node 33, node 11, node 132, node 122, node 101, node 69, node 138, node 79, node 15, node 130, node 135, node 121, node 60, node 118, node 140, node 85, node 39, node 134, node 119, node 59, node 10, node 100, node 125, node 45, node 13, node 129, node 139, node 131, node 65, node 108, node 102, node 141, node 103, node 19, node 49, node 40, node 143, node 105, node 110 and node 144. Node 101 is linked to node 108, node 110, node 122, node 138, node 143, node 33, node 39 and node 45. Node 10 is linked to node 104, node 111, node 118, node 121, node 125, node 128, node 131 and node 132. Node 103 is linked to node 106, node 125, node 13, node 131, node 133, node 15, node 45 and node 60. Node 100 is linked to node 134, node 22, node 29, node 40, node 52, node 69, node 79 and node 92. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 1 is linked to node 119, node 125, node 139, node 140, node 141, node 144, node 49 and node 65. Node 102 is linked to node 11, node 110, node 117, node 118, node 119, node 129, node 134 and node 143. Node 104 is linked to node 10, node 11, node 112, node 114, node 130, node 139, node 15 and node 18.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6507669140266475784", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 103 is linked to node 100, node 101, node 102, node 104, node 115, node 116, node 117 and node 12. Node 10 is linked to node 1, node 101, node 106, node 11, node 114, node 118, node 12 and node 127. There are twenty-seven nodes: node 111, node 114, node 124, node 112, node 127, node 116, node 104, node 113, node 106, node 12, node 117, node 1, node 128, node 11, node 109, node 107, node 101, node 118, node 100, node 13, node 10, node 108, node 102, node 103, node 115, node 105 and node 110. Node 105 is linked to node 1, node 106, node 107, node 108, node 109, node 110, node 111 and node 112. Node 102 is linked to node 100, node 101, node 103, node 104, node 11, node 114, node 115 and node 116. Node 104 is linked to node 100, node 101, node 102, node 103, node 116, node 117, node 128 and node 13. Node 100 is linked to node 101, node 102, node 103, node 104, node 112, node 113, node 114 and node 124. Node 101 is linked to node 10, node 100, node 102, node 103, node 104, node 113, node 114 and node 115. Node 1 is linked to node 10, node 105, node 11, node 113, node 118, node 12, node 127 and node 13. The present colors are: c1, c10, c11, c12, c13, c2, c3 and c4.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c2). colour(c3). colour(c4). link(1,10) link(1,105) link(1,11) link(1,113) link(1,118) link(1,12) link(1,127) link(1,13) link(10,1) link(10,101) link(10,106) link(10,11) link(10,114) link(10,118) link(10,12) link(10,127) link(100,101) link(100,102) link(100,103) link(100,104) link(100,112) link(100,113) link(100,114) link(100,124) link(101,10) link(101,100) link(101,102) link(101,103) link(101,104) link(101,113) link(101,114) link(101,115) link(102,100) link(102,101) link(102,103) link(102,104) link(102,11) link(102,114) link(102,115) link(102,116) link(103,100) link(103,101) link(103,102) link(103,104) link(103,115) link(103,116) link(103,117) link(103,12) link(104,100) link(104,101) link(104,102) link(104,103) link(104,116) link(104,117) link(104,128) link(104,13) link(105,1) link(105,106) link(105,107) link(105,108) link(105,109) link(105,110) link(105,111) link(105,112) node(111). node(114). node(124). node(112). node(127). node(116). node(104). node(113). node(106). node(12). node(117). node(1). node(128). node(11). node(109). node(107). node(101). node(118). node(100). node(13). node(10). node(108). node(102). node(103). node(115). node(105). node(110).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 103 is linked to node 100, node 101, node 102, node 104, node 115, node 116, node 117 and node 12. Node 10 is linked to node 1, node 101, node 106, node 11, node 114, node 118, node 12 and node 127. There are twenty-seven nodes: node 111, node 114, node 124, node 112, node 127, node 116, node 104, node 113, node 106, node 12, node 117, node 1, node 128, node 11, node 109, node 107, node 101, node 118, node 100, node 13, node 10, node 108, node 102, node 103, node 115, node 105 and node 110. Node 105 is linked to node 1, node 106, node 107, node 108, node 109, node 110, node 111 and node 112. Node 102 is linked to node 100, node 101, node 103, node 104, node 11, node 114, node 115 and node 116. Node 104 is linked to node 100, node 101, node 102, node 103, node 116, node 117, node 128 and node 13. Node 100 is linked to node 101, node 102, node 103, node 104, node 112, node 113, node 114 and node 124. Node 101 is linked to node 10, node 100, node 102, node 103, node 104, node 113, node 114 and node 115. Node 1 is linked to node 10, node 105, node 11, node 113, node 118, node 12, node 127 and node 13. The present colors are: c1, c10, c11, c12, c13, c2, c3 and c4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2602281674785750904", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "There are fifty-three nodes: node 74, node 17, node 124, node 112, node 133, node 127, node 28, node 14, node 21, node 142, node 104, node 42, node 26, node 113, node 106, node 12, node 117, node 1, node 145, node 76, node 4, node 11, node 50, node 109, node 107, node 132, node 122, node 101, node 130, node 138, node 137, node 35, node 118, node 44, node 140, node 39, node 119, node 100, node 13, node 10, node 31, node 129, node 131, node 108, node 136, node 34, node 102, node 103, node 49, node 143, node 105, node 126 and node 144. Node 100 is linked to node 104, node 105, node 107, node 117, node 119, node 129, node 13 and node 133. Node 104 is linked to node 100, node 108, node 109, node 112, node 127, node 130, node 132 and node 39. Node 103 is linked to node 10, node 127, node 132, node 136, node 138, node 140, node 142 and node 39. Node 102 is linked to node 106, node 145, node 26, node 31, node 35, node 39, node 50 and node 74. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 101 is linked to node 131, node 14, node 140, node 142, node 143, node 34, node 44 and node 76. Node 105 is linked to node 100, node 113, node 137, node 138, node 28, node 31, node 4 and node 49. Node 10 is linked to node 103, node 11, node 118, node 12, node 122, node 124, node 126 and node 13. Node 1 is linked to node 106, node 132, node 144, node 17, node 21, node 35, node 39 and node 42.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,106) link(1,132) link(1,144) link(1,17) link(1,21) link(1,35) link(1,39) link(1,42) link(10,103) link(10,11) link(10,118) link(10,12) link(10,122) link(10,124) link(10,126) link(10,13) link(100,104) link(100,105) link(100,107) link(100,117) link(100,119) link(100,129) link(100,13) link(100,133) link(101,131) link(101,14) link(101,140) link(101,142) link(101,143) link(101,34) link(101,44) link(101,76) link(102,106) link(102,145) link(102,26) link(102,31) link(102,35) link(102,39) link(102,50) link(102,74) link(103,10) link(103,127) link(103,132) link(103,136) link(103,138) link(103,140) link(103,142) link(103,39) link(104,100) link(104,108) link(104,109) link(104,112) link(104,127) link(104,130) link(104,132) link(104,39) link(105,100) link(105,113) link(105,137) link(105,138) link(105,28) link(105,31) link(105,4) link(105,49) node(74). node(17). node(124). node(112). node(133). node(127). node(28). node(14). node(21). node(142). node(104). node(42). node(26). node(113). node(106). node(12). node(117). node(1). node(145). node(76). node(4). node(11). node(50). node(109). node(107). node(132). node(122). node(101). node(130). node(138). node(137). node(35). node(118). node(44). node(140). node(39). node(119). node(100). node(13). node(10). node(31). node(129). node(131). node(108). node(136). node(34). node(102). node(103). node(49). node(143). node(105). node(126). node(144).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```There are fifty-three nodes: node 74, node 17, node 124, node 112, node 133, node 127, node 28, node 14, node 21, node 142, node 104, node 42, node 26, node 113, node 106, node 12, node 117, node 1, node 145, node 76, node 4, node 11, node 50, node 109, node 107, node 132, node 122, node 101, node 130, node 138, node 137, node 35, node 118, node 44, node 140, node 39, node 119, node 100, node 13, node 10, node 31, node 129, node 131, node 108, node 136, node 34, node 102, node 103, node 49, node 143, node 105, node 126 and node 144. Node 100 is linked to node 104, node 105, node 107, node 117, node 119, node 129, node 13 and node 133. Node 104 is linked to node 100, node 108, node 109, node 112, node 127, node 130, node 132 and node 39. Node 103 is linked to node 10, node 127, node 132, node 136, node 138, node 140, node 142 and node 39. Node 102 is linked to node 106, node 145, node 26, node 31, node 35, node 39, node 50 and node 74. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 101 is linked to node 131, node 14, node 140, node 142, node 143, node 34, node 44 and node 76. Node 105 is linked to node 100, node 113, node 137, node 138, node 28, node 31, node 4 and node 49. Node 10 is linked to node 103, node 11, node 118, node 12, node 122, node 124, node 126 and node 13. Node 1 is linked to node 106, node 132, node 144, node 17, node 21, node 35, node 39 and node 42.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "456949792655662152", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 12 is linked to node 23, node 25, node 27, node 30, node 32 and node 46. Node 13 is linked to node 23, node 24, node 26, node 29, node 31 and node 46. Node 16 is linked to node 23, node 26, node 27, node 31, node 32 and node 46. Node 1 is linked to node 13, node 15, node 18, node 2, node 20, node 25, node 27 and node 30. Node 10 is linked to node 11, node 14, node 15, node 22, node 26, node 27, node 34 and node 37. The present colors are: c1, c2, c3, c4, c5 and c6. Node 14 is linked to node 23, node 25, node 28, node 30, node 33 and node 46. Node 11 is linked to node 17, node 18, node 19, node 20, node 21, node 29, node 30 and node 31. There are twenty-nine nodes: node 20, node 29, node 32, node 17, node 37, node 28, node 2, node 14, node 21, node 30, node 23, node 26, node 22, node 12, node 1, node 18, node 46, node 33, node 11, node 24, node 15, node 16, node 10, node 13, node 31, node 25, node 34, node 19 and node 27. Node 15 is linked to node 23, node 24, node 28, node 29, node 33 and node 46.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). link(1,13) link(1,15) link(1,18) link(1,2) link(1,20) link(1,25) link(1,27) link(1,30) link(10,11) link(10,14) link(10,15) link(10,22) link(10,26) link(10,27) link(10,34) link(10,37) link(11,17) link(11,18) link(11,19) link(11,20) link(11,21) link(11,29) link(11,30) link(11,31) link(12,23) link(12,25) link(12,27) link(12,30) link(12,32) link(12,46) link(13,23) link(13,24) link(13,26) link(13,29) link(13,31) link(13,46) link(14,23) link(14,25) link(14,28) link(14,30) link(14,33) link(14,46) link(15,23) link(15,24) link(15,28) link(15,29) link(15,33) link(15,46) link(16,23) link(16,26) link(16,27) link(16,31) link(16,32) link(16,46) node(20). node(29). node(32). node(17). node(37). node(28). node(2). node(14). node(21). node(30). node(23). node(26). node(22). node(12). node(1). node(18). node(46). node(33). node(11). node(24). node(15). node(16). node(10). node(13). node(31). node(25). node(34). node(19). node(27).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 12 is linked to node 23, node 25, node 27, node 30, node 32 and node 46. Node 13 is linked to node 23, node 24, node 26, node 29, node 31 and node 46. Node 16 is linked to node 23, node 26, node 27, node 31, node 32 and node 46. Node 1 is linked to node 13, node 15, node 18, node 2, node 20, node 25, node 27 and node 30. Node 10 is linked to node 11, node 14, node 15, node 22, node 26, node 27, node 34 and node 37. The present colors are: c1, c2, c3, c4, c5 and c6. Node 14 is linked to node 23, node 25, node 28, node 30, node 33 and node 46. Node 11 is linked to node 17, node 18, node 19, node 20, node 21, node 29, node 30 and node 31. There are twenty-nine nodes: node 20, node 29, node 32, node 17, node 37, node 28, node 2, node 14, node 21, node 30, node 23, node 26, node 22, node 12, node 1, node 18, node 46, node 33, node 11, node 24, node 15, node 16, node 10, node 13, node 31, node 25, node 34, node 19 and node 27. Node 15 is linked to node 23, node 24, node 28, node 29, node 33 and node 46.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6893188936307796061", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 1 is linked to node 10, node 103, node 106, node 11, node 113, node 114, node 12 and node 121. Node 13 is linked to node 103, node 106, node 113, node 114, node 121, node 124, node 126 and node 129. Node 10 is linked to node 106, node 11, node 113, node 114, node 12, node 121, node 124 and node 126. Node 12 is linked to node 103, node 106, node 113, node 114, node 121, node 124, node 126 and node 129. Node 106 is linked to node 113, node 114, node 121, node 124, node 126, node 129, node 132 and node 134. Node 11 is linked to node 103, node 106, node 113, node 114, node 12, node 121, node 124 and node 126. Node 132 is linked to node 134, node 135, node 140, node 141, node 142, node 145, node 146 and node 159. There are twenty-seven nodes: node 114, node 124, node 142, node 104, node 113, node 106, node 12, node 1, node 145, node 11, node 132, node 101, node 135, node 121, node 159, node 140, node 134, node 10, node 13, node 100, node 129, node 102, node 103, node 141, node 146, node 105 and node 126. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 124 is linked to node 126, node 129, node 132, node 134, node 135, node 140, node 141 and node 142.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c14). colour(c15). colour(c16). link(1,10) link(1,103) link(1,106) link(1,11) link(1,113) link(1,114) link(1,12) link(1,121) link(10,106) link(10,11) link(10,113) link(10,114) link(10,12) link(10,121) link(10,124) link(10,126) link(106,113) link(106,114) link(106,121) link(106,124) link(106,126) link(106,129) link(106,132) link(106,134) link(11,103) link(11,106) link(11,113) link(11,114) link(11,12) link(11,121) link(11,124) link(11,126) link(12,103) link(12,106) link(12,113) link(12,114) link(12,121) link(12,124) link(12,126) link(12,129) link(124,126) link(124,129) link(124,132) link(124,134) link(124,135) link(124,140) link(124,141) link(124,142) link(13,103) link(13,106) link(13,113) link(13,114) link(13,121) link(13,124) link(13,126) link(13,129) link(132,134) link(132,135) link(132,140) link(132,141) link(132,142) link(132,145) link(132,146) link(132,159) node(114). node(124). node(142). node(104). node(113). node(106). node(12). node(1). node(145). node(11). node(132). node(101). node(135). node(121). node(159). node(140). node(134). node(10). node(13). node(100). node(129). node(102). node(103). node(141). node(146). node(105). node(126).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 1 is linked to node 10, node 103, node 106, node 11, node 113, node 114, node 12 and node 121. Node 13 is linked to node 103, node 106, node 113, node 114, node 121, node 124, node 126 and node 129. Node 10 is linked to node 106, node 11, node 113, node 114, node 12, node 121, node 124 and node 126. Node 12 is linked to node 103, node 106, node 113, node 114, node 121, node 124, node 126 and node 129. Node 106 is linked to node 113, node 114, node 121, node 124, node 126, node 129, node 132 and node 134. Node 11 is linked to node 103, node 106, node 113, node 114, node 12, node 121, node 124 and node 126. Node 132 is linked to node 134, node 135, node 140, node 141, node 142, node 145, node 146 and node 159. There are twenty-seven nodes: node 114, node 124, node 142, node 104, node 113, node 106, node 12, node 1, node 145, node 11, node 132, node 101, node 135, node 121, node 159, node 140, node 134, node 10, node 13, node 100, node 129, node 102, node 103, node 141, node 146, node 105 and node 126. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 124 is linked to node 126, node 129, node 132, node 134, node 135, node 140, node 141 and node 142.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2238655628717699312", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "There are sixty-one nodes: node 242, node 206, node 182, node 414, node 323, node 286, node 168, node 183, node 185, node 220, node 221, node 112, node 127, node 116, node 337, node 142, node 104, node 155, node 437, node 1, node 128, node 193, node 276, node 195, node 423, node 194, node 164, node 109, node 107, node 15, node 158, node 130, node 101, node 149, node 212, node 137, node 430, node 135, node 121, node 175, node 294, node 163, node 267, node 119, node 100, node 10, node 129, node 171, node 150, node 136, node 108, node 241, node 196, node 102, node 103, node 291, node 188, node 115, node 105, node 207 and node 144. Node 101 is linked to node 112, node 115, node 128, node 149, node 168, node 185, node 194 and node 195. Node 10 is linked to node 116, node 121, node 130, node 137, node 15, node 164, node 175 and node 196. Node 103 is linked to node 112, node 212, node 221, node 337, node 414, node 423, node 430 and node 437. Node 100 is linked to node 109, node 116, node 127, node 142, node 144, node 158, node 171 and node 182. Node 105 is linked to node 107, node 135, node 171, node 276, node 286, node 291, node 294 and node 323. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 1 is linked to node 115, node 119, node 129, node 183, node 188, node 220, node 242 and node 267. Node 104 is linked to node 108, node 127, node 149, node 158, node 168, node 188, node 206 and node 241. Node 102 is linked to node 129, node 136, node 150, node 155, node 163, node 168, node 193 and node 207.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c14). colour(c15). colour(c16). link(1,115) link(1,119) link(1,129) link(1,183) link(1,188) link(1,220) link(1,242) link(1,267) link(10,116) link(10,121) link(10,130) link(10,137) link(10,15) link(10,164) link(10,175) link(10,196) link(100,109) link(100,116) link(100,127) link(100,142) link(100,144) link(100,158) link(100,171) link(100,182) link(101,112) link(101,115) link(101,128) link(101,149) link(101,168) link(101,185) link(101,194) link(101,195) link(102,129) link(102,136) link(102,150) link(102,155) link(102,163) link(102,168) link(102,193) link(102,207) link(103,112) link(103,212) link(103,221) link(103,337) link(103,414) link(103,423) link(103,430) link(103,437) link(104,108) link(104,127) link(104,149) link(104,158) link(104,168) link(104,188) link(104,206) link(104,241) link(105,107) link(105,135) link(105,171) link(105,276) link(105,286) link(105,291) link(105,294) link(105,323) node(242). node(206). node(182). node(414). node(323). node(286). node(168). node(183). node(185). node(220). node(221). node(112). node(127). node(116). node(337). node(142). node(104). node(155). node(437). node(1). node(128). node(193). node(276). node(195). node(423). node(194). node(164). node(109). node(107). node(15). node(158). node(130). node(101). node(149). node(212). node(137). node(430). node(135). node(121). node(175). node(294). node(163). node(267). node(119). node(100). node(10). node(129). node(171). node(150). node(136). node(108). node(241). node(196). node(102). node(103). node(291). node(188). node(115). node(105). node(207). node(144).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```There are sixty-one nodes: node 242, node 206, node 182, node 414, node 323, node 286, node 168, node 183, node 185, node 220, node 221, node 112, node 127, node 116, node 337, node 142, node 104, node 155, node 437, node 1, node 128, node 193, node 276, node 195, node 423, node 194, node 164, node 109, node 107, node 15, node 158, node 130, node 101, node 149, node 212, node 137, node 430, node 135, node 121, node 175, node 294, node 163, node 267, node 119, node 100, node 10, node 129, node 171, node 150, node 136, node 108, node 241, node 196, node 102, node 103, node 291, node 188, node 115, node 105, node 207 and node 144. Node 101 is linked to node 112, node 115, node 128, node 149, node 168, node 185, node 194 and node 195. Node 10 is linked to node 116, node 121, node 130, node 137, node 15, node 164, node 175 and node 196. Node 103 is linked to node 112, node 212, node 221, node 337, node 414, node 423, node 430 and node 437. Node 100 is linked to node 109, node 116, node 127, node 142, node 144, node 158, node 171 and node 182. Node 105 is linked to node 107, node 135, node 171, node 276, node 286, node 291, node 294 and node 323. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 1 is linked to node 115, node 119, node 129, node 183, node 188, node 220, node 242 and node 267. Node 104 is linked to node 108, node 127, node 149, node 158, node 168, node 188, node 206 and node 241. Node 102 is linked to node 129, node 136, node 150, node 155, node 163, node 168, node 193 and node 207.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "525253065442442958", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 105 is linked to node 244. Node 101 is linked to node 244 and node 471. Node 103 is linked to node 78. Node 104 is linked to node 192, node 267, node 330, node 46 and node 553. Node 10 is linked to node 114, node 310, node 317, node 321 and node 422. Node 102 is linked to node 137, node 244, node 363, node 426, node 479, node 542 and node 554. The present colors are: c1, c10, c11, c12, c2, c3, c4 and c5. There are thirty-five nodes: node 363, node 553, node 422, node 114, node 317, node 330, node 178, node 192, node 78, node 152, node 104, node 1, node 542, node 471, node 335, node 46, node 164, node 310, node 101, node 135, node 137, node 35, node 479, node 105, node 426, node 267, node 554, node 119, node 100, node 321, node 10, node 102, node 103, node 447 and node 244. Node 100 is linked to node 321. Node 1 is linked to node 119, node 135, node 152, node 164, node 178, node 335, node 35 and node 447.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c2). colour(c3). colour(c4). colour(c5). link(1,119) link(1,135) link(1,152) link(1,164) link(1,178) link(1,335) link(1,35) link(1,447) link(10,114) link(10,310) link(10,317) link(10,321) link(10,422) link(100,321) link(101,244) link(101,471) link(102,137) link(102,244) link(102,363) link(102,426) link(102,479) link(102,542) link(102,554) link(103,78) link(104,192) link(104,267) link(104,330) link(104,46) link(104,553) link(105,244) node(363). node(553). node(422). node(114). node(317). node(330). node(178). node(192). node(78). node(152). node(104). node(1). node(542). node(471). node(335). node(46). node(164). node(310). node(101). node(135). node(137). node(35). node(479). node(105). node(426). node(267). node(554). node(119). node(100). node(321). node(10). node(102). node(103). node(447). node(244).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 105 is linked to node 244. Node 101 is linked to node 244 and node 471. Node 103 is linked to node 78. Node 104 is linked to node 192, node 267, node 330, node 46 and node 553. Node 10 is linked to node 114, node 310, node 317, node 321 and node 422. Node 102 is linked to node 137, node 244, node 363, node 426, node 479, node 542 and node 554. The present colors are: c1, c10, c11, c12, c2, c3, c4 and c5. There are thirty-five nodes: node 363, node 553, node 422, node 114, node 317, node 330, node 178, node 192, node 78, node 152, node 104, node 1, node 542, node 471, node 335, node 46, node 164, node 310, node 101, node 135, node 137, node 35, node 479, node 105, node 426, node 267, node 554, node 119, node 100, node 321, node 10, node 102, node 103, node 447 and node 244. Node 100 is linked to node 321. Node 1 is linked to node 119, node 135, node 152, node 164, node 178, node 335, node 35 and node 447.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5416454880798499759", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 1 is linked to node 14. Node 11 is linked to node 42 and node 72. The present colors are: c1, c2, c3, c4, c5, c6, c7 and c8. There are thirty-five nodes: node 20, node 58, node 38, node 29, node 32, node 17, node 37, node 2, node 14, node 23, node 42, node 26, node 22, node 12, node 1, node 43, node 33, node 11, node 6, node 24, node 15, node 48, node 35, node 72, node 16, node 39, node 10, node 13, node 5, node 65, node 34, node 19, node 55, node 41 and node 57. Node 13 is linked to node 43. Node 12 is linked to node 14. Node 15 is linked to node 19, node 23, node 26, node 29, node 33, node 34, node 37 and node 38. Node 14 is linked to node 1, node 12, node 2, node 24, node 32, node 37, node 41 and node 65. Node 16 is linked to node 35, node 48, node 55, node 57, node 58, node 6 and node 72. Node 10 is linked to node 17, node 20, node 22, node 37, node 39 and node 5.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). colour(c7). colour(c8). link(1,14) link(10,17) link(10,20) link(10,22) link(10,37) link(10,39) link(10,5) link(11,42) link(11,72) link(12,14) link(13,43) link(14,1) link(14,12) link(14,2) link(14,24) link(14,32) link(14,37) link(14,41) link(14,65) link(15,19) link(15,23) link(15,26) link(15,29) link(15,33) link(15,34) link(15,37) link(15,38) link(16,35) link(16,48) link(16,55) link(16,57) link(16,58) link(16,6) link(16,72) node(20). node(58). node(38). node(29). node(32). node(17). node(37). node(2). node(14). node(23). node(42). node(26). node(22). node(12). node(1). node(43). node(33). node(11). node(6). node(24). node(15). node(48). node(35). node(72). node(16). node(39). node(10). node(13). node(5). node(65). node(34). node(19). node(55). node(41). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 1 is linked to node 14. Node 11 is linked to node 42 and node 72. The present colors are: c1, c2, c3, c4, c5, c6, c7 and c8. There are thirty-five nodes: node 20, node 58, node 38, node 29, node 32, node 17, node 37, node 2, node 14, node 23, node 42, node 26, node 22, node 12, node 1, node 43, node 33, node 11, node 6, node 24, node 15, node 48, node 35, node 72, node 16, node 39, node 10, node 13, node 5, node 65, node 34, node 19, node 55, node 41 and node 57. Node 13 is linked to node 43. Node 12 is linked to node 14. Node 15 is linked to node 19, node 23, node 26, node 29, node 33, node 34, node 37 and node 38. Node 14 is linked to node 1, node 12, node 2, node 24, node 32, node 37, node 41 and node 65. Node 16 is linked to node 35, node 48, node 55, node 57, node 58, node 6 and node 72. Node 10 is linked to node 17, node 20, node 22, node 37, node 39 and node 5.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2710972463683756689", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 102 is linked to node 137, node 244, node 363, node 426, node 479, node 542 and node 554. Node 10 is linked to node 114, node 310, node 317, node 321 and node 422. Node 103 is linked to node 78. Node 1 is linked to node 119, node 135, node 152, node 164, node 178, node 335, node 35 and node 447. Node 100 is linked to node 321. There are thirty-five nodes: node 363, node 553, node 422, node 114, node 317, node 330, node 178, node 192, node 78, node 152, node 104, node 1, node 542, node 471, node 335, node 46, node 164, node 310, node 101, node 135, node 137, node 35, node 479, node 105, node 426, node 267, node 554, node 119, node 100, node 321, node 10, node 102, node 103, node 447 and node 244. Node 105 is linked to node 244. Node 104 is linked to node 192, node 267, node 330, node 46 and node 553. Node 101 is linked to node 244 and node 471. The present colors are: c1, c10, c11, c12, c13, c2, c3 and c4.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c2). colour(c3). colour(c4). link(1,119) link(1,135) link(1,152) link(1,164) link(1,178) link(1,335) link(1,35) link(1,447) link(10,114) link(10,310) link(10,317) link(10,321) link(10,422) link(100,321) link(101,244) link(101,471) link(102,137) link(102,244) link(102,363) link(102,426) link(102,479) link(102,542) link(102,554) link(103,78) link(104,192) link(104,267) link(104,330) link(104,46) link(104,553) link(105,244) node(363). node(553). node(422). node(114). node(317). node(330). node(178). node(192). node(78). node(152). node(104). node(1). node(542). node(471). node(335). node(46). node(164). node(310). node(101). node(135). node(137). node(35). node(479). node(105). node(426). node(267). node(554). node(119). node(100). node(321). node(10). node(102). node(103). node(447). node(244).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 102 is linked to node 137, node 244, node 363, node 426, node 479, node 542 and node 554. Node 10 is linked to node 114, node 310, node 317, node 321 and node 422. Node 103 is linked to node 78. Node 1 is linked to node 119, node 135, node 152, node 164, node 178, node 335, node 35 and node 447. Node 100 is linked to node 321. There are thirty-five nodes: node 363, node 553, node 422, node 114, node 317, node 330, node 178, node 192, node 78, node 152, node 104, node 1, node 542, node 471, node 335, node 46, node 164, node 310, node 101, node 135, node 137, node 35, node 479, node 105, node 426, node 267, node 554, node 119, node 100, node 321, node 10, node 102, node 103, node 447 and node 244. Node 105 is linked to node 244. Node 104 is linked to node 192, node 267, node 330, node 46 and node 553. Node 101 is linked to node 244 and node 471. The present colors are: c1, c10, c11, c12, c13, c2, c3 and c4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1581525903705217295", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 102 is linked to node 1, node 100, node 101, node 103, node 105, node 107, node 108 and node 109. Node 101 is linked to node 100, node 102, node 105, node 107, node 108, node 109, node 110 and node 113. Node 105 is linked to node 1, node 100, node 101, node 102, node 103, node 108, node 109 and node 110. There are twenty-six nodes: node 111, node 29, node 17, node 114, node 124, node 116, node 21, node 104, node 113, node 26, node 117, node 1, node 18, node 11, node 109, node 107, node 15, node 101, node 10, node 100, node 108, node 102, node 103, node 115, node 105 and node 110. Node 1 is linked to node 100, node 102, node 103, node 105, node 108, node 109, node 110 and node 114. Node 103 is linked to node 1, node 102, node 105, node 108, node 109, node 110, node 114 and node 117. Node 10 is linked to node 100, node 107, node 110, node 111, node 113, node 114, node 115 and node 116. Node 100 is linked to node 1, node 10, node 101, node 102, node 105, node 107, node 108 and node 109. Node 104 is linked to node 11, node 124, node 15, node 17, node 18, node 21, node 26 and node 29. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c14). colour(c15). colour(c16). link(1,100) link(1,102) link(1,103) link(1,105) link(1,108) link(1,109) link(1,110) link(1,114) link(10,100) link(10,107) link(10,110) link(10,111) link(10,113) link(10,114) link(10,115) link(10,116) link(100,1) link(100,10) link(100,101) link(100,102) link(100,105) link(100,107) link(100,108) link(100,109) link(101,100) link(101,102) link(101,105) link(101,107) link(101,108) link(101,109) link(101,110) link(101,113) link(102,1) link(102,100) link(102,101) link(102,103) link(102,105) link(102,107) link(102,108) link(102,109) link(103,1) link(103,102) link(103,105) link(103,108) link(103,109) link(103,110) link(103,114) link(103,117) link(104,11) link(104,124) link(104,15) link(104,17) link(104,18) link(104,21) link(104,26) link(104,29) link(105,1) link(105,100) link(105,101) link(105,102) link(105,103) link(105,108) link(105,109) link(105,110) node(111). node(29). node(17). node(114). node(124). node(116). node(21). node(104). node(113). node(26). node(117). node(1). node(18). node(11). node(109). node(107). node(15). node(101). node(10). node(100). node(108). node(102). node(103). node(115). node(105). node(110).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 102 is linked to node 1, node 100, node 101, node 103, node 105, node 107, node 108 and node 109. Node 101 is linked to node 100, node 102, node 105, node 107, node 108, node 109, node 110 and node 113. Node 105 is linked to node 1, node 100, node 101, node 102, node 103, node 108, node 109 and node 110. There are twenty-six nodes: node 111, node 29, node 17, node 114, node 124, node 116, node 21, node 104, node 113, node 26, node 117, node 1, node 18, node 11, node 109, node 107, node 15, node 101, node 10, node 100, node 108, node 102, node 103, node 115, node 105 and node 110. Node 1 is linked to node 100, node 102, node 103, node 105, node 108, node 109, node 110 and node 114. Node 103 is linked to node 1, node 102, node 105, node 108, node 109, node 110, node 114 and node 117. Node 10 is linked to node 100, node 107, node 110, node 111, node 113, node 114, node 115 and node 116. Node 100 is linked to node 1, node 10, node 101, node 102, node 105, node 107, node 108 and node 109. Node 104 is linked to node 11, node 124, node 15, node 17, node 18, node 21, node 26 and node 29. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1390600992425913524", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "There are seventeen nodes: node 104, node 216, node 101, node 244, node 246, node 10, node 106, node 249, node 1, node 102, node 103, node 245, node 248, node 163, node 11, node 105 and node 100. Node 105 is linked to node 106, node 163, node 216, node 244, node 245, node 246, node 248 and node 249. Node 103 is linked to node 104, node 105, node 106, node 163, node 216, node 244, node 245 and node 246. Node 100 is linked to node 101, node 102, node 103, node 104, node 105, node 106, node 163 and node 216. Node 102 is linked to node 103, node 104, node 105, node 106, node 163, node 216, node 244 and node 245. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 10 is linked to node 100, node 101, node 102, node 103, node 104, node 105, node 106 and node 11. Node 1 is linked to node 10, node 100, node 101, node 102, node 103, node 104, node 105 and node 106. Node 104 is linked to node 105, node 106, node 163, node 216, node 244, node 245, node 246 and node 248. Node 101 is linked to node 102, node 103, node 104, node 105, node 106, node 163, node 216 and node 244.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c14). colour(c15). colour(c16). link(1,10) link(1,100) link(1,101) link(1,102) link(1,103) link(1,104) link(1,105) link(1,106) link(10,100) link(10,101) link(10,102) link(10,103) link(10,104) link(10,105) link(10,106) link(10,11) link(100,101) link(100,102) link(100,103) link(100,104) link(100,105) link(100,106) link(100,163) link(100,216) link(101,102) link(101,103) link(101,104) link(101,105) link(101,106) link(101,163) link(101,216) link(101,244) link(102,103) link(102,104) link(102,105) link(102,106) link(102,163) link(102,216) link(102,244) link(102,245) link(103,104) link(103,105) link(103,106) link(103,163) link(103,216) link(103,244) link(103,245) link(103,246) link(104,105) link(104,106) link(104,163) link(104,216) link(104,244) link(104,245) link(104,246) link(104,248) link(105,106) link(105,163) link(105,216) link(105,244) link(105,245) link(105,246) link(105,248) link(105,249) node(104). node(216). node(101). node(244). node(246). node(10). node(106). node(249). node(1). node(102). node(103). node(245). node(248). node(163). node(11). node(105). node(100).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```There are seventeen nodes: node 104, node 216, node 101, node 244, node 246, node 10, node 106, node 249, node 1, node 102, node 103, node 245, node 248, node 163, node 11, node 105 and node 100. Node 105 is linked to node 106, node 163, node 216, node 244, node 245, node 246, node 248 and node 249. Node 103 is linked to node 104, node 105, node 106, node 163, node 216, node 244, node 245 and node 246. Node 100 is linked to node 101, node 102, node 103, node 104, node 105, node 106, node 163 and node 216. Node 102 is linked to node 103, node 104, node 105, node 106, node 163, node 216, node 244 and node 245. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 10 is linked to node 100, node 101, node 102, node 103, node 104, node 105, node 106 and node 11. Node 1 is linked to node 10, node 100, node 101, node 102, node 103, node 104, node 105 and node 106. Node 104 is linked to node 105, node 106, node 163, node 216, node 244, node 245, node 246 and node 248. Node 101 is linked to node 102, node 103, node 104, node 105, node 106, node 163, node 216 and node 244.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4602079450001463329", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 102 is linked to node 100, node 115, node 15, node 24, node 36, node 42, node 44 and node 56. Node 10 is linked to node 108, node 116, node 119, node 20, node 34, node 37, node 40 and node 57. There are fifty-four nodes: node 20, node 58, node 66, node 111, node 32, node 17, node 114, node 37, node 127, node 116, node 2, node 14, node 21, node 104, node 23, node 42, node 113, node 106, node 117, node 1, node 128, node 68, node 24, node 109, node 15, node 101, node 69, node 123, node 16, node 44, node 119, node 51, node 120, node 100, node 10, node 125, node 45, node 5, node 129, node 25, node 108, node 34, node 102, node 103, node 36, node 40, node 47, node 3, node 115, node 105, node 126, node 110, node 56 and node 57. Node 101 is linked to node 120, node 123, node 15, node 16, node 23, node 25, node 45 and node 58. Node 103 is linked to node 105, node 114, node 116, node 117, node 126, node 127, node 16 and node 20. Node 1 is linked to node 106, node 116, node 20, node 3, node 42, node 66, node 68 and node 69. Node 100 is linked to node 102, node 108, node 110, node 114, node 115, node 125, node 128 and node 129. Node 104 is linked to node 109, node 14, node 17, node 20, node 21, node 47, node 5 and node 51. Node 105 is linked to node 103, node 111, node 113, node 125, node 129, node 17, node 2 and node 32.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,106) link(1,116) link(1,20) link(1,3) link(1,42) link(1,66) link(1,68) link(1,69) link(10,108) link(10,116) link(10,119) link(10,20) link(10,34) link(10,37) link(10,40) link(10,57) link(100,102) link(100,108) link(100,110) link(100,114) link(100,115) link(100,125) link(100,128) link(100,129) link(101,120) link(101,123) link(101,15) link(101,16) link(101,23) link(101,25) link(101,45) link(101,58) link(102,100) link(102,115) link(102,15) link(102,24) link(102,36) link(102,42) link(102,44) link(102,56) link(103,105) link(103,114) link(103,116) link(103,117) link(103,126) link(103,127) link(103,16) link(103,20) link(104,109) link(104,14) link(104,17) link(104,20) link(104,21) link(104,47) link(104,5) link(104,51) link(105,103) link(105,111) link(105,113) link(105,125) link(105,129) link(105,17) link(105,2) link(105,32) node(20). node(58). node(66). node(111). node(32). node(17). node(114). node(37). node(127). node(116). node(2). node(14). node(21). node(104). node(23). node(42). node(113). node(106). node(117). node(1). node(128). node(68). node(24). node(109). node(15). node(101). node(69). node(123). node(16). node(44). node(119). node(51). node(120). node(100). node(10). node(125). node(45). node(5). node(129). node(25). node(108). node(34). node(102). node(103). node(36). node(40). node(47). node(3). node(115). node(105). node(126). node(110). node(56). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 102 is linked to node 100, node 115, node 15, node 24, node 36, node 42, node 44 and node 56. Node 10 is linked to node 108, node 116, node 119, node 20, node 34, node 37, node 40 and node 57. There are fifty-four nodes: node 20, node 58, node 66, node 111, node 32, node 17, node 114, node 37, node 127, node 116, node 2, node 14, node 21, node 104, node 23, node 42, node 113, node 106, node 117, node 1, node 128, node 68, node 24, node 109, node 15, node 101, node 69, node 123, node 16, node 44, node 119, node 51, node 120, node 100, node 10, node 125, node 45, node 5, node 129, node 25, node 108, node 34, node 102, node 103, node 36, node 40, node 47, node 3, node 115, node 105, node 126, node 110, node 56 and node 57. Node 101 is linked to node 120, node 123, node 15, node 16, node 23, node 25, node 45 and node 58. Node 103 is linked to node 105, node 114, node 116, node 117, node 126, node 127, node 16 and node 20. Node 1 is linked to node 106, node 116, node 20, node 3, node 42, node 66, node 68 and node 69. Node 100 is linked to node 102, node 108, node 110, node 114, node 115, node 125, node 128 and node 129. Node 104 is linked to node 109, node 14, node 17, node 20, node 21, node 47, node 5 and node 51. Node 105 is linked to node 103, node 111, node 113, node 125, node 129, node 17, node 2 and node 32.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6596846276813879509", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 105 is linked to node 100, node 101, node 102, node 103, node 104, node 106, node 107 and node 108. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 1 is linked to node 10, node 103, node 11, node 113, node 12, node 120, node 129 and node 13. Node 100 is linked to node 10, node 101, node 102, node 103, node 104, node 105, node 106 and node 107. Node 10 is linked to node 1, node 100, node 106, node 11, node 112, node 115, node 12 and node 122. Node 102 is linked to node 100, node 101, node 103, node 104, node 105, node 106, node 107 and node 108. Node 104 is linked to node 100, node 101, node 102, node 103, node 105, node 106, node 107 and node 108. Node 101 is linked to node 100, node 102, node 103, node 104, node 105, node 106, node 107 and node 108. Node 103 is linked to node 1, node 100, node 101, node 102, node 104, node 105, node 106 and node 107. There are twenty nodes: node 112, node 104, node 113, node 106, node 12, node 1, node 11, node 107, node 122, node 101, node 120, node 100, node 13, node 10, node 129, node 108, node 102, node 103, node 115 and node 105.", "output": "colour(c1). colour(c10). colour(c11). colour(c12). colour(c13). colour(c14). colour(c15). colour(c16). link(1,10) link(1,103) link(1,11) link(1,113) link(1,12) link(1,120) link(1,129) link(1,13) link(10,1) link(10,100) link(10,106) link(10,11) link(10,112) link(10,115) link(10,12) link(10,122) link(100,10) link(100,101) link(100,102) link(100,103) link(100,104) link(100,105) link(100,106) link(100,107) link(101,100) link(101,102) link(101,103) link(101,104) link(101,105) link(101,106) link(101,107) link(101,108) link(102,100) link(102,101) link(102,103) link(102,104) link(102,105) link(102,106) link(102,107) link(102,108) link(103,1) link(103,100) link(103,101) link(103,102) link(103,104) link(103,105) link(103,106) link(103,107) link(104,100) link(104,101) link(104,102) link(104,103) link(104,105) link(104,106) link(104,107) link(104,108) link(105,100) link(105,101) link(105,102) link(105,103) link(105,104) link(105,106) link(105,107) link(105,108) node(112). node(104). node(113). node(106). node(12). node(1). node(11). node(107). node(122). node(101). node(120). node(100). node(13). node(10). node(129). node(108). node(102). node(103). node(115). node(105).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 105 is linked to node 100, node 101, node 102, node 103, node 104, node 106, node 107 and node 108. The present colors are: c1, c10, c11, c12, c13, c14, c15 and c16. Node 1 is linked to node 10, node 103, node 11, node 113, node 12, node 120, node 129 and node 13. Node 100 is linked to node 10, node 101, node 102, node 103, node 104, node 105, node 106 and node 107. Node 10 is linked to node 1, node 100, node 106, node 11, node 112, node 115, node 12 and node 122. Node 102 is linked to node 100, node 101, node 103, node 104, node 105, node 106, node 107 and node 108. Node 104 is linked to node 100, node 101, node 102, node 103, node 105, node 106, node 107 and node 108. Node 101 is linked to node 100, node 102, node 103, node 104, node 105, node 106, node 107 and node 108. Node 103 is linked to node 1, node 100, node 101, node 102, node 104, node 105, node 106 and node 107. There are twenty nodes: node 112, node 104, node 113, node 106, node 12, node 1, node 11, node 107, node 122, node 101, node 120, node 100, node 13, node 10, node 129, node 108, node 102, node 103, node 115 and node 105.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1953742209972896137", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 101 is linked to node 11, node 118, node 32, node 59, node 6, node 8, node 85 and node 86. Node 104 is linked to node 119, node 127, node 30, node 32, node 46, node 56, node 61 and node 66. Node 105 is linked to node 118, node 121, node 126, node 22, node 27, node 36, node 38 and node 43. Node 10 is linked to node 31, node 4, node 44, node 51, node 57 and node 6. Node 100 is linked to node 107, node 11, node 121, node 122, node 129, node 20, node 22 and node 31. There are fifty-four nodes: node 20, node 38, node 8, node 29, node 32, node 66, node 95, node 127, node 28, node 30, node 104, node 22, node 117, node 52, node 1, node 18, node 128, node 43, node 46, node 4, node 94, node 11, node 6, node 107, node 122, node 130, node 101, node 86, node 121, node 118, node 44, node 85, node 39, node 119, node 51, node 59, node 100, node 10, node 61, node 5, node 31, node 129, node 53, node 102, node 103, node 19, node 27, node 36, node 49, node 40, node 105, node 126, node 56 and node 57. Node 103 is linked to node 1, node 117, node 18, node 20, node 28, node 46, node 49 and node 52. Node 1 is linked to node 103, node 128, node 130, node 19, node 28, node 29, node 39 and node 5. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 102 is linked to node 119, node 39, node 40, node 53, node 56, node 86, node 94 and node 95.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,103) link(1,128) link(1,130) link(1,19) link(1,28) link(1,29) link(1,39) link(1,5) link(10,31) link(10,4) link(10,44) link(10,51) link(10,57) link(10,6) link(100,107) link(100,11) link(100,121) link(100,122) link(100,129) link(100,20) link(100,22) link(100,31) link(101,11) link(101,118) link(101,32) link(101,59) link(101,6) link(101,8) link(101,85) link(101,86) link(102,119) link(102,39) link(102,40) link(102,53) link(102,56) link(102,86) link(102,94) link(102,95) link(103,1) link(103,117) link(103,18) link(103,20) link(103,28) link(103,46) link(103,49) link(103,52) link(104,119) link(104,127) link(104,30) link(104,32) link(104,46) link(104,56) link(104,61) link(104,66) link(105,118) link(105,121) link(105,126) link(105,22) link(105,27) link(105,36) link(105,38) link(105,43) node(20). node(38). node(8). node(29). node(32). node(66). node(95). node(127). node(28). node(30). node(104). node(22). node(117). node(52). node(1). node(18). node(128). node(43). node(46). node(4). node(94). node(11). node(6). node(107). node(122). node(130). node(101). node(86). node(121). node(118). node(44). node(85). node(39). node(119). node(51). node(59). node(100). node(10). node(61). node(5). node(31). node(129). node(53). node(102). node(103). node(19). node(27). node(36). node(49). node(40). node(105). node(126). node(56). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 101 is linked to node 11, node 118, node 32, node 59, node 6, node 8, node 85 and node 86. Node 104 is linked to node 119, node 127, node 30, node 32, node 46, node 56, node 61 and node 66. Node 105 is linked to node 118, node 121, node 126, node 22, node 27, node 36, node 38 and node 43. Node 10 is linked to node 31, node 4, node 44, node 51, node 57 and node 6. Node 100 is linked to node 107, node 11, node 121, node 122, node 129, node 20, node 22 and node 31. There are fifty-four nodes: node 20, node 38, node 8, node 29, node 32, node 66, node 95, node 127, node 28, node 30, node 104, node 22, node 117, node 52, node 1, node 18, node 128, node 43, node 46, node 4, node 94, node 11, node 6, node 107, node 122, node 130, node 101, node 86, node 121, node 118, node 44, node 85, node 39, node 119, node 51, node 59, node 100, node 10, node 61, node 5, node 31, node 129, node 53, node 102, node 103, node 19, node 27, node 36, node 49, node 40, node 105, node 126, node 56 and node 57. Node 103 is linked to node 1, node 117, node 18, node 20, node 28, node 46, node 49 and node 52. Node 1 is linked to node 103, node 128, node 130, node 19, node 28, node 29, node 39 and node 5. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 102 is linked to node 119, node 39, node 40, node 53, node 56, node 86, node 94 and node 95.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "113031265417743749", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 102 is linked to node 116, node 136, node 38, node 39, node 41, node 52, node 56 and node 61. Node 103 is linked to node 10, node 104, node 111, node 126, node 132, node 21, node 37 and node 4. Node 10 is linked to node 103, node 11, node 110, node 126, node 127, node 133, node 4 and node 44. There are fifty-three nodes: node 58, node 38, node 111, node 32, node 114, node 37, node 112, node 127, node 133, node 28, node 116, node 21, node 104, node 23, node 42, node 52, node 12, node 1, node 18, node 128, node 4, node 11, node 24, node 107, node 15, node 122, node 101, node 132, node 138, node 137, node 121, node 16, node 44, node 140, node 39, node 120, node 100, node 61, node 10, node 31, node 139, node 108, node 136, node 102, node 103, node 36, node 19, node 55, node 41, node 105, node 126, node 110 and node 56. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 105 is linked to node 110, node 112, node 138, node 23, node 41, node 42, node 55 and node 58. Node 100 is linked to node 104, node 120, node 122, node 128, node 21, node 37, node 41 and node 42. Node 1 is linked to node 101, node 107, node 121, node 16, node 32, node 36, node 55 and node 61. Node 101 is linked to node 1, node 140, node 15, node 18, node 19, node 24, node 28 and node 31. Node 104 is linked to node 100, node 103, node 108, node 110, node 114, node 12, node 137 and node 139.", "output": "colour(blue0). colour(cyan0). colour(green0). colour(red0). colour(yellow0). link(1,101) link(1,107) link(1,121) link(1,16) link(1,32) link(1,36) link(1,55) link(1,61) link(10,103) link(10,11) link(10,110) link(10,126) link(10,127) link(10,133) link(10,4) link(10,44) link(100,104) link(100,120) link(100,122) link(100,128) link(100,21) link(100,37) link(100,41) link(100,42) link(101,1) link(101,140) link(101,15) link(101,18) link(101,19) link(101,24) link(101,28) link(101,31) link(102,116) link(102,136) link(102,38) link(102,39) link(102,41) link(102,52) link(102,56) link(102,61) link(103,10) link(103,104) link(103,111) link(103,126) link(103,132) link(103,21) link(103,37) link(103,4) link(104,100) link(104,103) link(104,108) link(104,110) link(104,114) link(104,12) link(104,137) link(104,139) link(105,110) link(105,112) link(105,138) link(105,23) link(105,41) link(105,42) link(105,55) link(105,58) node(58). node(38). node(111). node(32). node(114). node(37). node(112). node(127). node(133). node(28). node(116). node(21). node(104). node(23). node(42). node(52). node(12). node(1). node(18). node(128). node(4). node(11). node(24). node(107). node(15). node(122). node(101). node(132). node(138). node(137). node(121). node(16). node(44). node(140). node(39). node(120). node(100). node(61). node(10). node(31). node(139). node(108). node(136). node(102). node(103). node(36). node(19). node(55). node(41). node(105). node(126). node(110). node(56).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 102 is linked to node 116, node 136, node 38, node 39, node 41, node 52, node 56 and node 61. Node 103 is linked to node 10, node 104, node 111, node 126, node 132, node 21, node 37 and node 4. Node 10 is linked to node 103, node 11, node 110, node 126, node 127, node 133, node 4 and node 44. There are fifty-three nodes: node 58, node 38, node 111, node 32, node 114, node 37, node 112, node 127, node 133, node 28, node 116, node 21, node 104, node 23, node 42, node 52, node 12, node 1, node 18, node 128, node 4, node 11, node 24, node 107, node 15, node 122, node 101, node 132, node 138, node 137, node 121, node 16, node 44, node 140, node 39, node 120, node 100, node 61, node 10, node 31, node 139, node 108, node 136, node 102, node 103, node 36, node 19, node 55, node 41, node 105, node 126, node 110 and node 56. The present colors are: blue0, cyan0, green0, red0 and yellow0. Node 105 is linked to node 110, node 112, node 138, node 23, node 41, node 42, node 55 and node 58. Node 100 is linked to node 104, node 120, node 122, node 128, node 21, node 37, node 41 and node 42. Node 1 is linked to node 101, node 107, node 121, node 16, node 32, node 36, node 55 and node 61. Node 101 is linked to node 1, node 140, node 15, node 18, node 19, node 24, node 28 and node 31. Node 104 is linked to node 100, node 103, node 108, node 110, node 114, node 12, node 137 and node 139.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5276308788242589141", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 11 is linked to node 1, node 13, node 25, node 29, node 40, node 49, node 5 and node 50. Node 15 is linked to node 22 and node 55. Node 16 is linked to node 55 and node 65. Node 1 is linked to node 10, node 11, node 13, node 22, node 25, node 29, node 4 and node 40. Node 10 is linked to node 1, node 49, node 55, node 72 and node 9. There are thirty-two nodes: node 67, node 38, node 8, node 29, node 62, node 14, node 9, node 22, node 12, node 52, node 1, node 43, node 18, node 4, node 11, node 50, node 15, node 72, node 44, node 16, node 10, node 13, node 5, node 31, node 25, node 65, node 55, node 49, node 41, node 40, node 47 and node 57. The present colors are: c1, c10, c11, c2, c3, c4, c5 and c6. Node 14 is linked to node 18, node 31, node 38, node 44, node 52, node 8 and node 9. Node 12 is linked to node 4, node 41, node 43, node 47, node 55, node 57, node 62 and node 67. Node 13 is linked to node 1, node 11, node 25, node 29, node 40, node 49, node 5 and node 50.", "output": "colour(c1). colour(c10). colour(c11). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). link(1,10) link(1,11) link(1,13) link(1,22) link(1,25) link(1,29) link(1,4) link(1,40) link(10,1) link(10,49) link(10,55) link(10,72) link(10,9) link(11,1) link(11,13) link(11,25) link(11,29) link(11,40) link(11,49) link(11,5) link(11,50) link(12,4) link(12,41) link(12,43) link(12,47) link(12,55) link(12,57) link(12,62) link(12,67) link(13,1) link(13,11) link(13,25) link(13,29) link(13,40) link(13,49) link(13,5) link(13,50) link(14,18) link(14,31) link(14,38) link(14,44) link(14,52) link(14,8) link(14,9) link(15,22) link(15,55) link(16,55) link(16,65) node(67). node(38). node(8). node(29). node(62). node(14). node(9). node(22). node(12). node(52). node(1). node(43). node(18). node(4). node(11). node(50). node(15). node(72). node(44). node(16). node(10). node(13). node(5). node(31). node(25). node(65). node(55). node(49). node(41). node(40). node(47). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 11 is linked to node 1, node 13, node 25, node 29, node 40, node 49, node 5 and node 50. Node 15 is linked to node 22 and node 55. Node 16 is linked to node 55 and node 65. Node 1 is linked to node 10, node 11, node 13, node 22, node 25, node 29, node 4 and node 40. Node 10 is linked to node 1, node 49, node 55, node 72 and node 9. There are thirty-two nodes: node 67, node 38, node 8, node 29, node 62, node 14, node 9, node 22, node 12, node 52, node 1, node 43, node 18, node 4, node 11, node 50, node 15, node 72, node 44, node 16, node 10, node 13, node 5, node 31, node 25, node 65, node 55, node 49, node 41, node 40, node 47 and node 57. The present colors are: c1, c10, c11, c2, c3, c4, c5 and c6. Node 14 is linked to node 18, node 31, node 38, node 44, node 52, node 8 and node 9. Node 12 is linked to node 4, node 41, node 43, node 47, node 55, node 57, node 62 and node 67. Node 13 is linked to node 1, node 11, node 25, node 29, node 40, node 49, node 5 and node 50.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6444774342679471907", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "There are forty-eight nodes: node 168, node 111, node 183, node 114, node 178, node 186, node 156, node 127, node 116, node 154, node 104, node 155, node 106, node 172, node 1, node 18, node 173, node 164, node 109, node 107, node 158, node 122, node 101, node 149, node 138, node 176, node 123, node 159, node 163, node 147, node 165, node 119, node 120, node 100, node 13, node 10, node 190, node 108, node 150, node 161, node 177, node 102, node 103, node 169, node 179, node 167, node 105 and node 110. Node 100 is linked to node 103, node 114, node 116, node 119, node 138, node 158, node 167 and node 168. Node 101 is linked to node 104, node 114, node 119, node 147, node 168, node 173, node 183 and node 190. Node 103 is linked to node 106, node 111, node 119, node 120, node 122, node 149, node 155 and node 161. Node 1 is linked to node 103, node 105, node 109, node 13, node 154, node 164, node 18 and node 183. Node 10 is linked to node 103, node 106, node 108, node 114, node 119, node 122, node 123 and node 127. Node 105 is linked to node 107, node 108, node 123, node 159, node 163, node 164, node 168 and node 177. The present colors are: c1, c2, c3 and c4. Node 104 is linked to node 106, node 107, node 147, node 150, node 172, node 176, node 177 and node 186. Node 102 is linked to node 105, node 110, node 156, node 161, node 165, node 169, node 178 and node 179.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). link(1,103) link(1,105) link(1,109) link(1,13) link(1,154) link(1,164) link(1,18) link(1,183) link(10,103) link(10,106) link(10,108) link(10,114) link(10,119) link(10,122) link(10,123) link(10,127) link(100,103) link(100,114) link(100,116) link(100,119) link(100,138) link(100,158) link(100,167) link(100,168) link(101,104) link(101,114) link(101,119) link(101,147) link(101,168) link(101,173) link(101,183) link(101,190) link(102,105) link(102,110) link(102,156) link(102,161) link(102,165) link(102,169) link(102,178) link(102,179) link(103,106) link(103,111) link(103,119) link(103,120) link(103,122) link(103,149) link(103,155) link(103,161) link(104,106) link(104,107) link(104,147) link(104,150) link(104,172) link(104,176) link(104,177) link(104,186) link(105,107) link(105,108) link(105,123) link(105,159) link(105,163) link(105,164) link(105,168) link(105,177) node(168). node(111). node(183). node(114). node(178). node(186). node(156). node(127). node(116). node(154). node(104). node(155). node(106). node(172). node(1). node(18). node(173). node(164). node(109). node(107). node(158). node(122). node(101). node(149). node(138). node(176). node(123). node(159). node(163). node(147). node(165). node(119). node(120). node(100). node(13). node(10). node(190). node(108). node(150). node(161). node(177). node(102). node(103). node(169). node(179). node(167). node(105). node(110).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```There are forty-eight nodes: node 168, node 111, node 183, node 114, node 178, node 186, node 156, node 127, node 116, node 154, node 104, node 155, node 106, node 172, node 1, node 18, node 173, node 164, node 109, node 107, node 158, node 122, node 101, node 149, node 138, node 176, node 123, node 159, node 163, node 147, node 165, node 119, node 120, node 100, node 13, node 10, node 190, node 108, node 150, node 161, node 177, node 102, node 103, node 169, node 179, node 167, node 105 and node 110. Node 100 is linked to node 103, node 114, node 116, node 119, node 138, node 158, node 167 and node 168. Node 101 is linked to node 104, node 114, node 119, node 147, node 168, node 173, node 183 and node 190. Node 103 is linked to node 106, node 111, node 119, node 120, node 122, node 149, node 155 and node 161. Node 1 is linked to node 103, node 105, node 109, node 13, node 154, node 164, node 18 and node 183. Node 10 is linked to node 103, node 106, node 108, node 114, node 119, node 122, node 123 and node 127. Node 105 is linked to node 107, node 108, node 123, node 159, node 163, node 164, node 168 and node 177. The present colors are: c1, c2, c3 and c4. Node 104 is linked to node 106, node 107, node 147, node 150, node 172, node 176, node 177 and node 186. Node 102 is linked to node 105, node 110, node 156, node 161, node 165, node 169, node 178 and node 179.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7584780737184804585", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 1 is linked to node 13, node 15, node 18, node 2, node 20, node 25, node 27 and node 30. Node 14 is linked to node 23, node 25, node 28, node 30, node 33 and node 46. Node 13 is linked to node 23, node 24, node 26, node 29, node 31 and node 46. Node 12 is linked to node 23, node 25, node 27, node 30, node 32 and node 46. The present colors are: c1, c2, c3, c4 and c5. There are twenty-nine nodes: node 20, node 29, node 32, node 17, node 37, node 28, node 2, node 14, node 21, node 30, node 23, node 26, node 22, node 12, node 1, node 18, node 46, node 33, node 11, node 24, node 15, node 16, node 10, node 13, node 31, node 25, node 34, node 19 and node 27. Node 15 is linked to node 23, node 24, node 28, node 29, node 33 and node 46. Node 10 is linked to node 11, node 14, node 15, node 22, node 26, node 27, node 34 and node 37. Node 16 is linked to node 23, node 26, node 27, node 31, node 32 and node 46. Node 11 is linked to node 17, node 18, node 19, node 20, node 21, node 29, node 30 and node 31.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). colour(c5). link(1,13) link(1,15) link(1,18) link(1,2) link(1,20) link(1,25) link(1,27) link(1,30) link(10,11) link(10,14) link(10,15) link(10,22) link(10,26) link(10,27) link(10,34) link(10,37) link(11,17) link(11,18) link(11,19) link(11,20) link(11,21) link(11,29) link(11,30) link(11,31) link(12,23) link(12,25) link(12,27) link(12,30) link(12,32) link(12,46) link(13,23) link(13,24) link(13,26) link(13,29) link(13,31) link(13,46) link(14,23) link(14,25) link(14,28) link(14,30) link(14,33) link(14,46) link(15,23) link(15,24) link(15,28) link(15,29) link(15,33) link(15,46) link(16,23) link(16,26) link(16,27) link(16,31) link(16,32) link(16,46) node(20). node(29). node(32). node(17). node(37). node(28). node(2). node(14). node(21). node(30). node(23). node(26). node(22). node(12). node(1). node(18). node(46). node(33). node(11). node(24). node(15). node(16). node(10). node(13). node(31). node(25). node(34). node(19). node(27).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 1 is linked to node 13, node 15, node 18, node 2, node 20, node 25, node 27 and node 30. Node 14 is linked to node 23, node 25, node 28, node 30, node 33 and node 46. Node 13 is linked to node 23, node 24, node 26, node 29, node 31 and node 46. Node 12 is linked to node 23, node 25, node 27, node 30, node 32 and node 46. The present colors are: c1, c2, c3, c4 and c5. There are twenty-nine nodes: node 20, node 29, node 32, node 17, node 37, node 28, node 2, node 14, node 21, node 30, node 23, node 26, node 22, node 12, node 1, node 18, node 46, node 33, node 11, node 24, node 15, node 16, node 10, node 13, node 31, node 25, node 34, node 19 and node 27. Node 15 is linked to node 23, node 24, node 28, node 29, node 33 and node 46. Node 10 is linked to node 11, node 14, node 15, node 22, node 26, node 27, node 34 and node 37. Node 16 is linked to node 23, node 26, node 27, node 31, node 32 and node 46. Node 11 is linked to node 17, node 18, node 19, node 20, node 21, node 29, node 30 and node 31.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5836457269685601824", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 3 is linked to node 10, node 5 and node 7. Node 7 is linked to node 11. Node 4 is linked to node 10, node 5 and node 6. Node 5 is linked to node 8 and node 9. There are eleven nodes: node 9, node 5, node 8, node 1, node 6, node 7, node 4, node 3, node 11, node 2 and node 10. The present colors are: c1, c2, c3 and c4. Node 1 is linked to node 2, node 4, node 7 and node 9. Node 10 is linked to node 11. Node 6 is linked to node 11. Node 2 is linked to node 3, node 6 and node 8.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). link(1,2) link(1,4) link(1,7) link(1,9) link(10,11) link(2,3) link(2,6) link(2,8) link(3,10) link(3,5) link(3,7) link(4,10) link(4,5) link(4,6) link(5,8) link(5,9) link(6,11) link(7,11) node(9). node(5). node(8). node(1). node(6). node(7). node(4). node(3). node(11). node(2). node(10).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 3 is linked to node 10, node 5 and node 7. Node 7 is linked to node 11. Node 4 is linked to node 10, node 5 and node 6. Node 5 is linked to node 8 and node 9. There are eleven nodes: node 9, node 5, node 8, node 1, node 6, node 7, node 4, node 3, node 11, node 2 and node 10. The present colors are: c1, c2, c3 and c4. Node 1 is linked to node 2, node 4, node 7 and node 9. Node 10 is linked to node 11. Node 6 is linked to node 11. Node 2 is linked to node 3, node 6 and node 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8599637117672651746", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 102 is linked to node 100, node 101, node 103, node 104, node 105, node 106, node 107 and node 108. Node 101 is linked to node 100, node 102, node 103, node 104, node 105, node 106, node 107 and node 108. Node 105 is linked to node 100, node 101, node 102, node 103, node 104, node 106, node 107 and node 108. There are twenty-one nodes: node 20, node 111, node 2, node 21, node 104, node 106, node 12, node 1, node 11, node 109, node 107, node 101, node 121, node 120, node 10, node 13, node 100, node 108, node 102, node 103 and node 105. The present colors are: c1, c10, c11, c2, c3, c4, c5 and c6. Node 104 is linked to node 100, node 101, node 102, node 103, node 105, node 106, node 107 and node 108. Node 100 is linked to node 1, node 10, node 101, node 102, node 103, node 104, node 105 and node 106. Node 10 is linked to node 1, node 100, node 109, node 11, node 120, node 2, node 20 and node 21. Node 103 is linked to node 100, node 101, node 102, node 104, node 105, node 106, node 107 and node 108. Node 1 is linked to node 10, node 100, node 109, node 11, node 111, node 12, node 121 and node 13.", "output": "colour(c1). colour(c10). colour(c11). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). link(1,10) link(1,100) link(1,109) link(1,11) link(1,111) link(1,12) link(1,121) link(1,13) link(10,1) link(10,100) link(10,109) link(10,11) link(10,120) link(10,2) link(10,20) link(10,21) link(100,1) link(100,10) link(100,101) link(100,102) link(100,103) link(100,104) link(100,105) link(100,106) link(101,100) link(101,102) link(101,103) link(101,104) link(101,105) link(101,106) link(101,107) link(101,108) link(102,100) link(102,101) link(102,103) link(102,104) link(102,105) link(102,106) link(102,107) link(102,108) link(103,100) link(103,101) link(103,102) link(103,104) link(103,105) link(103,106) link(103,107) link(103,108) link(104,100) link(104,101) link(104,102) link(104,103) link(104,105) link(104,106) link(104,107) link(104,108) link(105,100) link(105,101) link(105,102) link(105,103) link(105,104) link(105,106) link(105,107) link(105,108) node(20). node(111). node(2). node(21). node(104). node(106). node(12). node(1). node(11). node(109). node(107). node(101). node(121). node(120). node(10). node(13). node(100). node(108). node(102). node(103). node(105).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 102 is linked to node 100, node 101, node 103, node 104, node 105, node 106, node 107 and node 108. Node 101 is linked to node 100, node 102, node 103, node 104, node 105, node 106, node 107 and node 108. Node 105 is linked to node 100, node 101, node 102, node 103, node 104, node 106, node 107 and node 108. There are twenty-one nodes: node 20, node 111, node 2, node 21, node 104, node 106, node 12, node 1, node 11, node 109, node 107, node 101, node 121, node 120, node 10, node 13, node 100, node 108, node 102, node 103 and node 105. The present colors are: c1, c10, c11, c2, c3, c4, c5 and c6. Node 104 is linked to node 100, node 101, node 102, node 103, node 105, node 106, node 107 and node 108. Node 100 is linked to node 1, node 10, node 101, node 102, node 103, node 104, node 105 and node 106. Node 10 is linked to node 1, node 100, node 109, node 11, node 120, node 2, node 20 and node 21. Node 103 is linked to node 100, node 101, node 102, node 104, node 105, node 106, node 107 and node 108. Node 1 is linked to node 10, node 100, node 109, node 11, node 111, node 12, node 121 and node 13.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5901488786028660306", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "Node 1 is linked to node 109, node 31, node 55, node 80 and node 98. There are forty-three nodes: node 20, node 38, node 8, node 74, node 111, node 114, node 124, node 78, node 116, node 2, node 21, node 30, node 104, node 9, node 113, node 26, node 117, node 1, node 43, node 18, node 4, node 73, node 24, node 109, node 101, node 79, node 44, node 80, node 97, node 39, node 100, node 10, node 125, node 31, node 102, node 19, node 103, node 90, node 55, node 49, node 98, node 105 and node 57. Node 104 is linked to node 124, node 18, node 21, node 26, node 4, node 49 and node 9. Node 103 is linked to node 31, node 44, node 55, node 57 and node 98. Node 100 is linked to node 101, node 114, node 19, node 39, node 43, node 73, node 78 and node 8. Node 102 is linked to node 79, node 80 and node 90. Node 105 is linked to node 117, node 125, node 39, node 74, node 78 and node 97. The present colors are: c1, c2, c3, c4, c5, c6 and c7. Node 101 is linked to node 100, node 19, node 73 and node 78. Node 10 is linked to node 111, node 113, node 116, node 2, node 20, node 24, node 30 and node 38.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). colour(c5). colour(c6). colour(c7). link(1,109) link(1,31) link(1,55) link(1,80) link(1,98) link(10,111) link(10,113) link(10,116) link(10,2) link(10,20) link(10,24) link(10,30) link(10,38) link(100,101) link(100,114) link(100,19) link(100,39) link(100,43) link(100,73) link(100,78) link(100,8) link(101,100) link(101,19) link(101,73) link(101,78) link(102,79) link(102,80) link(102,90) link(103,31) link(103,44) link(103,55) link(103,57) link(103,98) link(104,124) link(104,18) link(104,21) link(104,26) link(104,4) link(104,49) link(104,9) link(105,117) link(105,125) link(105,39) link(105,74) link(105,78) link(105,97) node(20). node(38). node(8). node(74). node(111). node(114). node(124). node(78). node(116). node(2). node(21). node(30). node(104). node(9). node(113). node(26). node(117). node(1). node(43). node(18). node(4). node(73). node(24). node(109). node(101). node(79). node(44). node(80). node(97). node(39). node(100). node(10). node(125). node(31). node(102). node(19). node(103). node(90). node(55). node(49). node(98). node(105). node(57).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```Node 1 is linked to node 109, node 31, node 55, node 80 and node 98. There are forty-three nodes: node 20, node 38, node 8, node 74, node 111, node 114, node 124, node 78, node 116, node 2, node 21, node 30, node 104, node 9, node 113, node 26, node 117, node 1, node 43, node 18, node 4, node 73, node 24, node 109, node 101, node 79, node 44, node 80, node 97, node 39, node 100, node 10, node 125, node 31, node 102, node 19, node 103, node 90, node 55, node 49, node 98, node 105 and node 57. Node 104 is linked to node 124, node 18, node 21, node 26, node 4, node 49 and node 9. Node 103 is linked to node 31, node 44, node 55, node 57 and node 98. Node 100 is linked to node 101, node 114, node 19, node 39, node 43, node 73, node 78 and node 8. Node 102 is linked to node 79, node 80 and node 90. Node 105 is linked to node 117, node 125, node 39, node 74, node 78 and node 97. The present colors are: c1, c2, c3, c4, c5, c6 and c7. Node 101 is linked to node 100, node 19, node 73 and node 78. Node 10 is linked to node 111, node 113, node 116, node 2, node 20, node 24, node 30 and node 38.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8454246992299296648", "problem_id": "24", "problem_name": "Graph Colouring", "description": "A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.", "format": "A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).", "text": "The present colors are: c1, c2, c3, c4 and c5. There are nineteen nodes: node 20, node 17, node 2, node 14, node 21, node 9, node 23, node 22, node 12, node 1, node 18, node 4, node 11, node 15, node 16, node 10, node 13, node 19 and node 7. Node 1 is linked to node 13, node 15, node 18, node 2, node 20, node 4, node 7 and node 9. Node 12 is linked to node 23. Node 14 is linked to node 23. Node 16 is linked to node 23. Node 11 is linked to node 17, node 18, node 19, node 20 and node 21. Node 13 is linked to node 23. Node 10 is linked to node 11, node 14, node 15 and node 22. Node 15 is linked to node 23.", "output": "colour(c1). colour(c2). colour(c3). colour(c4). colour(c5). link(1,13) link(1,15) link(1,18) link(1,2) link(1,20) link(1,4) link(1,7) link(1,9) link(10,11) link(10,14) link(10,15) link(10,22) link(11,17) link(11,18) link(11,19) link(11,20) link(11,21) link(12,23) link(13,23) link(14,23) link(15,23) link(16,23) node(20). node(17). node(2). node(14). node(21). node(9). node(23). node(22). node(12). node(1). node(18). node(4). node(11). node(15). node(16). node(10). node(13). node(19). node(7).", "prompt": "Given the following problem description between triple backtips: \n ```A graph is a set of nodes and a symmetric, binary link relation on nodes. Given a set of N colours, a graph is colourable if each node can be assigned a colour in such a way that any two nodes that are linked together cannot have the same colour.```\nGiven the following specification for the predicates format: \n```A number of node facts which give the names of the nodes. Node names are consecutive, ascending integers starting from 1.\nA number of colour facts which give the names of the colours. Colour names start with the sequence \"red\", \"green\", \"blue\".\nA number of link facts which say which nodes are linked. Note that if link(N1,N2). is included then so will link(N2,N1).```\nExtract the datalog facts from this text: \n```The present colors are: c1, c2, c3, c4 and c5. There are nineteen nodes: node 20, node 17, node 2, node 14, node 21, node 9, node 23, node 22, node 12, node 1, node 18, node 4, node 11, node 15, node 16, node 10, node 13, node 19 and node 7. Node 1 is linked to node 13, node 15, node 18, node 2, node 20, node 4, node 7 and node 9. Node 12 is linked to node 23. Node 14 is linked to node 23. Node 16 is linked to node 23. Node 11 is linked to node 17, node 18, node 19, node 20 and node 21. Node 13 is linked to node 23. Node 10 is linked to node 11, node 14, node 15 and node 22. Node 15 is linked to node 23.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4734729659279607242", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 3 has a deadline 14. The completion time of job 13 must occur before the start time of 14. The job 1 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. Job 19 should end before 20 starts. Device 1 has instance one offline. Job 17 must finish before the start time of 18. Job 10 must finish before the start time of 11. The job 18 has a deadline 36. The job 30 has a deadline 18. The job 11 has an importance of 1, must be executed by device 3, need 5 timesteps to be performed. The end time of job 16 must precede the start time of 17. The job 13 has an importance of 1, must be executed by device 1, need 11 timesteps to be performed. The job 15 has a deadline 24, has an importance of 3, must be executed by device 5, need 13 timesteps to be performed. The total penalty for the schedule cannot be greater than 1638. The job 27 has a deadline 37. Job 14 must finish before the start time of 15. The job 14 has an importance of 3, must be executed by device 4, need 15 timesteps to be performed. The job 24 has a deadline 21. The job 12 has a deadline 29, has an importance of 2, must be executed by device 5, need 19 timesteps to be performed. Job 1 must be completed before 2 begins. The job 16 has an importance of 2, must be executed by device 1, need 17 timesteps to be performed. Instance three on device 2 is currently offline. Job 12 is not allowed to start before the end time of 11. The job 10 has an importance of 3, must be executed by device 1, need 9 timesteps to be performed. The job 21 has a deadline 27. The numerical quantities cannot exceed one thousand, eight hundred. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The current time is 0.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 29). importance(12, 2). job_device(12, 5). job_len(12, 19). job(12). deadline(15, 24). importance(15, 3). job_device(15, 5). job_len(15, 13). job(15). deadline(18, 36). job(18). deadline(21, 27). job(21). deadline(24, 21). job(24). deadline(27, 37). job(27). deadline(3, 14). job(3). deadline(30, 18). job(30). importance(1, 2). job_device(1, 1). job_len(1, 14). job(1). importance(10, 3). job_device(10, 1). job_len(10, 9). job(10). importance(11, 1). job_device(11, 3). job_len(11, 5). job(11). importance(13, 1). job_device(13, 1). job_len(13, 11). job(13). importance(14, 3). job_device(14, 4). job_len(14, 15). job(14). importance(16, 2). job_device(16, 1). job_len(16, 17). job(16). curr_time(0). max_total_penalty(1638). max_value(1800). offline_instance(1,1). offline_instance(3,2). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 3 has a deadline 14. The completion time of job 13 must occur before the start time of 14. The job 1 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. Job 19 should end before 20 starts. Device 1 has instance one offline. Job 17 must finish before the start time of 18. Job 10 must finish before the start time of 11. The job 18 has a deadline 36. The job 30 has a deadline 18. The job 11 has an importance of 1, must be executed by device 3, need 5 timesteps to be performed. The end time of job 16 must precede the start time of 17. The job 13 has an importance of 1, must be executed by device 1, need 11 timesteps to be performed. The job 15 has a deadline 24, has an importance of 3, must be executed by device 5, need 13 timesteps to be performed. The total penalty for the schedule cannot be greater than 1638. The job 27 has a deadline 37. Job 14 must finish before the start time of 15. The job 14 has an importance of 3, must be executed by device 4, need 15 timesteps to be performed. The job 24 has a deadline 21. The job 12 has a deadline 29, has an importance of 2, must be executed by device 5, need 19 timesteps to be performed. Job 1 must be completed before 2 begins. The job 16 has an importance of 2, must be executed by device 1, need 17 timesteps to be performed. Instance three on device 2 is currently offline. Job 12 is not allowed to start before the end time of 11. The job 10 has an importance of 3, must be executed by device 1, need 9 timesteps to be performed. The job 21 has a deadline 27. The numerical quantities cannot exceed one thousand, eight hundred. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The current time is 0.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4010263045640620876", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "Job 106 should end before 107 starts. Job 10 must be completed before 11 begins. The job 101 has an importance of 3, must be executed by device 3, need 13 timesteps to be performed. The job 111 start time in the schedule is 36, is scheduled to run on device instance 1, has a deadline 12. The job 117 has a deadline 17. The job 105 start time in the schedule is 22, is scheduled to run on device instance 1, has a deadline 35, has an importance of 3, must be executed by device 5, need 14 timesteps to be performed. Job 1 must be completed before 2 begins. The completion time of job 101 must occur before the start time of 102. The job 103 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. The job 114 has a deadline 17. The job 108 has a deadline 36. The job 110 start time in the schedule is 14, is scheduled to run on device instance 1. The job 104 start time in the schedule is 3, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 3, need 19 timesteps to be performed. The end time of job 100 must precede the start time of 101. The job 1 start time in the schedule is 60, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 2, need 17 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. Job 104 must be completed before 105 begins. The job 100 has an importance of 1, must be executed by device 1, need 8 timesteps to be performed. The job 109 start time in the schedule is 0, is scheduled to run on device instance 1. The job 16 start time in the schedule is 31, is scheduled to run on device instance 1. The job 12 has a deadline 19. The highest possible value for the numerical quantities is five thousand and thirteen. Job 104 is not allowed to start before the end time of 103. Device 1 is showing instance four as offline. Time is on 208. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The completion time of job 107 must occur before the start time of 108. The job 120 has a deadline 39. The job 102 has a deadline 32, has an importance of 2, must be executed by device 5, need 6 timesteps to be performed. The total penalty of the schedule must be less than or equal to 4597.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(1, 60). curr_on_instance(1, 1). importance(1, 1). job_device(1, 2). job_len(1, 17). job(1). curr_job_start(103, 0). curr_on_instance(103, 1). importance(103, 2). job_device(103, 1). job_len(103, 3). job(103). curr_job_start(104, 3). curr_on_instance(104, 1). importance(104, 3). job_device(104, 3). job_len(104, 19). job(104). curr_job_start(105, 22). curr_on_instance(105, 1). deadline(105, 35). importance(105, 3). job_device(105, 5). job_len(105, 14). job(105). curr_job_start(109, 0). curr_on_instance(109, 1). job(109). curr_job_start(110, 14). curr_on_instance(110, 1). job(110). curr_job_start(111, 36). curr_on_instance(111, 1). deadline(111, 12). job(111). curr_job_start(16, 31). curr_on_instance(16, 1). job(16). deadline(102, 32). importance(102, 2). job_device(102, 5). job_len(102, 6). job(102). deadline(108, 36). job(108). deadline(114, 17). job(114). deadline(117, 17). job(117). deadline(12, 19). job(12). deadline(120, 39). job(120). importance(10, 3). job_device(10, 1). job_len(10, 15). job(10). importance(100, 1). job_device(100, 1). job_len(100, 8). job(100). importance(101, 3). job_device(101, 3). job_len(101, 13). job(101). curr_time(208). max_total_penalty(4597). max_value(5013). offline_instance(4,1). precedes(1,2). precedes(10,11). precedes(100,101). precedes(101,102). precedes(103,104). precedes(104,105). precedes(106,107). precedes(107,108).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```Job 106 should end before 107 starts. Job 10 must be completed before 11 begins. The job 101 has an importance of 3, must be executed by device 3, need 13 timesteps to be performed. The job 111 start time in the schedule is 36, is scheduled to run on device instance 1, has a deadline 12. The job 117 has a deadline 17. The job 105 start time in the schedule is 22, is scheduled to run on device instance 1, has a deadline 35, has an importance of 3, must be executed by device 5, need 14 timesteps to be performed. Job 1 must be completed before 2 begins. The completion time of job 101 must occur before the start time of 102. The job 103 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. The job 114 has a deadline 17. The job 108 has a deadline 36. The job 110 start time in the schedule is 14, is scheduled to run on device instance 1. The job 104 start time in the schedule is 3, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 3, need 19 timesteps to be performed. The end time of job 100 must precede the start time of 101. The job 1 start time in the schedule is 60, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 2, need 17 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. Job 104 must be completed before 105 begins. The job 100 has an importance of 1, must be executed by device 1, need 8 timesteps to be performed. The job 109 start time in the schedule is 0, is scheduled to run on device instance 1. The job 16 start time in the schedule is 31, is scheduled to run on device instance 1. The job 12 has a deadline 19. The highest possible value for the numerical quantities is five thousand and thirteen. Job 104 is not allowed to start before the end time of 103. Device 1 is showing instance four as offline. Time is on 208. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The completion time of job 107 must occur before the start time of 108. The job 120 has a deadline 39. The job 102 has a deadline 32, has an importance of 2, must be executed by device 5, need 6 timesteps to be performed. The total penalty of the schedule must be less than or equal to 4597.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8933328718115443649", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 21 has a deadline 21. The job 10 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. Job 17 is not allowed to start before the end time of 16. The job 16 has an importance of 1, must be executed by device 1, need 4 timesteps to be performed. Job 13 should end before 14 starts. The job 13 has an importance of 2, must be executed by device 2, need 4 timesteps to be performed. The total penalty of the schedule must be less than or equal to 2760. The job 18 has a deadline 38. The numerical quantities cannot exceed three thousand. Job 15 should begin only after the end time of 14. Time is on 0. The job 27 has a deadline 28. The job 14 has an importance of 1, must be executed by device 4, need 18 timesteps to be performed. The job 24 has a deadline 40. The completion time of job 1 must occur before the start time of 2. The job 15 has a deadline 35, has an importance of 1, must be executed by device 5, need 3 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 2, need 6 timesteps to be performed. Job 17 must be completed before 18 begins. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 30 has a deadline 40. The job 3 has a deadline 19. The job 12 has a deadline 16, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. The start time of 11 must be after the end time of 10. The start time of 20 must be after the end time of 19. Job 11 must finish before the start time of 12. The job 11 has an importance of 1, must be executed by device 3, need 6 timesteps to be performed. Instance three from device 1 has gone offline.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 16). importance(12, 2). job_device(12, 5). job_len(12, 12). job(12). deadline(15, 35). importance(15, 1). job_device(15, 5). job_len(15, 3). job(15). deadline(18, 38). job(18). deadline(21, 21). job(21). deadline(24, 40). job(24). deadline(27, 28). job(27). deadline(3, 19). job(3). deadline(30, 40). job(30). importance(1, 2). job_device(1, 2). job_len(1, 6). job(1). importance(10, 1). job_device(10, 1). job_len(10, 13). job(10). importance(11, 1). job_device(11, 3). job_len(11, 6). job(11). importance(13, 2). job_device(13, 2). job_len(13, 4). job(13). importance(14, 1). job_device(14, 4). job_len(14, 18). job(14). importance(16, 1). job_device(16, 1). job_len(16, 4). job(16). curr_time(0). max_total_penalty(2760). max_value(3000). offline_instance(3,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 21 has a deadline 21. The job 10 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. Job 17 is not allowed to start before the end time of 16. The job 16 has an importance of 1, must be executed by device 1, need 4 timesteps to be performed. Job 13 should end before 14 starts. The job 13 has an importance of 2, must be executed by device 2, need 4 timesteps to be performed. The total penalty of the schedule must be less than or equal to 2760. The job 18 has a deadline 38. The numerical quantities cannot exceed three thousand. Job 15 should begin only after the end time of 14. Time is on 0. The job 27 has a deadline 28. The job 14 has an importance of 1, must be executed by device 4, need 18 timesteps to be performed. The job 24 has a deadline 40. The completion time of job 1 must occur before the start time of 2. The job 15 has a deadline 35, has an importance of 1, must be executed by device 5, need 3 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 2, need 6 timesteps to be performed. Job 17 must be completed before 18 begins. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 30 has a deadline 40. The job 3 has a deadline 19. The job 12 has a deadline 16, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. The start time of 11 must be after the end time of 10. The start time of 20 must be after the end time of 19. Job 11 must finish before the start time of 12. The job 11 has an importance of 1, must be executed by device 3, need 6 timesteps to be performed. Instance three from device 1 has gone offline.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3459089026359275704", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 24 has a deadline 19. The job 15 has a deadline 18, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. Job 2 should begin only after the end time of 1. The start time of 14 must be after the end time of 13. Instance two on the device 1 is down. The job 14 has an importance of 1, must be executed by device 4, need 18 timesteps to be performed. Job 10 must finish before the start time of 11. Job 11 must finish before the start time of 12. The schedule's total penalty must not exceed 1400. The job 21 has a deadline 31. Job 17 must be completed before 18 begins. The job 18 has a deadline 22. The job 30 has a deadline 18. The job 13 has an importance of 2, must be executed by device 1, need 19 timesteps to be performed. The end time of job 19 must precede the start time of 20. Time is on 0. The job 10 has an importance of 2, must be executed by device 1, need 10 timesteps to be performed. The job 27 has a deadline 21. The job 1 has an importance of 3, must be executed by device 1, need 18 timesteps to be performed. The job 12 has a deadline 13, has an importance of 3, must be executed by device 5, need 14 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 19 timesteps to be performed. The highest possible value for the numerical quantities is one thousand, four hundred and forty. Job 15 is not allowed to start before the end time of 14. The start time of 17 must be after the end time of 16. The job 16 has an importance of 2, must be executed by device 2, need 14 timesteps to be performed. The job 3 has a deadline 10.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 13). importance(12, 3). job_device(12, 5). job_len(12, 14). job(12). deadline(15, 18). importance(15, 2). job_device(15, 5). job_len(15, 12). job(15). deadline(18, 22). job(18). deadline(21, 31). job(21). deadline(24, 19). job(24). deadline(27, 21). job(27). deadline(3, 10). job(3). deadline(30, 18). job(30). importance(1, 3). job_device(1, 1). job_len(1, 18). job(1). importance(10, 2). job_device(10, 1). job_len(10, 10). job(10). importance(11, 3). job_device(11, 3). job_len(11, 19). job(11). importance(13, 2). job_device(13, 1). job_len(13, 19). job(13). importance(14, 1). job_device(14, 4). job_len(14, 18). job(14). importance(16, 2). job_device(16, 2). job_len(16, 14). job(16). curr_time(0). max_total_penalty(1400). max_value(1440). offline_instance(2,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 24 has a deadline 19. The job 15 has a deadline 18, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. Job 2 should begin only after the end time of 1. The start time of 14 must be after the end time of 13. Instance two on the device 1 is down. The job 14 has an importance of 1, must be executed by device 4, need 18 timesteps to be performed. Job 10 must finish before the start time of 11. Job 11 must finish before the start time of 12. The schedule's total penalty must not exceed 1400. The job 21 has a deadline 31. Job 17 must be completed before 18 begins. The job 18 has a deadline 22. The job 30 has a deadline 18. The job 13 has an importance of 2, must be executed by device 1, need 19 timesteps to be performed. The end time of job 19 must precede the start time of 20. Time is on 0. The job 10 has an importance of 2, must be executed by device 1, need 10 timesteps to be performed. The job 27 has a deadline 21. The job 1 has an importance of 3, must be executed by device 1, need 18 timesteps to be performed. The job 12 has a deadline 13, has an importance of 3, must be executed by device 5, need 14 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 19 timesteps to be performed. The highest possible value for the numerical quantities is one thousand, four hundred and forty. Job 15 is not allowed to start before the end time of 14. The start time of 17 must be after the end time of 16. The job 16 has an importance of 2, must be executed by device 2, need 14 timesteps to be performed. The job 3 has a deadline 10.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8729215910539297000", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The total penalty of the schedule must be less than or equal to 4702. Job 2 is not allowed to start before the end time of 1. The job 1 has an importance of 2, must be executed by device 1, need 12 timesteps to be performed. The job 101 has an importance of 3, must be executed by device 4, need 18 timesteps to be performed. The end time of job 106 must precede the start time of 107. Job 104 should end before 105 starts. The end time of job 10 must precede the start time of 11. The numerical quantities cannot exceed four thousand, eight hundred. The job 114 has a deadline 14. The job 104 has an importance of 1, must be executed by device 3, need 8 timesteps to be performed. The job 105 has a deadline 24, has an importance of 2, must be executed by device 5, need 3 timesteps to be performed. The end time of job 103 must precede the start time of 104. The job 10 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. The job 120 has a deadline 10. The job 117 has a deadline 11. Job 100 must be completed before 101 begins. The job 102 has a deadline 20, has an importance of 3, must be executed by device 5, need 3 timesteps to be performed. The job 12 has a deadline 40. The job 103 has an importance of 3, must be executed by device 2, need 4 timesteps to be performed. Job 101 should end before 102 starts. The job 100 has an importance of 3, must be executed by device 2, need 5 timesteps to be performed. Time is on 0. Job 107 must be completed before 108 begins. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 108 has a deadline 17. The job 111 has a deadline 32.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(102, 20). importance(102, 3). job_device(102, 5). job_len(102, 3). job(102). deadline(105, 24). importance(105, 2). job_device(105, 5). job_len(105, 3). job(105). deadline(108, 17). job(108). deadline(111, 32). job(111). deadline(114, 14). job(114). deadline(117, 11). job(117). deadline(12, 40). job(12). deadline(120, 10). job(120). importance(1, 2). job_device(1, 1). job_len(1, 12). job(1). importance(10, 1). job_device(10, 2). job_len(10, 15). job(10). importance(100, 3). job_device(100, 2). job_len(100, 5). job(100). importance(101, 3). job_device(101, 4). job_len(101, 18). job(101). importance(103, 3). job_device(103, 2). job_len(103, 4). job(103). importance(104, 1). job_device(104, 3). job_len(104, 8). job(104). curr_time(0). max_total_penalty(4702). max_value(4800). precedes(1,2). precedes(10,11). precedes(100,101). precedes(101,102). precedes(103,104). precedes(104,105). precedes(106,107). precedes(107,108).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The total penalty of the schedule must be less than or equal to 4702. Job 2 is not allowed to start before the end time of 1. The job 1 has an importance of 2, must be executed by device 1, need 12 timesteps to be performed. The job 101 has an importance of 3, must be executed by device 4, need 18 timesteps to be performed. The end time of job 106 must precede the start time of 107. Job 104 should end before 105 starts. The end time of job 10 must precede the start time of 11. The numerical quantities cannot exceed four thousand, eight hundred. The job 114 has a deadline 14. The job 104 has an importance of 1, must be executed by device 3, need 8 timesteps to be performed. The job 105 has a deadline 24, has an importance of 2, must be executed by device 5, need 3 timesteps to be performed. The end time of job 103 must precede the start time of 104. The job 10 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. The job 120 has a deadline 10. The job 117 has a deadline 11. Job 100 must be completed before 101 begins. The job 102 has a deadline 20, has an importance of 3, must be executed by device 5, need 3 timesteps to be performed. The job 12 has a deadline 40. The job 103 has an importance of 3, must be executed by device 2, need 4 timesteps to be performed. Job 101 should end before 102 starts. The job 100 has an importance of 3, must be executed by device 2, need 5 timesteps to be performed. Time is on 0. Job 107 must be completed before 108 begins. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 108 has a deadline 17. The job 111 has a deadline 32.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7704873502911959189", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The completion time of job 17 must occur before the start time of 18. The job 3 has a deadline 28. The completion time of job 10 must occur before the start time of 11. The job 16 has an importance of 1, must be executed by device 1, need 6 timesteps to be performed. Job 16 must be completed before 17 begins. Job 11 must finish before the start time of 12. The job 27 has a deadline 13. The total penalty for the schedule cannot be greater than 2152. The greatest possible value for the numerical quantities is two thousand, two hundred and sixty-one. The job 28 start time in the schedule is 0, is scheduled to run on device instance 1. Job 1 should end before 2 starts. The job 22 start time in the schedule is 15, is scheduled to run on device instance 1. The job 23 start time in the schedule is 28, is scheduled to run on device instance 2. The job 14 has an importance of 3, must be executed by device 4, need 3 timesteps to be performed. The job 15 has a deadline 10, has an importance of 1, must be executed by device 5, need 16 timesteps to be performed. The job 10 has an importance of 2, must be executed by device 1, need 6 timesteps to be performed. The current time is 30. The job 21 start time in the schedule is 82, is scheduled to run on device instance 1, has a deadline 27. The job 11 has an importance of 2, must be executed by device 3, need 15 timesteps to be performed. The job 19 start time in the schedule is 20, is scheduled to run on device instance 2. The job 20 start time in the schedule is 39, is scheduled to run on device instance 1. The job 29 start time in the schedule is 17, is scheduled to run on device instance 2. The job 12 has a deadline 23, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. The job 18 has a deadline 21. Job 15 should begin only after the end time of 14. The job 30 has a deadline 14. The job 1 has an importance of 2, must be executed by device 1, need 20 timesteps to be performed. The job 24 start time in the schedule is 70, is scheduled to run on device instance 1, has a deadline 18. Job 13 must be completed before 14 begins. Job 20 is not allowed to start before the end time of 19. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 13 has an importance of 1, must be executed by device 2, need 6 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(19, 20). curr_on_instance(19, 2). job(19). curr_job_start(20, 39). curr_on_instance(20, 1). job(20). curr_job_start(21, 82). curr_on_instance(21, 1). deadline(21, 27). job(21). curr_job_start(22, 15). curr_on_instance(22, 1). job(22). curr_job_start(23, 28). curr_on_instance(23, 2). job(23). curr_job_start(24, 70). curr_on_instance(24, 1). deadline(24, 18). job(24). curr_job_start(28, 0). curr_on_instance(28, 1). job(28). curr_job_start(29, 17). curr_on_instance(29, 2). job(29). deadline(12, 23). importance(12, 3). job_device(12, 5). job_len(12, 5). job(12). deadline(15, 10). importance(15, 1). job_device(15, 5). job_len(15, 16). job(15). deadline(18, 21). job(18). deadline(27, 13). job(27). deadline(3, 28). job(3). deadline(30, 14). job(30). importance(1, 2). job_device(1, 1). job_len(1, 20). job(1). importance(10, 2). job_device(10, 1). job_len(10, 6). job(10). importance(11, 2). job_device(11, 3). job_len(11, 15). job(11). importance(13, 1). job_device(13, 2). job_len(13, 6). job(13). importance(14, 3). job_device(14, 4). job_len(14, 3). job(14). importance(16, 1). job_device(16, 1). job_len(16, 6). job(16). curr_time(30). max_total_penalty(2152). max_value(2261). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The completion time of job 17 must occur before the start time of 18. The job 3 has a deadline 28. The completion time of job 10 must occur before the start time of 11. The job 16 has an importance of 1, must be executed by device 1, need 6 timesteps to be performed. Job 16 must be completed before 17 begins. Job 11 must finish before the start time of 12. The job 27 has a deadline 13. The total penalty for the schedule cannot be greater than 2152. The greatest possible value for the numerical quantities is two thousand, two hundred and sixty-one. The job 28 start time in the schedule is 0, is scheduled to run on device instance 1. Job 1 should end before 2 starts. The job 22 start time in the schedule is 15, is scheduled to run on device instance 1. The job 23 start time in the schedule is 28, is scheduled to run on device instance 2. The job 14 has an importance of 3, must be executed by device 4, need 3 timesteps to be performed. The job 15 has a deadline 10, has an importance of 1, must be executed by device 5, need 16 timesteps to be performed. The job 10 has an importance of 2, must be executed by device 1, need 6 timesteps to be performed. The current time is 30. The job 21 start time in the schedule is 82, is scheduled to run on device instance 1, has a deadline 27. The job 11 has an importance of 2, must be executed by device 3, need 15 timesteps to be performed. The job 19 start time in the schedule is 20, is scheduled to run on device instance 2. The job 20 start time in the schedule is 39, is scheduled to run on device instance 1. The job 29 start time in the schedule is 17, is scheduled to run on device instance 2. The job 12 has a deadline 23, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. The job 18 has a deadline 21. Job 15 should begin only after the end time of 14. The job 30 has a deadline 14. The job 1 has an importance of 2, must be executed by device 1, need 20 timesteps to be performed. The job 24 start time in the schedule is 70, is scheduled to run on device instance 1, has a deadline 18. Job 13 must be completed before 14 begins. Job 20 is not allowed to start before the end time of 19. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 13 has an importance of 1, must be executed by device 2, need 6 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8671407333053033211", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "Job 18 is not allowed to start before the end time of 17. The highest possible value for the numerical quantities is two thousand, four hundred. The job 18 has a deadline 25. The job 16 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. The completion time of job 13 must occur before the start time of 14. The job 24 has a deadline 15. The job 21 has a deadline 36. Job 10 should end before 11 starts. The job 14 has an importance of 3, must be executed by device 3, need 16 timesteps to be performed. The job 13 has an importance of 2, must be executed by device 2, need 12 timesteps to be performed. Job 20 should begin only after the end time of 19. The job 11 has an importance of 3, must be executed by device 4, need 7 timesteps to be performed. Job 14 must be completed before 15 begins. The job 30 has a deadline 33. The start time of 12 must be after the end time of 11. The completion time of job 16 must occur before the start time of 17. The job 15 has a deadline 35, has an importance of 1, must be executed by device 5, need 4 timesteps to be performed. The job 27 has a deadline 31. The total penalty of the schedule must be less than or equal to 2245. The job 12 has a deadline 33, has an importance of 3, must be executed by device 5, need 20 timesteps to be performed. Job 1 must finish before the start time of 2. The job 1 has an importance of 3, must be executed by device 2, need 6 timesteps to be performed. The current time is 0. The job 10 has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 3 has a deadline 25. Device 1 has instance two offline. Instance three on the device 2 is down.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 33). importance(12, 3). job_device(12, 5). job_len(12, 20). job(12). deadline(15, 35). importance(15, 1). job_device(15, 5). job_len(15, 4). job(15). deadline(18, 25). job(18). deadline(21, 36). job(21). deadline(24, 15). job(24). deadline(27, 31). job(27). deadline(3, 25). job(3). deadline(30, 33). job(30). importance(1, 3). job_device(1, 2). job_len(1, 6). job(1). importance(10, 2). job_device(10, 1). job_len(10, 3). job(10). importance(11, 3). job_device(11, 4). job_len(11, 7). job(11). importance(13, 2). job_device(13, 2). job_len(13, 12). job(13). importance(14, 3). job_device(14, 3). job_len(14, 16). job(14). importance(16, 1). job_device(16, 1). job_len(16, 13). job(16). curr_time(0). max_total_penalty(2245). max_value(2400). offline_instance(2,1). offline_instance(3,2). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```Job 18 is not allowed to start before the end time of 17. The highest possible value for the numerical quantities is two thousand, four hundred. The job 18 has a deadline 25. The job 16 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. The completion time of job 13 must occur before the start time of 14. The job 24 has a deadline 15. The job 21 has a deadline 36. Job 10 should end before 11 starts. The job 14 has an importance of 3, must be executed by device 3, need 16 timesteps to be performed. The job 13 has an importance of 2, must be executed by device 2, need 12 timesteps to be performed. Job 20 should begin only after the end time of 19. The job 11 has an importance of 3, must be executed by device 4, need 7 timesteps to be performed. Job 14 must be completed before 15 begins. The job 30 has a deadline 33. The start time of 12 must be after the end time of 11. The completion time of job 16 must occur before the start time of 17. The job 15 has a deadline 35, has an importance of 1, must be executed by device 5, need 4 timesteps to be performed. The job 27 has a deadline 31. The total penalty of the schedule must be less than or equal to 2245. The job 12 has a deadline 33, has an importance of 3, must be executed by device 5, need 20 timesteps to be performed. Job 1 must finish before the start time of 2. The job 1 has an importance of 3, must be executed by device 2, need 6 timesteps to be performed. The current time is 0. The job 10 has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 3 has a deadline 25. Device 1 has instance two offline. Instance three on the device 2 is down.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4462156897440945905", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 111 has a deadline 27. Time is on 0. The job 105 has a deadline 25, has an importance of 1, must be executed by device 5, need 12 timesteps to be performed. The schedule's total penalty must be at most 4642. Job 100 should end before 101 starts. The job 120 has a deadline 32. The job 100 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. Job 107 should begin only after the end time of 106. The job 103 has an importance of 3, must be executed by device 2, need 19 timesteps to be performed. Instance three on the device 2 is down. The job 104 has an importance of 2, must be executed by device 4, need 17 timesteps to be performed. The job 12 has a deadline 10. The start time of 104 must be after the end time of 103. The completion time of job 1 must occur before the start time of 2. Job 108 should begin only after the end time of 107. The highest possible value for the numerical quantities is four thousand, eight hundred. The job 1 has an importance of 2, must be executed by device 2, need 11 timesteps to be performed. Job 11 should begin only after the end time of 10. The job 108 has a deadline 19. The job 114 has a deadline 27. The start time of 105 must be after the end time of 104. The job 117 has a deadline 37. The job 10 has an importance of 1, must be executed by device 1, need 16 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 101 has an importance of 3, must be executed by device 4, need 14 timesteps to be performed. The job 102 has a deadline 36, has an importance of 3, must be executed by device 5, need 17 timesteps to be performed. Job 102 is not allowed to start before the end time of 101.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(102, 36). importance(102, 3). job_device(102, 5). job_len(102, 17). job(102). deadline(105, 25). importance(105, 1). job_device(105, 5). job_len(105, 12). job(105). deadline(108, 19). job(108). deadline(111, 27). job(111). deadline(114, 27). job(114). deadline(117, 37). job(117). deadline(12, 10). job(12). deadline(120, 32). job(120). importance(1, 2). job_device(1, 2). job_len(1, 11). job(1). importance(10, 1). job_device(10, 1). job_len(10, 16). job(10). importance(100, 1). job_device(100, 1). job_len(100, 13). job(100). importance(101, 3). job_device(101, 4). job_len(101, 14). job(101). importance(103, 3). job_device(103, 2). job_len(103, 19). job(103). importance(104, 2). job_device(104, 4). job_len(104, 17). job(104). curr_time(0). max_total_penalty(4642). max_value(4800). offline_instance(3,2). precedes(1,2). precedes(10,11). precedes(100,101). precedes(101,102). precedes(103,104). precedes(104,105). precedes(106,107). precedes(107,108).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 111 has a deadline 27. Time is on 0. The job 105 has a deadline 25, has an importance of 1, must be executed by device 5, need 12 timesteps to be performed. The schedule's total penalty must be at most 4642. Job 100 should end before 101 starts. The job 120 has a deadline 32. The job 100 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. Job 107 should begin only after the end time of 106. The job 103 has an importance of 3, must be executed by device 2, need 19 timesteps to be performed. Instance three on the device 2 is down. The job 104 has an importance of 2, must be executed by device 4, need 17 timesteps to be performed. The job 12 has a deadline 10. The start time of 104 must be after the end time of 103. The completion time of job 1 must occur before the start time of 2. Job 108 should begin only after the end time of 107. The highest possible value for the numerical quantities is four thousand, eight hundred. The job 1 has an importance of 2, must be executed by device 2, need 11 timesteps to be performed. Job 11 should begin only after the end time of 10. The job 108 has a deadline 19. The job 114 has a deadline 27. The start time of 105 must be after the end time of 104. The job 117 has a deadline 37. The job 10 has an importance of 1, must be executed by device 1, need 16 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 101 has an importance of 3, must be executed by device 4, need 14 timesteps to be performed. The job 102 has a deadline 36, has an importance of 3, must be executed by device 5, need 17 timesteps to be performed. Job 102 is not allowed to start before the end time of 101.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2764630411379303860", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 30 has a deadline 27. The job 16 has an importance of 1, must be executed by device 2, need 16 timesteps to be performed. The present time is 0. The end time of job 13 must precede the start time of 14. The job 27 has a deadline 39. The job 18 has a deadline 22. The numerical quantities cannot exceed one thousand, four hundred and forty. The job 1 has an importance of 1, must be executed by device 1, need 3 timesteps to be performed. The job 21 has a deadline 18. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 17 is not allowed to start before the end time of 16. The completion time of job 17 must occur before the start time of 18. Job 19 must finish before the start time of 20. The job 15 has a deadline 13, has an importance of 3, must be executed by device 5, need 3 timesteps to be performed. Job 1 must finish before the start time of 2. The job 14 has an importance of 3, must be executed by device 3, need 9 timesteps to be performed. The schedule's total penalty must not exceed 1374. The end time of job 10 must precede the start time of 11. The job 13 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. Job 11 should end before 12 starts. The job 24 has a deadline 38. The job 12 has a deadline 26, has an importance of 1, must be executed by device 5, need 15 timesteps to be performed. The job 3 has a deadline 38. The job 10 has an importance of 3, must be executed by device 2, need 19 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 9 timesteps to be performed. The end time of job 14 must precede the start time of 15. Instance three from device 2 has gone offline.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 26). importance(12, 1). job_device(12, 5). job_len(12, 15). job(12). deadline(15, 13). importance(15, 3). job_device(15, 5). job_len(15, 3). job(15). deadline(18, 22). job(18). deadline(21, 18). job(21). deadline(24, 38). job(24). deadline(27, 39). job(27). deadline(3, 38). job(3). deadline(30, 27). job(30). importance(1, 1). job_device(1, 1). job_len(1, 3). job(1). importance(10, 3). job_device(10, 2). job_len(10, 19). job(10). importance(11, 3). job_device(11, 3). job_len(11, 9). job(11). importance(13, 3). job_device(13, 1). job_len(13, 15). job(13). importance(14, 3). job_device(14, 3). job_len(14, 9). job(14). importance(16, 1). job_device(16, 2). job_len(16, 16). job(16). curr_time(0). max_total_penalty(1374). max_value(1440). offline_instance(3,2). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 30 has a deadline 27. The job 16 has an importance of 1, must be executed by device 2, need 16 timesteps to be performed. The present time is 0. The end time of job 13 must precede the start time of 14. The job 27 has a deadline 39. The job 18 has a deadline 22. The numerical quantities cannot exceed one thousand, four hundred and forty. The job 1 has an importance of 1, must be executed by device 1, need 3 timesteps to be performed. The job 21 has a deadline 18. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 17 is not allowed to start before the end time of 16. The completion time of job 17 must occur before the start time of 18. Job 19 must finish before the start time of 20. The job 15 has a deadline 13, has an importance of 3, must be executed by device 5, need 3 timesteps to be performed. Job 1 must finish before the start time of 2. The job 14 has an importance of 3, must be executed by device 3, need 9 timesteps to be performed. The schedule's total penalty must not exceed 1374. The end time of job 10 must precede the start time of 11. The job 13 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. Job 11 should end before 12 starts. The job 24 has a deadline 38. The job 12 has a deadline 26, has an importance of 1, must be executed by device 5, need 15 timesteps to be performed. The job 3 has a deadline 38. The job 10 has an importance of 3, must be executed by device 2, need 19 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 9 timesteps to be performed. The end time of job 14 must precede the start time of 15. Instance three from device 2 has gone offline.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7317097609531126964", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The completion time of job 107 must occur before the start time of 108. Job 11 is not allowed to start before the end time of 10. The job 10 has an importance of 2, must be executed by device 1, need 19 timesteps to be performed. The job 117 has a deadline 15. The job 108 has a deadline 29. Job 101 should end before 102 starts. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 100 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. The completion time of job 1 must occur before the start time of 2. The numerical quantities can have a maximum value of four thousand, eight hundred. The start time of 107 must be after the end time of 106. The schedule's total penalty must be at most 4401. The job 101 has an importance of 2, must be executed by device 3, need 16 timesteps to be performed. Job 104 must be completed before 105 begins. The job 114 has a deadline 13. The start time of 104 must be after the end time of 103. The job 12 has a deadline 19. The job 1 has an importance of 3, must be executed by device 2, need 16 timesteps to be performed. Job 100 must be completed before 101 begins. The job 120 has a deadline 15. The present time is 0. The job 111 has a deadline 36. The job 104 has an importance of 3, must be executed by device 3, need 19 timesteps to be performed. The job 105 has a deadline 32, has an importance of 2, must be executed by device 5, need 3 timesteps to be performed. The job 102 has a deadline 17, has an importance of 2, must be executed by device 5, need 18 timesteps to be performed. The job 103 has an importance of 1, must be executed by device 2, need 13 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(102, 17). importance(102, 2). job_device(102, 5). job_len(102, 18). job(102). deadline(105, 32). importance(105, 2). job_device(105, 5). job_len(105, 3). job(105). deadline(108, 29). job(108). deadline(111, 36). job(111). deadline(114, 13). job(114). deadline(117, 15). job(117). deadline(12, 19). job(12). deadline(120, 15). job(120). importance(1, 3). job_device(1, 2). job_len(1, 16). job(1). importance(10, 2). job_device(10, 1). job_len(10, 19). job(10). importance(100, 1). job_device(100, 1). job_len(100, 12). job(100). importance(101, 2). job_device(101, 3). job_len(101, 16). job(101). importance(103, 1). job_device(103, 2). job_len(103, 13). job(103). importance(104, 3). job_device(104, 3). job_len(104, 19). job(104). curr_time(0). max_total_penalty(4401). max_value(4800). precedes(1,2). precedes(10,11). precedes(100,101). precedes(101,102). precedes(103,104). precedes(104,105). precedes(106,107). precedes(107,108).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The completion time of job 107 must occur before the start time of 108. Job 11 is not allowed to start before the end time of 10. The job 10 has an importance of 2, must be executed by device 1, need 19 timesteps to be performed. The job 117 has a deadline 15. The job 108 has a deadline 29. Job 101 should end before 102 starts. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 100 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. The completion time of job 1 must occur before the start time of 2. The numerical quantities can have a maximum value of four thousand, eight hundred. The start time of 107 must be after the end time of 106. The schedule's total penalty must be at most 4401. The job 101 has an importance of 2, must be executed by device 3, need 16 timesteps to be performed. Job 104 must be completed before 105 begins. The job 114 has a deadline 13. The start time of 104 must be after the end time of 103. The job 12 has a deadline 19. The job 1 has an importance of 3, must be executed by device 2, need 16 timesteps to be performed. Job 100 must be completed before 101 begins. The job 120 has a deadline 15. The present time is 0. The job 111 has a deadline 36. The job 104 has an importance of 3, must be executed by device 3, need 19 timesteps to be performed. The job 105 has a deadline 32, has an importance of 2, must be executed by device 5, need 3 timesteps to be performed. The job 102 has a deadline 17, has an importance of 2, must be executed by device 5, need 18 timesteps to be performed. The job 103 has an importance of 1, must be executed by device 2, need 13 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8732105612660523338", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "Job 11 is not allowed to start before the end time of 10. Instance three from device 2 has gone offline. The job 21 has a deadline 21. The job 24 has a deadline 32. The start time of 20 must be after the end time of 19. Job 1 must finish before the start time of 2. The maximum possible value for the numerical quanitities is one thousand, four hundred and forty. The job 1 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. The total penalty of the schedule must be less than or equal to 1316. The job 15 has a deadline 22, has an importance of 3, must be executed by device 5, need 3 timesteps to be performed. The job 14 has an importance of 2, must be executed by device 4, need 8 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The current time is 0. Job 14 must be completed before 15 begins. The job 18 has a deadline 34. Job 13 must finish before the start time of 14. The job 27 has a deadline 34. Job 17 must finish before the start time of 18. The job 11 has an importance of 3, must be executed by device 4, need 15 timesteps to be performed. Job 12 is not allowed to start before the end time of 11. The job 13 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 2, need 4 timesteps to be performed. The job 16 has an importance of 1, must be executed by device 2, need 7 timesteps to be performed. The job 12 has a deadline 10, has an importance of 1, must be executed by device 5, need 5 timesteps to be performed. Job 17 should begin only after the end time of 16. The job 30 has a deadline 24. The job 3 has a deadline 40.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 10). importance(12, 1). job_device(12, 5). job_len(12, 5). job(12). deadline(15, 22). importance(15, 3). job_device(15, 5). job_len(15, 3). job(15). deadline(18, 34). job(18). deadline(21, 21). job(21). deadline(24, 32). job(24). deadline(27, 34). job(27). deadline(3, 40). job(3). deadline(30, 24). job(30). importance(1, 2). job_device(1, 1). job_len(1, 14). job(1). importance(10, 3). job_device(10, 2). job_len(10, 4). job(10). importance(11, 3). job_device(11, 4). job_len(11, 15). job(11). importance(13, 1). job_device(13, 1). job_len(13, 12). job(13). importance(14, 2). job_device(14, 4). job_len(14, 8). job(14). importance(16, 1). job_device(16, 2). job_len(16, 7). job(16). curr_time(0). max_total_penalty(1316). max_value(1440). offline_instance(3,2). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```Job 11 is not allowed to start before the end time of 10. Instance three from device 2 has gone offline. The job 21 has a deadline 21. The job 24 has a deadline 32. The start time of 20 must be after the end time of 19. Job 1 must finish before the start time of 2. The maximum possible value for the numerical quanitities is one thousand, four hundred and forty. The job 1 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. The total penalty of the schedule must be less than or equal to 1316. The job 15 has a deadline 22, has an importance of 3, must be executed by device 5, need 3 timesteps to be performed. The job 14 has an importance of 2, must be executed by device 4, need 8 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The current time is 0. Job 14 must be completed before 15 begins. The job 18 has a deadline 34. Job 13 must finish before the start time of 14. The job 27 has a deadline 34. Job 17 must finish before the start time of 18. The job 11 has an importance of 3, must be executed by device 4, need 15 timesteps to be performed. Job 12 is not allowed to start before the end time of 11. The job 13 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 2, need 4 timesteps to be performed. The job 16 has an importance of 1, must be executed by device 2, need 7 timesteps to be performed. The job 12 has a deadline 10, has an importance of 1, must be executed by device 5, need 5 timesteps to be performed. Job 17 should begin only after the end time of 16. The job 30 has a deadline 24. The job 3 has a deadline 40.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2634027973209206015", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 15 has a deadline 34, has an importance of 2, must be executed by device 5, need 13 timesteps to be performed. The greatest possible value for the numerical quantities is one thousand, five hundred and forty-seven. The job 14 has an importance of 2, must be executed by device 4, need 18 timesteps to be performed. The job 11 start time in the schedule is 84, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 4, need 9 timesteps to be performed. The job 21 has a deadline 32. The job 30 has a deadline 17. The completion time of job 13 must occur before the start time of 14. The job 17 start time in the schedule is 65, is scheduled to run on device instance 1. The job 27 has a deadline 36. Job 11 must be completed before 12 begins. Time is on 44. Job 17 should begin only after the end time of 16. Job 19 must finish before the start time of 20. The job 16 start time in the schedule is 56, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 9 timesteps to be performed. The total penalty of the schedule must be less than or equal to 1333. Job 14 must finish before the start time of 15. The start time of 11 must be after the end time of 10. The job 13 has an importance of 3, must be executed by device 2, need 11 timesteps to be performed. The end time of job 1 must precede the start time of 2. The job 18 start time in the schedule is 86, is scheduled to run on device instance 1, has a deadline 39. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 3 has a deadline 27. The job 12 start time in the schedule is 99, is scheduled to run on device instance 1, has a deadline 30, has an importance of 1, must be executed by device 5, need 8 timesteps to be performed. The job 19 start time in the schedule is 8, is scheduled to run on device instance 1. Instance three on the device 1 is down. The job 24 has a deadline 24. The job 10 start time in the schedule is 65, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 4 timesteps to be performed. Job 17 must finish before the start time of 18. The job 1 start time in the schedule is 0, is scheduled to run on device instance 2, has an importance of 1, must be executed by device 1, need 10 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(1, 0). curr_on_instance(1, 2). importance(1, 1). job_device(1, 1). job_len(1, 10). job(1). curr_job_start(10, 65). curr_on_instance(10, 1). importance(10, 3). job_device(10, 2). job_len(10, 4). job(10). curr_job_start(11, 84). curr_on_instance(11, 1). importance(11, 2). job_device(11, 4). job_len(11, 9). job(11). curr_job_start(12, 99). curr_on_instance(12, 1). deadline(12, 30). importance(12, 1). job_device(12, 5). job_len(12, 8). job(12). curr_job_start(16, 56). curr_on_instance(16, 1). importance(16, 3). job_device(16, 2). job_len(16, 9). job(16). curr_job_start(17, 65). curr_on_instance(17, 1). job(17). curr_job_start(18, 86). curr_on_instance(18, 1). deadline(18, 39). job(18). curr_job_start(19, 8). curr_on_instance(19, 1). job(19). deadline(15, 34). importance(15, 2). job_device(15, 5). job_len(15, 13). job(15). deadline(21, 32). job(21). deadline(24, 24). job(24). deadline(27, 36). job(27). deadline(3, 27). job(3). deadline(30, 17). job(30). importance(13, 3). job_device(13, 2). job_len(13, 11). job(13). importance(14, 2). job_device(14, 4). job_len(14, 18). job(14). curr_time(44). max_total_penalty(1333). max_value(1547). offline_instance(3,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 15 has a deadline 34, has an importance of 2, must be executed by device 5, need 13 timesteps to be performed. The greatest possible value for the numerical quantities is one thousand, five hundred and forty-seven. The job 14 has an importance of 2, must be executed by device 4, need 18 timesteps to be performed. The job 11 start time in the schedule is 84, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 4, need 9 timesteps to be performed. The job 21 has a deadline 32. The job 30 has a deadline 17. The completion time of job 13 must occur before the start time of 14. The job 17 start time in the schedule is 65, is scheduled to run on device instance 1. The job 27 has a deadline 36. Job 11 must be completed before 12 begins. Time is on 44. Job 17 should begin only after the end time of 16. Job 19 must finish before the start time of 20. The job 16 start time in the schedule is 56, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 9 timesteps to be performed. The total penalty of the schedule must be less than or equal to 1333. Job 14 must finish before the start time of 15. The start time of 11 must be after the end time of 10. The job 13 has an importance of 3, must be executed by device 2, need 11 timesteps to be performed. The end time of job 1 must precede the start time of 2. The job 18 start time in the schedule is 86, is scheduled to run on device instance 1, has a deadline 39. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 3 has a deadline 27. The job 12 start time in the schedule is 99, is scheduled to run on device instance 1, has a deadline 30, has an importance of 1, must be executed by device 5, need 8 timesteps to be performed. The job 19 start time in the schedule is 8, is scheduled to run on device instance 1. Instance three on the device 1 is down. The job 24 has a deadline 24. The job 10 start time in the schedule is 65, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 4 timesteps to be performed. Job 17 must finish before the start time of 18. The job 1 start time in the schedule is 0, is scheduled to run on device instance 2, has an importance of 1, must be executed by device 1, need 10 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7216901815058373578", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 11 start time in the schedule is 8, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 3, need 8 timesteps to be performed. Job 13 must be completed before 14 begins. The job 20 start time in the schedule is 8, is scheduled to run on device instance 2. Job 10 must be completed before 11 begins. The job 15 has a deadline 31, has an importance of 2, must be executed by device 5, need 15 timesteps to be performed. Time is on 5. The job 14 has an importance of 3, must be executed by device 3, need 7 timesteps to be performed. The job 3 has a deadline 15. The job 10 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 8 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 1, need 8 timesteps to be performed. The job 22 start time in the schedule is 0, is scheduled to run on device instance 2. Job 19 must be completed before 20 begins. The job 13 has an importance of 1, must be executed by device 1, need 10 timesteps to be performed. Job 12 is not allowed to start before the end time of 11. The end time of job 17 must precede the start time of 18. The job 12 start time in the schedule is 16, is scheduled to run on device instance 1, has a deadline 30, has an importance of 3, must be executed by device 5, need 11 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 24 has a deadline 33. The job 19 start time in the schedule is 0, is scheduled to run on device instance 1. Job 1 must be completed before 2 begins. Job 17 should begin only after the end time of 16. The job 18 has a deadline 28. The total penalty for the schedule cannot be greater than 1201. The numerical quantities cannot exceed one thousand, three hundred and seventy-two. The job 21 start time in the schedule is 27, is scheduled to run on device instance 1, has a deadline 17. The job 30 has a deadline 14. The job 27 has a deadline 36. The job 16 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. The job 23 start time in the schedule is 14, is scheduled to run on device instance 2. Job 15 should begin only after the end time of 14.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(10, 0). curr_on_instance(10, 1). importance(10, 3). job_device(10, 2). job_len(10, 8). job(10). curr_job_start(11, 8). curr_on_instance(11, 1). importance(11, 3). job_device(11, 3). job_len(11, 8). job(11). curr_job_start(12, 16). curr_on_instance(12, 1). deadline(12, 30). importance(12, 3). job_device(12, 5). job_len(12, 11). job(12). curr_job_start(19, 0). curr_on_instance(19, 1). job(19). curr_job_start(20, 8). curr_on_instance(20, 2). job(20). curr_job_start(21, 27). curr_on_instance(21, 1). deadline(21, 17). job(21). curr_job_start(22, 0). curr_on_instance(22, 2). job(22). curr_job_start(23, 14). curr_on_instance(23, 2). job(23). deadline(15, 31). importance(15, 2). job_device(15, 5). job_len(15, 15). job(15). deadline(18, 28). job(18). deadline(24, 33). job(24). deadline(27, 36). job(27). deadline(3, 15). job(3). deadline(30, 14). job(30). importance(1, 2). job_device(1, 1). job_len(1, 8). job(1). importance(13, 1). job_device(13, 1). job_len(13, 10). job(13). importance(14, 3). job_device(14, 3). job_len(14, 7). job(14). importance(16, 1). job_device(16, 2). job_len(16, 15). job(16). curr_time(5). max_total_penalty(1201). max_value(1372). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 11 start time in the schedule is 8, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 3, need 8 timesteps to be performed. Job 13 must be completed before 14 begins. The job 20 start time in the schedule is 8, is scheduled to run on device instance 2. Job 10 must be completed before 11 begins. The job 15 has a deadline 31, has an importance of 2, must be executed by device 5, need 15 timesteps to be performed. Time is on 5. The job 14 has an importance of 3, must be executed by device 3, need 7 timesteps to be performed. The job 3 has a deadline 15. The job 10 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 8 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 1, need 8 timesteps to be performed. The job 22 start time in the schedule is 0, is scheduled to run on device instance 2. Job 19 must be completed before 20 begins. The job 13 has an importance of 1, must be executed by device 1, need 10 timesteps to be performed. Job 12 is not allowed to start before the end time of 11. The end time of job 17 must precede the start time of 18. The job 12 start time in the schedule is 16, is scheduled to run on device instance 1, has a deadline 30, has an importance of 3, must be executed by device 5, need 11 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 24 has a deadline 33. The job 19 start time in the schedule is 0, is scheduled to run on device instance 1. Job 1 must be completed before 2 begins. Job 17 should begin only after the end time of 16. The job 18 has a deadline 28. The total penalty for the schedule cannot be greater than 1201. The numerical quantities cannot exceed one thousand, three hundred and seventy-two. The job 21 start time in the schedule is 27, is scheduled to run on device instance 1, has a deadline 17. The job 30 has a deadline 14. The job 27 has a deadline 36. The job 16 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. The job 23 start time in the schedule is 14, is scheduled to run on device instance 2. Job 15 should begin only after the end time of 14.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4960826996249737896", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The present time is 87. The greatest possible value for the numerical quantities is three thousand, one hundred and twenty-eight. Job 14 should begin only after the end time of 13. The job 28 start time in the schedule is 28, is scheduled to run on device instance 1. The job 18 has a deadline 30. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 19 must finish before the start time of 20. The job 11 has an importance of 1, must be executed by device 3, need 13 timesteps to be performed. The job 3 has a deadline 36. Job 12 is not allowed to start before the end time of 11. The job 13 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. The job 14 has an importance of 2, must be executed by device 4, need 5 timesteps to be performed. The job 10 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. The job 24 start time in the schedule is 117, is scheduled to run on device instance 1, has a deadline 39. The job 22 start time in the schedule is 15, is scheduled to run on device instance 2. Job 16 must be completed before 17 begins. The job 26 start time in the schedule is 15, is scheduled to run on device instance 2. Job 17 should end before 18 starts. The job 25 start time in the schedule is 5, is scheduled to run on device instance 2. The job 27 start time in the schedule is 105, is scheduled to run on device instance 1, has a deadline 28. The job 1 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. The job 30 has a deadline 36. Job 1 must finish before the start time of 2. The job 21 has a deadline 18. Job 14 should end before 15 starts. The job 29 start time in the schedule is 35, is scheduled to run on device instance 2. The start time of 11 must be after the end time of 10. The schedule's total penalty must not exceed 2812. The job 23 start time in the schedule is 40, is scheduled to run on device instance 1. Instance five on device 1 is currently offline. The job 16 has an importance of 3, must be executed by device 2, need 12 timesteps to be performed. The job 15 has a deadline 37, has an importance of 3, must be executed by device 5, need 13 timesteps to be performed. The job 12 has a deadline 16, has an importance of 2, must be executed by device 5, need 17 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(22, 15). curr_on_instance(22, 2). job(22). curr_job_start(23, 40). curr_on_instance(23, 1). job(23). curr_job_start(24, 117). curr_on_instance(24, 1). deadline(24, 39). job(24). curr_job_start(25, 5). curr_on_instance(25, 2). job(25). curr_job_start(26, 15). curr_on_instance(26, 2). job(26). curr_job_start(27, 105). curr_on_instance(27, 1). deadline(27, 28). job(27). curr_job_start(28, 28). curr_on_instance(28, 1). job(28). curr_job_start(29, 35). curr_on_instance(29, 2). job(29). deadline(12, 16). importance(12, 2). job_device(12, 5). job_len(12, 17). job(12). deadline(15, 37). importance(15, 3). job_device(15, 5). job_len(15, 13). job(15). deadline(18, 30). job(18). deadline(21, 18). job(21). deadline(3, 36). job(3). deadline(30, 36). job(30). importance(1, 1). job_device(1, 1). job_len(1, 13). job(1). importance(10, 1). job_device(10, 1). job_len(10, 13). job(10). importance(11, 1). job_device(11, 3). job_len(11, 13). job(11). importance(13, 2). job_device(13, 1). job_len(13, 14). job(13). importance(14, 2). job_device(14, 4). job_len(14, 5). job(14). importance(16, 3). job_device(16, 2). job_len(16, 12). job(16). curr_time(87). max_total_penalty(2812). max_value(3128). offline_instance(5,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The present time is 87. The greatest possible value for the numerical quantities is three thousand, one hundred and twenty-eight. Job 14 should begin only after the end time of 13. The job 28 start time in the schedule is 28, is scheduled to run on device instance 1. The job 18 has a deadline 30. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 19 must finish before the start time of 20. The job 11 has an importance of 1, must be executed by device 3, need 13 timesteps to be performed. The job 3 has a deadline 36. Job 12 is not allowed to start before the end time of 11. The job 13 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. The job 14 has an importance of 2, must be executed by device 4, need 5 timesteps to be performed. The job 10 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. The job 24 start time in the schedule is 117, is scheduled to run on device instance 1, has a deadline 39. The job 22 start time in the schedule is 15, is scheduled to run on device instance 2. Job 16 must be completed before 17 begins. The job 26 start time in the schedule is 15, is scheduled to run on device instance 2. Job 17 should end before 18 starts. The job 25 start time in the schedule is 5, is scheduled to run on device instance 2. The job 27 start time in the schedule is 105, is scheduled to run on device instance 1, has a deadline 28. The job 1 has an importance of 1, must be executed by device 1, need 13 timesteps to be performed. The job 30 has a deadline 36. Job 1 must finish before the start time of 2. The job 21 has a deadline 18. Job 14 should end before 15 starts. The job 29 start time in the schedule is 35, is scheduled to run on device instance 2. The start time of 11 must be after the end time of 10. The schedule's total penalty must not exceed 2812. The job 23 start time in the schedule is 40, is scheduled to run on device instance 1. Instance five on device 1 is currently offline. The job 16 has an importance of 3, must be executed by device 2, need 12 timesteps to be performed. The job 15 has a deadline 37, has an importance of 3, must be executed by device 5, need 13 timesteps to be performed. The job 12 has a deadline 16, has an importance of 2, must be executed by device 5, need 17 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6379000257427238958", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The end time of job 16 must precede the start time of 17. The end time of job 1 must precede the start time of 2. Job 11 must be completed before 12 begins. The job 13 has an importance of 2, must be executed by device 1, need 4 timesteps to be performed. The job 15 has a deadline 40, has an importance of 3, must be executed by device 5, need 20 timesteps to be performed. The job 18 has a deadline 30. The job 30 has a deadline 35. Time is on 0. The job 3 has a deadline 16. The job 14 has an importance of 2, must be executed by device 3, need 7 timesteps to be performed. The job 21 has a deadline 13. The schedule's total penalty must not exceed 1302. The job 12 has a deadline 35, has an importance of 2, must be executed by device 5, need 14 timesteps to be performed. Job 15 should begin only after the end time of 14. The job 10 has an importance of 3, must be executed by device 1, need 10 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 18 timesteps to be performed. Job 19 should end before 20 starts. The job 24 has a deadline 11. Job 10 must finish before the start time of 11. The numerical quantities can have a maximum value of one thousand, three hundred and twenty. The job 1 has an importance of 3, must be executed by device 1, need 18 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 16 has an importance of 2, must be executed by device 2, need 8 timesteps to be performed. Job 13 should end before 14 starts. The job 27 has a deadline 37. Job 18 is not allowed to start before the end time of 17.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 35). importance(12, 2). job_device(12, 5). job_len(12, 14). job(12). deadline(15, 40). importance(15, 3). job_device(15, 5). job_len(15, 20). job(15). deadline(18, 30). job(18). deadline(21, 13). job(21). deadline(24, 11). job(24). deadline(27, 37). job(27). deadline(3, 16). job(3). deadline(30, 35). job(30). importance(1, 3). job_device(1, 1). job_len(1, 18). job(1). importance(10, 3). job_device(10, 1). job_len(10, 10). job(10). importance(11, 3). job_device(11, 3). job_len(11, 18). job(11). importance(13, 2). job_device(13, 1). job_len(13, 4). job(13). importance(14, 2). job_device(14, 3). job_len(14, 7). job(14). importance(16, 2). job_device(16, 2). job_len(16, 8). job(16). curr_time(0). max_total_penalty(1302). max_value(1320). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The end time of job 16 must precede the start time of 17. The end time of job 1 must precede the start time of 2. Job 11 must be completed before 12 begins. The job 13 has an importance of 2, must be executed by device 1, need 4 timesteps to be performed. The job 15 has a deadline 40, has an importance of 3, must be executed by device 5, need 20 timesteps to be performed. The job 18 has a deadline 30. The job 30 has a deadline 35. Time is on 0. The job 3 has a deadline 16. The job 14 has an importance of 2, must be executed by device 3, need 7 timesteps to be performed. The job 21 has a deadline 13. The schedule's total penalty must not exceed 1302. The job 12 has a deadline 35, has an importance of 2, must be executed by device 5, need 14 timesteps to be performed. Job 15 should begin only after the end time of 14. The job 10 has an importance of 3, must be executed by device 1, need 10 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 18 timesteps to be performed. Job 19 should end before 20 starts. The job 24 has a deadline 11. Job 10 must finish before the start time of 11. The numerical quantities can have a maximum value of one thousand, three hundred and twenty. The job 1 has an importance of 3, must be executed by device 1, need 18 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 16 has an importance of 2, must be executed by device 2, need 8 timesteps to be performed. Job 13 should end before 14 starts. The job 27 has a deadline 37. Job 18 is not allowed to start before the end time of 17.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5479657898226312313", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The end time of job 1 must precede the start time of 2. The job 13 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. The highest possible value for the numerical quantities is one thousand, four hundred and forty. The job 24 has a deadline 17. Job 14 should begin only after the end time of 13. The job 15 has a deadline 15, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 16 must be completed before 17 begins. The job 30 has a deadline 16. The end time of job 10 must precede the start time of 11. The schedule's total penalty must be at most 1304. The job 27 has a deadline 37. The present time is 0. Job 15 should begin only after the end time of 14. The job 21 has a deadline 37. The job 18 has a deadline 29. The job 10 has an importance of 3, must be executed by device 2, need 10 timesteps to be performed. The job 11 has an importance of 1, must be executed by device 4, need 9 timesteps to be performed. The job 1 has an importance of 1, must be executed by device 1, need 7 timesteps to be performed. The completion time of job 11 must occur before the start time of 12. The completion time of job 19 must occur before the start time of 20. The end time of job 17 must precede the start time of 18. The job 12 has a deadline 25, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. The job 14 has an importance of 1, must be executed by device 3, need 17 timesteps to be performed. The job 3 has a deadline 37. The job 16 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 25). importance(12, 3). job_device(12, 5). job_len(12, 5). job(12). deadline(15, 15). importance(15, 3). job_device(15, 5). job_len(15, 8). job(15). deadline(18, 29). job(18). deadline(21, 37). job(21). deadline(24, 17). job(24). deadline(27, 37). job(27). deadline(3, 37). job(3). deadline(30, 16). job(30). importance(1, 1). job_device(1, 1). job_len(1, 7). job(1). importance(10, 3). job_device(10, 2). job_len(10, 10). job(10). importance(11, 1). job_device(11, 4). job_len(11, 9). job(11). importance(13, 3). job_device(13, 1). job_len(13, 15). job(13). importance(14, 1). job_device(14, 3). job_len(14, 17). job(14). importance(16, 3). job_device(16, 1). job_len(16, 15). job(16). curr_time(0). max_total_penalty(1304). max_value(1440). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The end time of job 1 must precede the start time of 2. The job 13 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. The highest possible value for the numerical quantities is one thousand, four hundred and forty. The job 24 has a deadline 17. Job 14 should begin only after the end time of 13. The job 15 has a deadline 15, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 16 must be completed before 17 begins. The job 30 has a deadline 16. The end time of job 10 must precede the start time of 11. The schedule's total penalty must be at most 1304. The job 27 has a deadline 37. The present time is 0. Job 15 should begin only after the end time of 14. The job 21 has a deadline 37. The job 18 has a deadline 29. The job 10 has an importance of 3, must be executed by device 2, need 10 timesteps to be performed. The job 11 has an importance of 1, must be executed by device 4, need 9 timesteps to be performed. The job 1 has an importance of 1, must be executed by device 1, need 7 timesteps to be performed. The completion time of job 11 must occur before the start time of 12. The completion time of job 19 must occur before the start time of 20. The end time of job 17 must precede the start time of 18. The job 12 has a deadline 25, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. The job 14 has an importance of 1, must be executed by device 3, need 17 timesteps to be performed. The job 3 has a deadline 37. The job 16 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5382431017043771391", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 18 has a deadline 36. The current time is 0. The job 16 has an importance of 2, must be executed by device 1, need 6 timesteps to be performed. Device 1 is showing instance five as offline. The job 13 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 21 has a deadline 37. The job 27 has a deadline 23. Job 11 must be completed before 12 begins. The job 1 has an importance of 3, must be executed by device 1, need 16 timesteps to be performed. The completion time of job 13 must occur before the start time of 14. The completion time of job 10 must occur before the start time of 11. The end time of job 16 must precede the start time of 17. The end time of job 17 must precede the start time of 18. The highest possible value for the numerical quantities is one thousand, four hundred and forty. The job 3 has a deadline 32. The job 11 has an importance of 2, must be executed by device 3, need 8 timesteps to be performed. The job 15 has a deadline 13, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. The completion time of job 1 must occur before the start time of 2. Job 15 should begin only after the end time of 14. The job 14 has an importance of 1, must be executed by device 3, need 19 timesteps to be performed. Job 19 should end before 20 starts. The total penalty of the schedule must be less than or equal to 1369. The job 30 has a deadline 38. The job 24 has a deadline 20. The job 12 has a deadline 22, has an importance of 1, must be executed by device 5, need 7 timesteps to be performed. The job 10 has an importance of 2, must be executed by device 2, need 5 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 22). importance(12, 1). job_device(12, 5). job_len(12, 7). job(12). deadline(15, 13). importance(15, 3). job_device(15, 5). job_len(15, 5). job(15). deadline(18, 36). job(18). deadline(21, 37). job(21). deadline(24, 20). job(24). deadline(27, 23). job(27). deadline(3, 32). job(3). deadline(30, 38). job(30). importance(1, 3). job_device(1, 1). job_len(1, 16). job(1). importance(10, 2). job_device(10, 2). job_len(10, 5). job(10). importance(11, 2). job_device(11, 3). job_len(11, 8). job(11). importance(13, 1). job_device(13, 2). job_len(13, 15). job(13). importance(14, 1). job_device(14, 3). job_len(14, 19). job(14). importance(16, 2). job_device(16, 1). job_len(16, 6). job(16). curr_time(0). max_total_penalty(1369). max_value(1440). offline_instance(5,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 18 has a deadline 36. The current time is 0. The job 16 has an importance of 2, must be executed by device 1, need 6 timesteps to be performed. Device 1 is showing instance five as offline. The job 13 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 21 has a deadline 37. The job 27 has a deadline 23. Job 11 must be completed before 12 begins. The job 1 has an importance of 3, must be executed by device 1, need 16 timesteps to be performed. The completion time of job 13 must occur before the start time of 14. The completion time of job 10 must occur before the start time of 11. The end time of job 16 must precede the start time of 17. The end time of job 17 must precede the start time of 18. The highest possible value for the numerical quantities is one thousand, four hundred and forty. The job 3 has a deadline 32. The job 11 has an importance of 2, must be executed by device 3, need 8 timesteps to be performed. The job 15 has a deadline 13, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. The completion time of job 1 must occur before the start time of 2. Job 15 should begin only after the end time of 14. The job 14 has an importance of 1, must be executed by device 3, need 19 timesteps to be performed. Job 19 should end before 20 starts. The total penalty of the schedule must be less than or equal to 1369. The job 30 has a deadline 38. The job 24 has a deadline 20. The job 12 has a deadline 22, has an importance of 1, must be executed by device 5, need 7 timesteps to be performed. The job 10 has an importance of 2, must be executed by device 2, need 5 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "532139557750627976", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "Job 16 should end before 17 starts. The job 15 has a deadline 34, has an importance of 2, must be executed by device 5, need 19 timesteps to be performed. The job 11 has an importance of 2, must be executed by device 4, need 3 timesteps to be performed. The job 24 has a deadline 22. Instance two on device 1 is currently offline. The job 1 has an importance of 2, must be executed by device 2, need 16 timesteps to be performed. Job 17 must be completed before 18 begins. The present time is 0. The maximum possible value for the numerical quanitities is one thousand, four hundred and forty. The job 12 has a deadline 39, has an importance of 1, must be executed by device 5, need 14 timesteps to be performed. Job 12 should begin only after the end time of 11. The job 3 has a deadline 26. The job 14 has an importance of 3, must be executed by device 4, need 19 timesteps to be performed. The job 13 has an importance of 2, must be executed by device 1, need 8 timesteps to be performed. The job 16 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. Job 2 should begin only after the end time of 1. Job 10 must be completed before 11 begins. Job 13 must finish before the start time of 14. The job 18 has a deadline 32. The job 21 has a deadline 35. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The schedule's total penalty must not exceed 1404. The job 27 has a deadline 34. The job 30 has a deadline 12. Job 19 must finish before the start time of 20. The end time of job 14 must precede the start time of 15. The job 10 has an importance of 2, must be executed by device 1, need 11 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 39). importance(12, 1). job_device(12, 5). job_len(12, 14). job(12). deadline(15, 34). importance(15, 2). job_device(15, 5). job_len(15, 19). job(15). deadline(18, 32). job(18). deadline(21, 35). job(21). deadline(24, 22). job(24). deadline(27, 34). job(27). deadline(3, 26). job(3). deadline(30, 12). job(30). importance(1, 2). job_device(1, 2). job_len(1, 16). job(1). importance(10, 2). job_device(10, 1). job_len(10, 11). job(10). importance(11, 2). job_device(11, 4). job_len(11, 3). job(11). importance(13, 2). job_device(13, 1). job_len(13, 8). job(13). importance(14, 3). job_device(14, 4). job_len(14, 19). job(14). importance(16, 1). job_device(16, 1). job_len(16, 12). job(16). curr_time(0). max_total_penalty(1404). max_value(1440). offline_instance(2,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```Job 16 should end before 17 starts. The job 15 has a deadline 34, has an importance of 2, must be executed by device 5, need 19 timesteps to be performed. The job 11 has an importance of 2, must be executed by device 4, need 3 timesteps to be performed. The job 24 has a deadline 22. Instance two on device 1 is currently offline. The job 1 has an importance of 2, must be executed by device 2, need 16 timesteps to be performed. Job 17 must be completed before 18 begins. The present time is 0. The maximum possible value for the numerical quanitities is one thousand, four hundred and forty. The job 12 has a deadline 39, has an importance of 1, must be executed by device 5, need 14 timesteps to be performed. Job 12 should begin only after the end time of 11. The job 3 has a deadline 26. The job 14 has an importance of 3, must be executed by device 4, need 19 timesteps to be performed. The job 13 has an importance of 2, must be executed by device 1, need 8 timesteps to be performed. The job 16 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. Job 2 should begin only after the end time of 1. Job 10 must be completed before 11 begins. Job 13 must finish before the start time of 14. The job 18 has a deadline 32. The job 21 has a deadline 35. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The schedule's total penalty must not exceed 1404. The job 27 has a deadline 34. The job 30 has a deadline 12. Job 19 must finish before the start time of 20. The end time of job 14 must precede the start time of 15. The job 10 has an importance of 2, must be executed by device 1, need 11 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1704904247378558841", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The schedule's total penalty must be at most 1781. The greatest possible value for the numerical quantities is one thousand, eight hundred. The start time of 17 must be after the end time of 16. The job 30 has a deadline 34. The job 16 has an importance of 3, must be executed by device 2, need 3 timesteps to be performed. The start time of 14 must be after the end time of 13. The job 13 has an importance of 3, must be executed by device 1, need 20 timesteps to be performed. The job 3 has a deadline 18. The end time of job 19 must precede the start time of 20. The job 24 has a deadline 27. The current time is 0. Job 12 is not allowed to start before the end time of 11. The job 21 has a deadline 35. The job 1 has an importance of 3, must be executed by device 2, need 14 timesteps to be performed. The job 27 has a deadline 15. The job 18 has a deadline 20. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 17 must be completed before 18 begins. Job 10 should end before 11 starts. The job 11 has an importance of 1, must be executed by device 3, need 16 timesteps to be performed. The job 15 has a deadline 35, has an importance of 2, must be executed by device 5, need 19 timesteps to be performed. The job 12 has a deadline 37, has an importance of 1, must be executed by device 5, need 13 timesteps to be performed. Job 14 must be completed before 15 begins. The job 10 has an importance of 3, must be executed by device 1, need 5 timesteps to be performed. The job 14 has an importance of 2, must be executed by device 4, need 5 timesteps to be performed. The end time of job 1 must precede the start time of 2.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 37). importance(12, 1). job_device(12, 5). job_len(12, 13). job(12). deadline(15, 35). importance(15, 2). job_device(15, 5). job_len(15, 19). job(15). deadline(18, 20). job(18). deadline(21, 35). job(21). deadline(24, 27). job(24). deadline(27, 15). job(27). deadline(3, 18). job(3). deadline(30, 34). job(30). importance(1, 3). job_device(1, 2). job_len(1, 14). job(1). importance(10, 3). job_device(10, 1). job_len(10, 5). job(10). importance(11, 1). job_device(11, 3). job_len(11, 16). job(11). importance(13, 3). job_device(13, 1). job_len(13, 20). job(13). importance(14, 2). job_device(14, 4). job_len(14, 5). job(14). importance(16, 3). job_device(16, 2). job_len(16, 3). job(16). curr_time(0). max_total_penalty(1781). max_value(1800). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The schedule's total penalty must be at most 1781. The greatest possible value for the numerical quantities is one thousand, eight hundred. The start time of 17 must be after the end time of 16. The job 30 has a deadline 34. The job 16 has an importance of 3, must be executed by device 2, need 3 timesteps to be performed. The start time of 14 must be after the end time of 13. The job 13 has an importance of 3, must be executed by device 1, need 20 timesteps to be performed. The job 3 has a deadline 18. The end time of job 19 must precede the start time of 20. The job 24 has a deadline 27. The current time is 0. Job 12 is not allowed to start before the end time of 11. The job 21 has a deadline 35. The job 1 has an importance of 3, must be executed by device 2, need 14 timesteps to be performed. The job 27 has a deadline 15. The job 18 has a deadline 20. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 17 must be completed before 18 begins. Job 10 should end before 11 starts. The job 11 has an importance of 1, must be executed by device 3, need 16 timesteps to be performed. The job 15 has a deadline 35, has an importance of 2, must be executed by device 5, need 19 timesteps to be performed. The job 12 has a deadline 37, has an importance of 1, must be executed by device 5, need 13 timesteps to be performed. Job 14 must be completed before 15 begins. The job 10 has an importance of 3, must be executed by device 1, need 5 timesteps to be performed. The job 14 has an importance of 2, must be executed by device 4, need 5 timesteps to be performed. The end time of job 1 must precede the start time of 2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8986505005725222920", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 13 has an importance of 2, must be executed by device 1, need 19 timesteps to be performed. The job 3 has a deadline 15. Job 14 is not allowed to start before the end time of 13. The job 1 has an importance of 2, must be executed by device 1, need 15 timesteps to be performed. Job 19 must be completed before 20 begins. The job 10 has an importance of 2, must be executed by device 2, need 12 timesteps to be performed. Job 17 must be completed before 18 begins. Job 2 should begin only after the end time of 1. Job 15 is not allowed to start before the end time of 14. The completion time of job 10 must occur before the start time of 11. The current time is 0. The job 16 has an importance of 1, must be executed by device 2, need 10 timesteps to be performed. Job 17 should begin only after the end time of 16. The job 27 has a deadline 36. The job 24 has a deadline 20. The job 14 has an importance of 3, must be executed by device 3, need 8 timesteps to be performed. Job 11 must finish before the start time of 12. The job 11 has an importance of 2, must be executed by device 3, need 18 timesteps to be performed. The total penalty of the schedule must be less than or equal to 1339. The job 30 has a deadline 24. The job 21 has a deadline 29. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Instance number two from device 1 is offline. The job 12 has a deadline 26, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed. The maximum possible value for the numerical quanitities is one thousand, four hundred and forty. The job 18 has a deadline 25. The job 15 has a deadline 34, has an importance of 1, must be executed by device 5, need 16 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 26). importance(12, 3). job_device(12, 5). job_len(12, 8). job(12). deadline(15, 34). importance(15, 1). job_device(15, 5). job_len(15, 16). job(15). deadline(18, 25). job(18). deadline(21, 29). job(21). deadline(24, 20). job(24). deadline(27, 36). job(27). deadline(3, 15). job(3). deadline(30, 24). job(30). importance(1, 2). job_device(1, 1). job_len(1, 15). job(1). importance(10, 2). job_device(10, 2). job_len(10, 12). job(10). importance(11, 2). job_device(11, 3). job_len(11, 18). job(11). importance(13, 2). job_device(13, 1). job_len(13, 19). job(13). importance(14, 3). job_device(14, 3). job_len(14, 8). job(14). importance(16, 1). job_device(16, 2). job_len(16, 10). job(16). curr_time(0). max_total_penalty(1339). max_value(1440). offline_instance(2,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 13 has an importance of 2, must be executed by device 1, need 19 timesteps to be performed. The job 3 has a deadline 15. Job 14 is not allowed to start before the end time of 13. The job 1 has an importance of 2, must be executed by device 1, need 15 timesteps to be performed. Job 19 must be completed before 20 begins. The job 10 has an importance of 2, must be executed by device 2, need 12 timesteps to be performed. Job 17 must be completed before 18 begins. Job 2 should begin only after the end time of 1. Job 15 is not allowed to start before the end time of 14. The completion time of job 10 must occur before the start time of 11. The current time is 0. The job 16 has an importance of 1, must be executed by device 2, need 10 timesteps to be performed. Job 17 should begin only after the end time of 16. The job 27 has a deadline 36. The job 24 has a deadline 20. The job 14 has an importance of 3, must be executed by device 3, need 8 timesteps to be performed. Job 11 must finish before the start time of 12. The job 11 has an importance of 2, must be executed by device 3, need 18 timesteps to be performed. The total penalty of the schedule must be less than or equal to 1339. The job 30 has a deadline 24. The job 21 has a deadline 29. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Instance number two from device 1 is offline. The job 12 has a deadline 26, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed. The maximum possible value for the numerical quanitities is one thousand, four hundred and forty. The job 18 has a deadline 25. The job 15 has a deadline 34, has an importance of 1, must be executed by device 5, need 16 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2997798139348547874", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 10 has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. Instance three from device 2 has gone offline. The completion time of job 1 must occur before the start time of 2. The job 3 has a deadline 31. The job 24 has a deadline 25. Instance number five from device 1 is offline. The job 1 has an importance of 3, must be executed by device 1, need 6 timesteps to be performed. The job 20 start time in the schedule is 14, is scheduled to run on device instance 1. The job 13 has an importance of 2, must be executed by device 1, need 12 timesteps to be performed. Job 19 should end before 20 starts. The job 17 start time in the schedule is 8, is scheduled to run on device instance 1. The job 29 start time in the schedule is 33, is scheduled to run on device instance 1. The job 12 has a deadline 18, has an importance of 2, must be executed by device 5, need 6 timesteps to be performed. The numerical quantities cannot exceed one thousand, two hundred and sixty-nine. Job 13 must finish before the start time of 14. The job 14 has an importance of 3, must be executed by device 4, need 10 timesteps to be performed. The job 15 has a deadline 30, has an importance of 1, must be executed by device 5, need 4 timesteps to be performed. The start time of 15 must be after the end time of 14. The end time of job 11 must precede the start time of 12. The job 16 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 8 timesteps to be performed. The end time of job 10 must precede the start time of 11. The job 28 start time in the schedule is 8, is scheduled to run on device instance 1. The present time is 0. The job 11 has an importance of 1, must be executed by device 3, need 6 timesteps to be performed. The job 30 has a deadline 25. The job 18 start time in the schedule is 14, is scheduled to run on device instance 1, has a deadline 12. The schedule's total penalty must be at most 1158. Job 17 must be completed before 18 begins. The job 19 start time in the schedule is 0, is scheduled to run on device instance 1. The job 21 start time in the schedule is 33, is scheduled to run on device instance 1, has a deadline 37. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The completion time of job 16 must occur before the start time of 17. The job 27 has a deadline 17.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(16, 0). curr_on_instance(16, 1). importance(16, 3). job_device(16, 2). job_len(16, 8). job(16). curr_job_start(17, 8). curr_on_instance(17, 1). job(17). curr_job_start(18, 14). curr_on_instance(18, 1). deadline(18, 12). job(18). curr_job_start(19, 0). curr_on_instance(19, 1). job(19). curr_job_start(20, 14). curr_on_instance(20, 1). job(20). curr_job_start(21, 33). curr_on_instance(21, 1). deadline(21, 37). job(21). curr_job_start(28, 8). curr_on_instance(28, 1). job(28). curr_job_start(29, 33). curr_on_instance(29, 1). job(29). deadline(12, 18). importance(12, 2). job_device(12, 5). job_len(12, 6). job(12). deadline(15, 30). importance(15, 1). job_device(15, 5). job_len(15, 4). job(15). deadline(24, 25). job(24). deadline(27, 17). job(27). deadline(3, 31). job(3). deadline(30, 25). job(30). importance(1, 3). job_device(1, 1). job_len(1, 6). job(1). importance(10, 2). job_device(10, 1). job_len(10, 3). job(10). importance(11, 1). job_device(11, 3). job_len(11, 6). job(11). importance(13, 2). job_device(13, 1). job_len(13, 12). job(13). importance(14, 3). job_device(14, 4). job_len(14, 10). job(14). curr_time(0). max_total_penalty(1158). max_value(1269). offline_instance(3,2). offline_instance(5,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 10 has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. Instance three from device 2 has gone offline. The completion time of job 1 must occur before the start time of 2. The job 3 has a deadline 31. The job 24 has a deadline 25. Instance number five from device 1 is offline. The job 1 has an importance of 3, must be executed by device 1, need 6 timesteps to be performed. The job 20 start time in the schedule is 14, is scheduled to run on device instance 1. The job 13 has an importance of 2, must be executed by device 1, need 12 timesteps to be performed. Job 19 should end before 20 starts. The job 17 start time in the schedule is 8, is scheduled to run on device instance 1. The job 29 start time in the schedule is 33, is scheduled to run on device instance 1. The job 12 has a deadline 18, has an importance of 2, must be executed by device 5, need 6 timesteps to be performed. The numerical quantities cannot exceed one thousand, two hundred and sixty-nine. Job 13 must finish before the start time of 14. The job 14 has an importance of 3, must be executed by device 4, need 10 timesteps to be performed. The job 15 has a deadline 30, has an importance of 1, must be executed by device 5, need 4 timesteps to be performed. The start time of 15 must be after the end time of 14. The end time of job 11 must precede the start time of 12. The job 16 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 8 timesteps to be performed. The end time of job 10 must precede the start time of 11. The job 28 start time in the schedule is 8, is scheduled to run on device instance 1. The present time is 0. The job 11 has an importance of 1, must be executed by device 3, need 6 timesteps to be performed. The job 30 has a deadline 25. The job 18 start time in the schedule is 14, is scheduled to run on device instance 1, has a deadline 12. The schedule's total penalty must be at most 1158. Job 17 must be completed before 18 begins. The job 19 start time in the schedule is 0, is scheduled to run on device instance 1. The job 21 start time in the schedule is 33, is scheduled to run on device instance 1, has a deadline 37. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The completion time of job 16 must occur before the start time of 17. The job 27 has a deadline 17.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4133190531649546075", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "Job 106 must be completed before 107 begins. Job 101 must be completed before 102 begins. The greatest possible value for the numerical quantities is four thousand, eight hundred. The schedule's total penalty must not exceed 4643. The job 105 has a deadline 32, has an importance of 2, must be executed by device 5, need 5 timesteps to be performed. The job 120 has a deadline 20. The job 10 has an importance of 2, must be executed by device 2, need 7 timesteps to be performed. The job 100 has an importance of 1, must be executed by device 2, need 6 timesteps to be performed. The job 108 has a deadline 31. The job 104 has an importance of 3, must be executed by device 3, need 10 timesteps to be performed. The job 101 has an importance of 1, must be executed by device 4, need 15 timesteps to be performed. The job 111 has a deadline 24. The job 114 has a deadline 13. The job 103 has an importance of 2, must be executed by device 1, need 20 timesteps to be performed. The end time of job 1 must precede the start time of 2. The job 117 has a deadline 22. Job 101 is not allowed to start before the end time of 100. The end time of job 107 must precede the start time of 108. The job 102 has a deadline 15, has an importance of 2, must be executed by device 5, need 17 timesteps to be performed. The job 1 has an importance of 1, must be executed by device 1, need 8 timesteps to be performed. The completion time of job 104 must occur before the start time of 105. The job 12 has a deadline 20. Job 10 should end before 11 starts. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 104 is not allowed to start before the end time of 103. Time is on 0.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(102, 15). importance(102, 2). job_device(102, 5). job_len(102, 17). job(102). deadline(105, 32). importance(105, 2). job_device(105, 5). job_len(105, 5). job(105). deadline(108, 31). job(108). deadline(111, 24). job(111). deadline(114, 13). job(114). deadline(117, 22). job(117). deadline(12, 20). job(12). deadline(120, 20). job(120). importance(1, 1). job_device(1, 1). job_len(1, 8). job(1). importance(10, 2). job_device(10, 2). job_len(10, 7). job(10). importance(100, 1). job_device(100, 2). job_len(100, 6). job(100). importance(101, 1). job_device(101, 4). job_len(101, 15). job(101). importance(103, 2). job_device(103, 1). job_len(103, 20). job(103). importance(104, 3). job_device(104, 3). job_len(104, 10). job(104). curr_time(0). max_total_penalty(4643). max_value(4800). precedes(1,2). precedes(10,11). precedes(100,101). precedes(101,102). precedes(103,104). precedes(104,105). precedes(106,107). precedes(107,108).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```Job 106 must be completed before 107 begins. Job 101 must be completed before 102 begins. The greatest possible value for the numerical quantities is four thousand, eight hundred. The schedule's total penalty must not exceed 4643. The job 105 has a deadline 32, has an importance of 2, must be executed by device 5, need 5 timesteps to be performed. The job 120 has a deadline 20. The job 10 has an importance of 2, must be executed by device 2, need 7 timesteps to be performed. The job 100 has an importance of 1, must be executed by device 2, need 6 timesteps to be performed. The job 108 has a deadline 31. The job 104 has an importance of 3, must be executed by device 3, need 10 timesteps to be performed. The job 101 has an importance of 1, must be executed by device 4, need 15 timesteps to be performed. The job 111 has a deadline 24. The job 114 has a deadline 13. The job 103 has an importance of 2, must be executed by device 1, need 20 timesteps to be performed. The end time of job 1 must precede the start time of 2. The job 117 has a deadline 22. Job 101 is not allowed to start before the end time of 100. The end time of job 107 must precede the start time of 108. The job 102 has a deadline 15, has an importance of 2, must be executed by device 5, need 17 timesteps to be performed. The job 1 has an importance of 1, must be executed by device 1, need 8 timesteps to be performed. The completion time of job 104 must occur before the start time of 105. The job 12 has a deadline 20. Job 10 should end before 11 starts. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 104 is not allowed to start before the end time of 103. Time is on 0.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1511052322675277797", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 20 start time in the schedule is 56, is scheduled to run on device instance 1. The job 119 start time in the schedule is 50, is scheduled to run on device instance 1. The job 104 has an importance of 2, must be executed by device 4, need 10 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 2, need 16 timesteps to be performed. The job 116 start time in the schedule is 19, is scheduled to run on device instance 2. Time is on 50. Job 100 must finish before the start time of 101. The job 19 start time in the schedule is 45, is scheduled to run on device instance 1. The job 102 has a deadline 16, has an importance of 2, must be executed by device 5, need 4 timesteps to be performed. The job 117 start time in the schedule is 138, is scheduled to run on device instance 1, has a deadline 40. The job 120 start time in the schedule is 128, is scheduled to run on device instance 1, has a deadline 14. Job 2 should begin only after the end time of 1. The job 108 has a deadline 34. The job 12 has a deadline 25. Job 104 should begin only after the end time of 103. The job 105 has a deadline 27, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. The job 115 start time in the schedule is 0, is scheduled to run on device instance 2. The job 100 has an importance of 2, must be executed by device 2, need 3 timesteps to be performed. Job 105 should begin only after the end time of 104. The start time of 11 must be after the end time of 10. The job 103 has an importance of 2, must be executed by device 2, need 12 timesteps to be performed. Job 107 is not allowed to start before the end time of 106. Job 108 should begin only after the end time of 107. Job 102 should begin only after the end time of 101. The job 114 has a deadline 30. The job 1 has an importance of 2, must be executed by device 2, need 3 timesteps to be performed. The job 101 has an importance of 1, must be executed by device 4, need 10 timesteps to be performed. The total penalty of the schedule must be less than or equal to 4609. The job 118 start time in the schedule is 16, is scheduled to run on device instance 1. The maximum value that the numerical quantities can take is four thousand, nine hundred and forty-four. The job 111 has a deadline 23.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(115, 0). curr_on_instance(115, 2). job(115). curr_job_start(116, 19). curr_on_instance(116, 2). job(116). curr_job_start(117, 138). curr_on_instance(117, 1). deadline(117, 40). job(117). curr_job_start(118, 16). curr_on_instance(118, 1). job(118). curr_job_start(119, 50). curr_on_instance(119, 1). job(119). curr_job_start(120, 128). curr_on_instance(120, 1). deadline(120, 14). job(120). curr_job_start(19, 45). curr_on_instance(19, 1). job(19). curr_job_start(20, 56). curr_on_instance(20, 1). job(20). deadline(102, 16). importance(102, 2). job_device(102, 5). job_len(102, 4). job(102). deadline(105, 27). importance(105, 2). job_device(105, 5). job_len(105, 12). job(105). deadline(108, 34). job(108). deadline(111, 23). job(111). deadline(114, 30). job(114). deadline(12, 25). job(12). importance(1, 2). job_device(1, 2). job_len(1, 3). job(1). importance(10, 3). job_device(10, 2). job_len(10, 16). job(10). importance(100, 2). job_device(100, 2). job_len(100, 3). job(100). importance(101, 1). job_device(101, 4). job_len(101, 10). job(101). importance(103, 2). job_device(103, 2). job_len(103, 12). job(103). importance(104, 2). job_device(104, 4). job_len(104, 10). job(104). curr_time(50). max_total_penalty(4609). max_value(4944). precedes(1,2). precedes(10,11). precedes(100,101). precedes(101,102). precedes(103,104). precedes(104,105). precedes(106,107). precedes(107,108).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 20 start time in the schedule is 56, is scheduled to run on device instance 1. The job 119 start time in the schedule is 50, is scheduled to run on device instance 1. The job 104 has an importance of 2, must be executed by device 4, need 10 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 2, need 16 timesteps to be performed. The job 116 start time in the schedule is 19, is scheduled to run on device instance 2. Time is on 50. Job 100 must finish before the start time of 101. The job 19 start time in the schedule is 45, is scheduled to run on device instance 1. The job 102 has a deadline 16, has an importance of 2, must be executed by device 5, need 4 timesteps to be performed. The job 117 start time in the schedule is 138, is scheduled to run on device instance 1, has a deadline 40. The job 120 start time in the schedule is 128, is scheduled to run on device instance 1, has a deadline 14. Job 2 should begin only after the end time of 1. The job 108 has a deadline 34. The job 12 has a deadline 25. Job 104 should begin only after the end time of 103. The job 105 has a deadline 27, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. The job 115 start time in the schedule is 0, is scheduled to run on device instance 2. The job 100 has an importance of 2, must be executed by device 2, need 3 timesteps to be performed. Job 105 should begin only after the end time of 104. The start time of 11 must be after the end time of 10. The job 103 has an importance of 2, must be executed by device 2, need 12 timesteps to be performed. Job 107 is not allowed to start before the end time of 106. Job 108 should begin only after the end time of 107. Job 102 should begin only after the end time of 101. The job 114 has a deadline 30. The job 1 has an importance of 2, must be executed by device 2, need 3 timesteps to be performed. The job 101 has an importance of 1, must be executed by device 4, need 10 timesteps to be performed. The total penalty of the schedule must be less than or equal to 4609. The job 118 start time in the schedule is 16, is scheduled to run on device instance 1. The maximum value that the numerical quantities can take is four thousand, nine hundred and forty-four. The job 111 has a deadline 23.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7240876973272880265", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 23 start time in the schedule is 42, is scheduled to run on device instance 1. The end time of job 10 must precede the start time of 11. The job 3 has a deadline 10. Instance four on device 1 is currently offline. The greatest possible value for the numerical quantities is one thousand, eight hundred and eighty-four. The job 18 has a deadline 29. The job 12 start time in the schedule is 77, is scheduled to run on device instance 1, has a deadline 21, has an importance of 2, must be executed by device 5, need 7 timesteps to be performed. The job 10 start time in the schedule is 59, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 2, need 9 timesteps to be performed. The job 19 start time in the schedule is 42, is scheduled to run on device instance 1. The job 16 has an importance of 2, must be executed by device 2, need 14 timesteps to be performed. The end time of job 17 must precede the start time of 18. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 20 is not allowed to start before the end time of 19. The job 24 has a deadline 11. The job 27 has a deadline 30. Time is on 58. Job 2 is not allowed to start before the end time of 1. The job 11 start time in the schedule is 68, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 4, need 9 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 1, need 10 timesteps to be performed. The job 14 has an importance of 1, must be executed by device 4, need 11 timesteps to be performed. The total penalty for the schedule cannot be greater than 1687. The job 20 start time in the schedule is 59, is scheduled to run on device instance 1. The job 21 start time in the schedule is 67, is scheduled to run on device instance 1, has a deadline 27. Job 13 must finish before the start time of 14. The job 13 has an importance of 2, must be executed by device 1, need 20 timesteps to be performed. The job 22 start time in the schedule is 22, is scheduled to run on device instance 1. Job 14 must be completed before 15 begins. Job 11 must be completed before 12 begins. The job 30 has a deadline 19. The end time of job 16 must precede the start time of 17. The job 15 has a deadline 31, has an importance of 3, must be executed by device 5, need 10 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(10, 59). curr_on_instance(10, 1). importance(10, 1). job_device(10, 2). job_len(10, 9). job(10). curr_job_start(11, 68). curr_on_instance(11, 1). importance(11, 2). job_device(11, 4). job_len(11, 9). job(11). curr_job_start(12, 77). curr_on_instance(12, 1). deadline(12, 21). importance(12, 2). job_device(12, 5). job_len(12, 7). job(12). curr_job_start(19, 42). curr_on_instance(19, 1). job(19). curr_job_start(20, 59). curr_on_instance(20, 1). job(20). curr_job_start(21, 67). curr_on_instance(21, 1). deadline(21, 27). job(21). curr_job_start(22, 22). curr_on_instance(22, 1). job(22). curr_job_start(23, 42). curr_on_instance(23, 1). job(23). deadline(15, 31). importance(15, 3). job_device(15, 5). job_len(15, 10). job(15). deadline(18, 29). job(18). deadline(24, 11). job(24). deadline(27, 30). job(27). deadline(3, 10). job(3). deadline(30, 19). job(30). importance(1, 2). job_device(1, 1). job_len(1, 10). job(1). importance(13, 2). job_device(13, 1). job_len(13, 20). job(13). importance(14, 1). job_device(14, 4). job_len(14, 11). job(14). importance(16, 2). job_device(16, 2). job_len(16, 14). job(16). curr_time(58). max_total_penalty(1687). max_value(1884). offline_instance(4,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 23 start time in the schedule is 42, is scheduled to run on device instance 1. The end time of job 10 must precede the start time of 11. The job 3 has a deadline 10. Instance four on device 1 is currently offline. The greatest possible value for the numerical quantities is one thousand, eight hundred and eighty-four. The job 18 has a deadline 29. The job 12 start time in the schedule is 77, is scheduled to run on device instance 1, has a deadline 21, has an importance of 2, must be executed by device 5, need 7 timesteps to be performed. The job 10 start time in the schedule is 59, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 2, need 9 timesteps to be performed. The job 19 start time in the schedule is 42, is scheduled to run on device instance 1. The job 16 has an importance of 2, must be executed by device 2, need 14 timesteps to be performed. The end time of job 17 must precede the start time of 18. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 20 is not allowed to start before the end time of 19. The job 24 has a deadline 11. The job 27 has a deadline 30. Time is on 58. Job 2 is not allowed to start before the end time of 1. The job 11 start time in the schedule is 68, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 4, need 9 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 1, need 10 timesteps to be performed. The job 14 has an importance of 1, must be executed by device 4, need 11 timesteps to be performed. The total penalty for the schedule cannot be greater than 1687. The job 20 start time in the schedule is 59, is scheduled to run on device instance 1. The job 21 start time in the schedule is 67, is scheduled to run on device instance 1, has a deadline 27. Job 13 must finish before the start time of 14. The job 13 has an importance of 2, must be executed by device 1, need 20 timesteps to be performed. The job 22 start time in the schedule is 22, is scheduled to run on device instance 1. Job 14 must be completed before 15 begins. Job 11 must be completed before 12 begins. The job 30 has a deadline 19. The end time of job 16 must precede the start time of 17. The job 15 has a deadline 31, has an importance of 3, must be executed by device 5, need 10 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3234482690657759901", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 12 start time in the schedule is 68, is scheduled to run on device instance 1, has a deadline 34, has an importance of 1, must be executed by device 5, need 15 timesteps to be performed. Device 1 has instance one offline. The start time of 18 must be after the end time of 17. The job 14 start time in the schedule is 23, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 4, need 11 timesteps to be performed. The start time of 14 must be after the end time of 13. The present time is 38. The total penalty of the schedule must be less than or equal to 1308. Job 17 should begin only after the end time of 16. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The highest possible value for the numerical quantities is one thousand, five hundred and twenty-three. Job 10 must be completed before 11 begins. The job 21 has a deadline 34. The job 11 start time in the schedule is 11, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 4, need 7 timesteps to be performed. The job 15 start time in the schedule is 61, is scheduled to run on device instance 1, has a deadline 15, has an importance of 3, must be executed by device 5, need 7 timesteps to be performed. The job 30 has a deadline 39. The job 17 start time in the schedule is 21, is scheduled to run on device instance 1. Job 15 should begin only after the end time of 14. The job 24 has a deadline 18. The end time of job 11 must precede the start time of 12. The job 13 start time in the schedule is 3, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 20 timesteps to be performed. The job 16 start time in the schedule is 11, is scheduled to run on device instance 2, has an importance of 2, must be executed by device 1, need 7 timesteps to be performed. Job 2 is not allowed to start before the end time of 1. The job 27 has a deadline 15. The job 1 has an importance of 3, must be executed by device 1, need 4 timesteps to be performed. The job 10 start time in the schedule is 0, is scheduled to run on device instance 2, has an importance of 2, must be executed by device 1, need 11 timesteps to be performed. Job 20 should begin only after the end time of 19. The job 18 has a deadline 37. The job 3 has a deadline 13.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(10, 0). curr_on_instance(10, 2). importance(10, 2). job_device(10, 1). job_len(10, 11). job(10). curr_job_start(11, 11). curr_on_instance(11, 1). importance(11, 1). job_device(11, 4). job_len(11, 7). job(11). curr_job_start(12, 68). curr_on_instance(12, 1). deadline(12, 34). importance(12, 1). job_device(12, 5). job_len(12, 15). job(12). curr_job_start(13, 3). curr_on_instance(13, 1). importance(13, 3). job_device(13, 2). job_len(13, 20). job(13). curr_job_start(14, 23). curr_on_instance(14, 1). importance(14, 2). job_device(14, 4). job_len(14, 11). job(14). curr_job_start(15, 61). curr_on_instance(15, 1). deadline(15, 15). importance(15, 3). job_device(15, 5). job_len(15, 7). job(15). curr_job_start(16, 11). curr_on_instance(16, 2). importance(16, 2). job_device(16, 1). job_len(16, 7). job(16). curr_job_start(17, 21). curr_on_instance(17, 1). job(17). deadline(18, 37). job(18). deadline(21, 34). job(21). deadline(24, 18). job(24). deadline(27, 15). job(27). deadline(3, 13). job(3). deadline(30, 39). job(30). importance(1, 3). job_device(1, 1). job_len(1, 4). job(1). curr_time(38). max_total_penalty(1308). max_value(1523). offline_instance(1,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 12 start time in the schedule is 68, is scheduled to run on device instance 1, has a deadline 34, has an importance of 1, must be executed by device 5, need 15 timesteps to be performed. Device 1 has instance one offline. The start time of 18 must be after the end time of 17. The job 14 start time in the schedule is 23, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 4, need 11 timesteps to be performed. The start time of 14 must be after the end time of 13. The present time is 38. The total penalty of the schedule must be less than or equal to 1308. Job 17 should begin only after the end time of 16. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The highest possible value for the numerical quantities is one thousand, five hundred and twenty-three. Job 10 must be completed before 11 begins. The job 21 has a deadline 34. The job 11 start time in the schedule is 11, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 4, need 7 timesteps to be performed. The job 15 start time in the schedule is 61, is scheduled to run on device instance 1, has a deadline 15, has an importance of 3, must be executed by device 5, need 7 timesteps to be performed. The job 30 has a deadline 39. The job 17 start time in the schedule is 21, is scheduled to run on device instance 1. Job 15 should begin only after the end time of 14. The job 24 has a deadline 18. The end time of job 11 must precede the start time of 12. The job 13 start time in the schedule is 3, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 20 timesteps to be performed. The job 16 start time in the schedule is 11, is scheduled to run on device instance 2, has an importance of 2, must be executed by device 1, need 7 timesteps to be performed. Job 2 is not allowed to start before the end time of 1. The job 27 has a deadline 15. The job 1 has an importance of 3, must be executed by device 1, need 4 timesteps to be performed. The job 10 start time in the schedule is 0, is scheduled to run on device instance 2, has an importance of 2, must be executed by device 1, need 11 timesteps to be performed. Job 20 should begin only after the end time of 19. The job 18 has a deadline 37. The job 3 has a deadline 13.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2681049126456344145", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 27 has a deadline 33. The job 29 start time in the schedule is 13, is scheduled to run on device instance 1. Job 17 is not allowed to start before the end time of 16. The job 15 start time in the schedule is 6, is scheduled to run on device instance 1, has a deadline 23, has an importance of 2, must be executed by device 5, need 20 timesteps to be performed. The job 21 has a deadline 22. The job 30 has a deadline 34. The job 14 start time in the schedule is 3, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 3, need 3 timesteps to be performed. The completion time of job 10 must occur before the start time of 11. Job 15 should begin only after the end time of 14. The job 10 has an importance of 3, must be executed by device 2, need 12 timesteps to be performed. The job 12 has a deadline 27, has an importance of 3, must be executed by device 5, need 19 timesteps to be performed. Job 11 should end before 12 starts. Device 1 has instance one offline. The highest possible value for the numerical quantities is one thousand, two hundred and fifty-one. The job 13 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 3 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 15 timesteps to be performed. The job 23 start time in the schedule is 16, is scheduled to run on device instance 1. Job 14 is not allowed to start before the end time of 13. The job 18 has a deadline 19. The schedule's total penalty must not exceed 1163. The job 16 has an importance of 2, must be executed by device 2, need 6 timesteps to be performed. Job 1 should end before 2 starts. The job 28 start time in the schedule is 3, is scheduled to run on device instance 1. The job 1 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. The job 22 start time in the schedule is 0, is scheduled to run on device instance 1. Job 18 is not allowed to start before the end time of 17. The job 24 start time in the schedule is 29, is scheduled to run on device instance 1, has a deadline 38. The current time is 45. Device 1 has instance four offline. Job 20 should begin only after the end time of 19. The job 3 has a deadline 12.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(13, 0). curr_on_instance(13, 1). importance(13, 3). job_device(13, 2). job_len(13, 3). job(13). curr_job_start(14, 3). curr_on_instance(14, 1). importance(14, 2). job_device(14, 3). job_len(14, 3). job(14). curr_job_start(15, 6). curr_on_instance(15, 1). deadline(15, 23). importance(15, 2). job_device(15, 5). job_len(15, 20). job(15). curr_job_start(22, 0). curr_on_instance(22, 1). job(22). curr_job_start(23, 16). curr_on_instance(23, 1). job(23). curr_job_start(24, 29). curr_on_instance(24, 1). deadline(24, 38). job(24). curr_job_start(28, 3). curr_on_instance(28, 1). job(28). curr_job_start(29, 13). curr_on_instance(29, 1). job(29). deadline(12, 27). importance(12, 3). job_device(12, 5). job_len(12, 19). job(12). deadline(18, 19). job(18). deadline(21, 22). job(21). deadline(27, 33). job(27). deadline(3, 12). job(3). deadline(30, 34). job(30). importance(1, 2). job_device(1, 1). job_len(1, 14). job(1). importance(10, 3). job_device(10, 2). job_len(10, 12). job(10). importance(11, 3). job_device(11, 3). job_len(11, 15). job(11). importance(16, 2). job_device(16, 2). job_len(16, 6). job(16). curr_time(45). max_total_penalty(1163). max_value(1251). offline_instance(1,1). offline_instance(4,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 27 has a deadline 33. The job 29 start time in the schedule is 13, is scheduled to run on device instance 1. Job 17 is not allowed to start before the end time of 16. The job 15 start time in the schedule is 6, is scheduled to run on device instance 1, has a deadline 23, has an importance of 2, must be executed by device 5, need 20 timesteps to be performed. The job 21 has a deadline 22. The job 30 has a deadline 34. The job 14 start time in the schedule is 3, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 3, need 3 timesteps to be performed. The completion time of job 10 must occur before the start time of 11. Job 15 should begin only after the end time of 14. The job 10 has an importance of 3, must be executed by device 2, need 12 timesteps to be performed. The job 12 has a deadline 27, has an importance of 3, must be executed by device 5, need 19 timesteps to be performed. Job 11 should end before 12 starts. Device 1 has instance one offline. The highest possible value for the numerical quantities is one thousand, two hundred and fifty-one. The job 13 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 3 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 15 timesteps to be performed. The job 23 start time in the schedule is 16, is scheduled to run on device instance 1. Job 14 is not allowed to start before the end time of 13. The job 18 has a deadline 19. The schedule's total penalty must not exceed 1163. The job 16 has an importance of 2, must be executed by device 2, need 6 timesteps to be performed. Job 1 should end before 2 starts. The job 28 start time in the schedule is 3, is scheduled to run on device instance 1. The job 1 has an importance of 2, must be executed by device 1, need 14 timesteps to be performed. The job 22 start time in the schedule is 0, is scheduled to run on device instance 1. Job 18 is not allowed to start before the end time of 17. The job 24 start time in the schedule is 29, is scheduled to run on device instance 1, has a deadline 38. The current time is 45. Device 1 has instance four offline. Job 20 should begin only after the end time of 19. The job 3 has a deadline 12.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5473515913464396806", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 3 has a deadline 11. Job 20 is not allowed to start before the end time of 19. The job 11 start time in the schedule is 10, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 3, need 5 timesteps to be performed. The job 22 start time in the schedule is 0, is scheduled to run on device instance 1. Job 12 should begin only after the end time of 11. The total penalty for the schedule cannot be greater than 1388. The job 23 start time in the schedule is 6, is scheduled to run on device instance 2. The job 20 start time in the schedule is 15, is scheduled to run on device instance 1. Job 17 should begin only after the end time of 16. The completion time of job 1 must occur before the start time of 2. The job 13 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. The job 15 has a deadline 14, has an importance of 2, must be executed by device 5, need 5 timesteps to be performed. Job 11 should begin only after the end time of 10. The numerical quantities cannot exceed one thousand, five hundred and fifteen. Job 18 should begin only after the end time of 17. The job 27 has a deadline 13. The job 30 has a deadline 15. The job 19 start time in the schedule is 10, is scheduled to run on device instance 1. The job 18 has a deadline 11. The end time of job 14 must precede the start time of 15. The start time of 14 must be after the end time of 13. The job 24 has a deadline 10. The job 10 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 2, need 10 timesteps to be performed. The current time is 51. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 14 has an importance of 3, must be executed by device 4, need 11 timesteps to be performed. The job 1 has an importance of 3, must be executed by device 1, need 6 timesteps to be performed. The job 21 start time in the schedule is 23, is scheduled to run on device instance 1, has a deadline 12. The job 16 has an importance of 3, must be executed by device 2, need 15 timesteps to be performed. The job 12 start time in the schedule is 15, is scheduled to run on device instance 1, has a deadline 18, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(10, 0). curr_on_instance(10, 1). importance(10, 2). job_device(10, 2). job_len(10, 10). job(10). curr_job_start(11, 10). curr_on_instance(11, 1). importance(11, 1). job_device(11, 3). job_len(11, 5). job(11). curr_job_start(12, 15). curr_on_instance(12, 1). deadline(12, 18). importance(12, 3). job_device(12, 5). job_len(12, 8). job(12). curr_job_start(19, 10). curr_on_instance(19, 1). job(19). curr_job_start(20, 15). curr_on_instance(20, 1). job(20). curr_job_start(21, 23). curr_on_instance(21, 1). deadline(21, 12). job(21). curr_job_start(22, 0). curr_on_instance(22, 1). job(22). curr_job_start(23, 6). curr_on_instance(23, 2). job(23). deadline(15, 14). importance(15, 2). job_device(15, 5). job_len(15, 5). job(15). deadline(18, 11). job(18). deadline(24, 10). job(24). deadline(27, 13). job(27). deadline(3, 11). job(3). deadline(30, 15). job(30). importance(1, 3). job_device(1, 1). job_len(1, 6). job(1). importance(13, 1). job_device(13, 1). job_len(13, 12). job(13). importance(14, 3). job_device(14, 4). job_len(14, 11). job(14). importance(16, 3). job_device(16, 2). job_len(16, 15). job(16). curr_time(51). max_total_penalty(1388). max_value(1515). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 3 has a deadline 11. Job 20 is not allowed to start before the end time of 19. The job 11 start time in the schedule is 10, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 3, need 5 timesteps to be performed. The job 22 start time in the schedule is 0, is scheduled to run on device instance 1. Job 12 should begin only after the end time of 11. The total penalty for the schedule cannot be greater than 1388. The job 23 start time in the schedule is 6, is scheduled to run on device instance 2. The job 20 start time in the schedule is 15, is scheduled to run on device instance 1. Job 17 should begin only after the end time of 16. The completion time of job 1 must occur before the start time of 2. The job 13 has an importance of 1, must be executed by device 1, need 12 timesteps to be performed. The job 15 has a deadline 14, has an importance of 2, must be executed by device 5, need 5 timesteps to be performed. Job 11 should begin only after the end time of 10. The numerical quantities cannot exceed one thousand, five hundred and fifteen. Job 18 should begin only after the end time of 17. The job 27 has a deadline 13. The job 30 has a deadline 15. The job 19 start time in the schedule is 10, is scheduled to run on device instance 1. The job 18 has a deadline 11. The end time of job 14 must precede the start time of 15. The start time of 14 must be after the end time of 13. The job 24 has a deadline 10. The job 10 start time in the schedule is 0, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 2, need 10 timesteps to be performed. The current time is 51. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 14 has an importance of 3, must be executed by device 4, need 11 timesteps to be performed. The job 1 has an importance of 3, must be executed by device 1, need 6 timesteps to be performed. The job 21 start time in the schedule is 23, is scheduled to run on device instance 1, has a deadline 12. The job 16 has an importance of 3, must be executed by device 2, need 15 timesteps to be performed. The job 12 start time in the schedule is 15, is scheduled to run on device instance 1, has a deadline 18, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1338650325408590934", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "Job 17 should end before 18 starts. The job 1 start time in the schedule is 28, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 18 timesteps to be performed. The job 11 has an importance of 1, must be executed by device 4, need 5 timesteps to be performed. Job 20 is not allowed to start before the end time of 19. Job 11 is not allowed to start before the end time of 10. The job 2 start time in the schedule is 46, is scheduled to run on device instance 1. The job 18 start time in the schedule is 106, is scheduled to run on device instance 1, has a deadline 27. The job 15 has a deadline 17, has an importance of 3, must be executed by device 5, need 12 timesteps to be performed. The end time of job 16 must precede the start time of 17. The job 14 has an importance of 3, must be executed by device 4, need 5 timesteps to be performed. The job 30 has a deadline 29. The job 17 start time in the schedule is 45, is scheduled to run on device instance 2. The job 27 start time in the schedule is 94, is scheduled to run on device instance 1, has a deadline 39. Job 14 should begin only after the end time of 13. Time is on 20. The job 3 has a deadline 32. Job 2 should begin only after the end time of 1. The job 25 start time in the schedule is 16, is scheduled to run on device instance 1. The job 13 has an importance of 3, must be executed by device 2, need 3 timesteps to be performed. The job 24 has a deadline 13. The schedule's total penalty must not exceed 2347. The start time of 15 must be after the end time of 14. The job 16 start time in the schedule is 26, is scheduled to run on device instance 2, has an importance of 2, must be executed by device 1, need 17 timesteps to be performed. The highest possible value for the numerical quantities is two thousand, five hundred and twenty-six. The job 26 start time in the schedule is 36, is scheduled to run on device instance 2. The start time of 12 must be after the end time of 11. The job 10 has an importance of 3, must be executed by device 2, need 14 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 12 has a deadline 18, has an importance of 3, must be executed by device 5, need 7 timesteps to be performed. The job 21 has a deadline 31.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(1, 28). curr_on_instance(1, 1). importance(1, 3). job_device(1, 2). job_len(1, 18). job(1). curr_job_start(16, 26). curr_on_instance(16, 2). importance(16, 2). job_device(16, 1). job_len(16, 17). job(16). curr_job_start(17, 45). curr_on_instance(17, 2). job(17). curr_job_start(18, 106). curr_on_instance(18, 1). deadline(18, 27). job(18). curr_job_start(2, 46). curr_on_instance(2, 1). job(2). curr_job_start(25, 16). curr_on_instance(25, 1). job(25). curr_job_start(26, 36). curr_on_instance(26, 2). job(26). curr_job_start(27, 94). curr_on_instance(27, 1). deadline(27, 39). job(27). deadline(12, 18). importance(12, 3). job_device(12, 5). job_len(12, 7). job(12). deadline(15, 17). importance(15, 3). job_device(15, 5). job_len(15, 12). job(15). deadline(21, 31). job(21). deadline(24, 13). job(24). deadline(3, 32). job(3). deadline(30, 29). job(30). importance(10, 3). job_device(10, 2). job_len(10, 14). job(10). importance(11, 1). job_device(11, 4). job_len(11, 5). job(11). importance(13, 3). job_device(13, 2). job_len(13, 3). job(13). importance(14, 3). job_device(14, 4). job_len(14, 5). job(14). curr_time(20). max_total_penalty(2347). max_value(2526). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```Job 17 should end before 18 starts. The job 1 start time in the schedule is 28, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 2, need 18 timesteps to be performed. The job 11 has an importance of 1, must be executed by device 4, need 5 timesteps to be performed. Job 20 is not allowed to start before the end time of 19. Job 11 is not allowed to start before the end time of 10. The job 2 start time in the schedule is 46, is scheduled to run on device instance 1. The job 18 start time in the schedule is 106, is scheduled to run on device instance 1, has a deadline 27. The job 15 has a deadline 17, has an importance of 3, must be executed by device 5, need 12 timesteps to be performed. The end time of job 16 must precede the start time of 17. The job 14 has an importance of 3, must be executed by device 4, need 5 timesteps to be performed. The job 30 has a deadline 29. The job 17 start time in the schedule is 45, is scheduled to run on device instance 2. The job 27 start time in the schedule is 94, is scheduled to run on device instance 1, has a deadline 39. Job 14 should begin only after the end time of 13. Time is on 20. The job 3 has a deadline 32. Job 2 should begin only after the end time of 1. The job 25 start time in the schedule is 16, is scheduled to run on device instance 1. The job 13 has an importance of 3, must be executed by device 2, need 3 timesteps to be performed. The job 24 has a deadline 13. The schedule's total penalty must not exceed 2347. The start time of 15 must be after the end time of 14. The job 16 start time in the schedule is 26, is scheduled to run on device instance 2, has an importance of 2, must be executed by device 1, need 17 timesteps to be performed. The highest possible value for the numerical quantities is two thousand, five hundred and twenty-six. The job 26 start time in the schedule is 36, is scheduled to run on device instance 2. The start time of 12 must be after the end time of 11. The job 10 has an importance of 3, must be executed by device 2, need 14 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 12 has a deadline 18, has an importance of 3, must be executed by device 5, need 7 timesteps to be performed. The job 21 has a deadline 31.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7309022508942367039", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 18 has a deadline 29. The job 14 has an importance of 1, must be executed by device 3, need 5 timesteps to be performed. The job 24 start time in the schedule is 81, is scheduled to run on device instance 1, has a deadline 27. The job 26 start time in the schedule is 6, is scheduled to run on device instance 1. The job 12 has a deadline 11, has an importance of 3, must be executed by device 5, need 15 timesteps to be performed. The job 30 has a deadline 14. The job 10 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. Job 11 should end before 12 starts. The job 16 has an importance of 1, must be executed by device 1, need 19 timesteps to be performed. Job 14 should end before 15 starts. The job 11 has an importance of 2, must be executed by device 4, need 10 timesteps to be performed. The total penalty for the schedule cannot be greater than 1658. Time is on 49. The job 21 has a deadline 26. The job 23 start time in the schedule is 67, is scheduled to run on device instance 1. The job 1 has an importance of 1, must be executed by device 2, need 9 timesteps to be performed. The numerical quantities cannot exceed one thousand, eight hundred and eighty-eight. Job 14 is not allowed to start before the end time of 13. The job 28 start time in the schedule is 34, is scheduled to run on device instance 1. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 22 start time in the schedule is 6, is scheduled to run on device instance 2. The job 25 start time in the schedule is 0, is scheduled to run on device instance 2. The job 3 has a deadline 13. Job 19 should end before 20 starts. The start time of 18 must be after the end time of 17. The completion time of job 10 must occur before the start time of 11. Job 1 must finish before the start time of 2. The job 15 has a deadline 22, has an importance of 1, must be executed by device 5, need 16 timesteps to be performed. The start time of 17 must be after the end time of 16. The job 29 start time in the schedule is 47, is scheduled to run on device instance 1. The job 27 start time in the schedule is 19, is scheduled to run on device instance 1, has a deadline 13. The job 13 has an importance of 3, must be executed by device 2, need 17 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(22, 6). curr_on_instance(22, 2). job(22). curr_job_start(23, 67). curr_on_instance(23, 1). job(23). curr_job_start(24, 81). curr_on_instance(24, 1). deadline(24, 27). job(24). curr_job_start(25, 0). curr_on_instance(25, 2). job(25). curr_job_start(26, 6). curr_on_instance(26, 1). job(26). curr_job_start(27, 19). curr_on_instance(27, 1). deadline(27, 13). job(27). curr_job_start(28, 34). curr_on_instance(28, 1). job(28). curr_job_start(29, 47). curr_on_instance(29, 1). job(29). deadline(12, 11). importance(12, 3). job_device(12, 5). job_len(12, 15). job(12). deadline(15, 22). importance(15, 1). job_device(15, 5). job_len(15, 16). job(15). deadline(18, 29). job(18). deadline(21, 26). job(21). deadline(3, 13). job(3). deadline(30, 14). job(30). importance(1, 1). job_device(1, 2). job_len(1, 9). job(1). importance(10, 1). job_device(10, 2). job_len(10, 15). job(10). importance(11, 2). job_device(11, 4). job_len(11, 10). job(11). importance(13, 3). job_device(13, 2). job_len(13, 17). job(13). importance(14, 1). job_device(14, 3). job_len(14, 5). job(14). importance(16, 1). job_device(16, 1). job_len(16, 19). job(16). curr_time(49). max_total_penalty(1658). max_value(1888). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 18 has a deadline 29. The job 14 has an importance of 1, must be executed by device 3, need 5 timesteps to be performed. The job 24 start time in the schedule is 81, is scheduled to run on device instance 1, has a deadline 27. The job 26 start time in the schedule is 6, is scheduled to run on device instance 1. The job 12 has a deadline 11, has an importance of 3, must be executed by device 5, need 15 timesteps to be performed. The job 30 has a deadline 14. The job 10 has an importance of 1, must be executed by device 2, need 15 timesteps to be performed. Job 11 should end before 12 starts. The job 16 has an importance of 1, must be executed by device 1, need 19 timesteps to be performed. Job 14 should end before 15 starts. The job 11 has an importance of 2, must be executed by device 4, need 10 timesteps to be performed. The total penalty for the schedule cannot be greater than 1658. Time is on 49. The job 21 has a deadline 26. The job 23 start time in the schedule is 67, is scheduled to run on device instance 1. The job 1 has an importance of 1, must be executed by device 2, need 9 timesteps to be performed. The numerical quantities cannot exceed one thousand, eight hundred and eighty-eight. Job 14 is not allowed to start before the end time of 13. The job 28 start time in the schedule is 34, is scheduled to run on device instance 1. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 22 start time in the schedule is 6, is scheduled to run on device instance 2. The job 25 start time in the schedule is 0, is scheduled to run on device instance 2. The job 3 has a deadline 13. Job 19 should end before 20 starts. The start time of 18 must be after the end time of 17. The completion time of job 10 must occur before the start time of 11. Job 1 must finish before the start time of 2. The job 15 has a deadline 22, has an importance of 1, must be executed by device 5, need 16 timesteps to be performed. The start time of 17 must be after the end time of 16. The job 29 start time in the schedule is 47, is scheduled to run on device instance 1. The job 27 start time in the schedule is 19, is scheduled to run on device instance 1, has a deadline 13. The job 13 has an importance of 3, must be executed by device 2, need 17 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4549118812617394930", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 10 has an importance of 2, must be executed by device 1, need 12 timesteps to be performed. Job 17 should begin only after the end time of 16. The maximum possible value for the numerical quanitities is three thousand. The end time of job 19 must precede the start time of 20. The job 11 has an importance of 2, must be executed by device 4, need 13 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 2, need 9 timesteps to be performed. The job 21 has a deadline 13. The job 30 has a deadline 24. The job 18 has a deadline 21. The job 13 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. The job 27 has a deadline 31. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Time is on 0. The job 3 has a deadline 23. Job 1 should end before 2 starts. The job 16 has an importance of 3, must be executed by device 1, need 5 timesteps to be performed. Job 11 must be completed before 12 begins. The job 12 has a deadline 14, has an importance of 1, must be executed by device 5, need 14 timesteps to be performed. The job 24 has a deadline 11. The end time of job 10 must precede the start time of 11. The schedule's total penalty must not exceed 2875. The job 14 has an importance of 1, must be executed by device 3, need 12 timesteps to be performed. The job 15 has a deadline 11, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed. Job 14 is not allowed to start before the end time of 13. Job 14 must be completed before 15 begins. Job 18 is not allowed to start before the end time of 17.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 14). importance(12, 1). job_device(12, 5). job_len(12, 14). job(12). deadline(15, 11). importance(15, 3). job_device(15, 5). job_len(15, 8). job(15). deadline(18, 21). job(18). deadline(21, 13). job(21). deadline(24, 11). job(24). deadline(27, 31). job(27). deadline(3, 23). job(3). deadline(30, 24). job(30). importance(1, 2). job_device(1, 2). job_len(1, 9). job(1). importance(10, 2). job_device(10, 1). job_len(10, 12). job(10). importance(11, 2). job_device(11, 4). job_len(11, 13). job(11). importance(13, 3). job_device(13, 1). job_len(13, 15). job(13). importance(14, 1). job_device(14, 3). job_len(14, 12). job(14). importance(16, 3). job_device(16, 1). job_len(16, 5). job(16). curr_time(0). max_total_penalty(2875). max_value(3000). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 10 has an importance of 2, must be executed by device 1, need 12 timesteps to be performed. Job 17 should begin only after the end time of 16. The maximum possible value for the numerical quanitities is three thousand. The end time of job 19 must precede the start time of 20. The job 11 has an importance of 2, must be executed by device 4, need 13 timesteps to be performed. The job 1 has an importance of 2, must be executed by device 2, need 9 timesteps to be performed. The job 21 has a deadline 13. The job 30 has a deadline 24. The job 18 has a deadline 21. The job 13 has an importance of 3, must be executed by device 1, need 15 timesteps to be performed. The job 27 has a deadline 31. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Time is on 0. The job 3 has a deadline 23. Job 1 should end before 2 starts. The job 16 has an importance of 3, must be executed by device 1, need 5 timesteps to be performed. Job 11 must be completed before 12 begins. The job 12 has a deadline 14, has an importance of 1, must be executed by device 5, need 14 timesteps to be performed. The job 24 has a deadline 11. The end time of job 10 must precede the start time of 11. The schedule's total penalty must not exceed 2875. The job 14 has an importance of 1, must be executed by device 3, need 12 timesteps to be performed. The job 15 has a deadline 11, has an importance of 3, must be executed by device 5, need 8 timesteps to be performed. Job 14 is not allowed to start before the end time of 13. Job 14 must be completed before 15 begins. Job 18 is not allowed to start before the end time of 17.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2599536250207954738", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The job 14 start time in the schedule is 33, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 3, need 17 timesteps to be performed. Job 15 is not allowed to start before the end time of 14. The total penalty of the schedule must be less than or equal to 2086. The job 3 has a deadline 38. The job 18 start time in the schedule is 91, is scheduled to run on device instance 1, has a deadline 33. The job 17 start time in the schedule is 75, is scheduled to run on device instance 1. Job 19 must be completed before 20 begins. The job 27 has a deadline 35. The job 1 has an importance of 2, must be executed by device 1, need 6 timesteps to be performed. The job 13 start time in the schedule is 8, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. Job 18 should begin only after the end time of 17. The job 24 has a deadline 35. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 17 is not allowed to start before the end time of 16. The present time is 90. Job 2 should begin only after the end time of 1. The completion time of job 10 must occur before the start time of 11. The job 20 start time in the schedule is 59, is scheduled to run on device instance 1. Instance one on device 1 is currently offline. The job 10 has an importance of 3, must be executed by device 2, need 18 timesteps to be performed. The job 21 has a deadline 12. The job 15 start time in the schedule is 50, is scheduled to run on device instance 1, has a deadline 19, has an importance of 1, must be executed by device 5, need 8 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 20 timesteps to be performed. The job 30 has a deadline 23. The greatest possible value for the numerical quantities is two thousand, two hundred and sixty-eight. The job 19 start time in the schedule is 46, is scheduled to run on device instance 1. Job 14 is not allowed to start before the end time of 13. The job 16 start time in the schedule is 54, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 2, need 4 timesteps to be performed. The completion time of job 11 must occur before the start time of 12. The job 12 has a deadline 18, has an importance of 3, must be executed by device 5, need 9 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). curr_job_start(13, 8). curr_on_instance(13, 1). importance(13, 2). job_device(13, 1). job_len(13, 3). job(13). curr_job_start(14, 33). curr_on_instance(14, 1). importance(14, 3). job_device(14, 3). job_len(14, 17). job(14). curr_job_start(15, 50). curr_on_instance(15, 1). deadline(15, 19). importance(15, 1). job_device(15, 5). job_len(15, 8). job(15). curr_job_start(16, 54). curr_on_instance(16, 1). importance(16, 1). job_device(16, 2). job_len(16, 4). job(16). curr_job_start(17, 75). curr_on_instance(17, 1). job(17). curr_job_start(18, 91). curr_on_instance(18, 1). deadline(18, 33). job(18). curr_job_start(19, 46). curr_on_instance(19, 1). job(19). curr_job_start(20, 59). curr_on_instance(20, 1). job(20). deadline(12, 18). importance(12, 3). job_device(12, 5). job_len(12, 9). job(12). deadline(21, 12). job(21). deadline(24, 35). job(24). deadline(27, 35). job(27). deadline(3, 38). job(3). deadline(30, 23). job(30). importance(1, 2). job_device(1, 1). job_len(1, 6). job(1). importance(10, 3). job_device(10, 2). job_len(10, 18). job(10). importance(11, 3). job_device(11, 3). job_len(11, 20). job(11). curr_time(90). max_total_penalty(2086). max_value(2268). offline_instance(1,1). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The job 14 start time in the schedule is 33, is scheduled to run on device instance 1, has an importance of 3, must be executed by device 3, need 17 timesteps to be performed. Job 15 is not allowed to start before the end time of 14. The total penalty of the schedule must be less than or equal to 2086. The job 3 has a deadline 38. The job 18 start time in the schedule is 91, is scheduled to run on device instance 1, has a deadline 33. The job 17 start time in the schedule is 75, is scheduled to run on device instance 1. Job 19 must be completed before 20 begins. The job 27 has a deadline 35. The job 1 has an importance of 2, must be executed by device 1, need 6 timesteps to be performed. The job 13 start time in the schedule is 8, is scheduled to run on device instance 1, has an importance of 2, must be executed by device 1, need 3 timesteps to be performed. Job 18 should begin only after the end time of 17. The job 24 has a deadline 35. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. Job 17 is not allowed to start before the end time of 16. The present time is 90. Job 2 should begin only after the end time of 1. The completion time of job 10 must occur before the start time of 11. The job 20 start time in the schedule is 59, is scheduled to run on device instance 1. Instance one on device 1 is currently offline. The job 10 has an importance of 3, must be executed by device 2, need 18 timesteps to be performed. The job 21 has a deadline 12. The job 15 start time in the schedule is 50, is scheduled to run on device instance 1, has a deadline 19, has an importance of 1, must be executed by device 5, need 8 timesteps to be performed. The job 11 has an importance of 3, must be executed by device 3, need 20 timesteps to be performed. The job 30 has a deadline 23. The greatest possible value for the numerical quantities is two thousand, two hundred and sixty-eight. The job 19 start time in the schedule is 46, is scheduled to run on device instance 1. Job 14 is not allowed to start before the end time of 13. The job 16 start time in the schedule is 54, is scheduled to run on device instance 1, has an importance of 1, must be executed by device 2, need 4 timesteps to be performed. The completion time of job 11 must occur before the start time of 12. The job 12 has a deadline 18, has an importance of 3, must be executed by device 5, need 9 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6722345185344889647", "problem_id": "33", "problem_name": "Incremental Scheduling", "description": "In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.", "format": "max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct", "text": "The maximum value that the numerical quantities can take is one thousand, four hundred and forty. The job 1 has an importance of 3, must be executed by device 1, need 6 timesteps to be performed. The job 21 has a deadline 31. The completion time of job 13 must occur before the start time of 14. Job 1 should end before 2 starts. Job 18 should begin only after the end time of 17. The job 3 has a deadline 14. The job 30 has a deadline 26. The job 14 has an importance of 3, must be executed by device 3, need 8 timesteps to be performed. The job 12 has a deadline 12, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. The completion time of job 16 must occur before the start time of 17. Instance number two from device 1 is offline. The schedule's total penalty must be at most 1339. The job 11 has an importance of 2, must be executed by device 3, need 15 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 15 has a deadline 23, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. Time is on 0. Job 11 must be completed before 12 begins. Instance number three from device 2 is offline. Job 11 should begin only after the end time of 10. The job 24 has a deadline 38. Job 14 must finish before the start time of 15. Job 19 should end before 20 starts. The job 13 has an importance of 1, must be executed by device 2, need 14 timesteps to be performed. The job 27 has a deadline 24. The job 18 has a deadline 19. The job 16 has an importance of 3, must be executed by device 1, need 5 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 1, need 17 timesteps to be performed.", "output": "device(1). instances(1,2). device(2). instances(2,1). device(3). instances(3,2). device(4). instances(4,1). device(5). instances(5,1). deadline(12, 12). importance(12, 2). job_device(12, 5). job_len(12, 12). job(12). deadline(15, 23). importance(15, 3). job_device(15, 5). job_len(15, 5). job(15). deadline(18, 19). job(18). deadline(21, 31). job(21). deadline(24, 38). job(24). deadline(27, 24). job(27). deadline(3, 14). job(3). deadline(30, 26). job(30). importance(1, 3). job_device(1, 1). job_len(1, 6). job(1). importance(10, 3). job_device(10, 1). job_len(10, 17). job(10). importance(11, 2). job_device(11, 3). job_len(11, 15). job(11). importance(13, 1). job_device(13, 2). job_len(13, 14). job(13). importance(14, 3). job_device(14, 3). job_len(14, 8). job(14). importance(16, 3). job_device(16, 1). job_len(16, 5). job(16). curr_time(0). max_total_penalty(1339). max_value(1440). offline_instance(2,1). offline_instance(3,2). precedes(1,2). precedes(10,11). precedes(11,12). precedes(13,14). precedes(14,15). precedes(16,17). precedes(17,18). precedes(19,20).", "prompt": "Given the following problem description between triple backtips: \n ```In this domain, a reasoner keeps a schedule updated with respect to the addition of jobs and to equipment going offline.\nAll numerical quantities discussed below are integers. The largest possible value is specified by relation max_value(mv).\nList of devices\nEach device has one or more identical instances. Each instance may be offline, meaning that it cannot be used for scheduling.\nList of jobs\nFor each job, the following are specified:\n- Job's device, i.e. which device should be used for the job (REQUIRED).\n- Length, i.e. how long production of the job will take (REQUIRED).\n- Deadline, i.e. the job's latest end time (OPTIONAL).\n- Importance: an integer imp >= 1 (OPTIONAL, DEFAULTS TO 1).\n- A list of jobs that precede it, i.e. must be completely executed before the current job can start.\n\nA job is tardy if it is completed after its deadline. Its tardiness is computed as the difference between the job's actual end time and its deadline. The penalty for a job being tardy is computed as td * imp, where td is the job's tardiness and imp is the job's importance. NOTE: For jobs that don't have a deadline tardiness is intended as undefined; and since the penalty is tardiness * importance, the penalty of jobs without a deadline is undefined as well.\n\nMaximum total penalty\nThe total penalty of a schedule is the sum of the penalties of the single jobs. Schedules with a higher total penalty greater than the specified maximum total penalty are not valid solutions.\nCurrent schedule\nThe current schedule, which must be updated by the scheduler, specifies, FOR A SUBSET OF THE AVAILABLE JOBS, each job's start time and the device instance the job must be run on. Intuitively, elements of the list of jobs (see section above) that have no start time and device instance assigned in the current schedule should be viewed as jobs that have been added after the current schedule was computed.\nCurrent time\nThe current time ct is an integer specifying at which point the execution of the schedule is. Jobs whose end time is smaller than OR EQUAL TO ct are expected to have already been completed.\nThe scheduling task\nGiven the list of devices, the list of jobs, the current schedule, and the current time, the scheduler is expected to find a new schedule such that:\n- the start time and allocated instance of a job that has already been completed remain the same;\n- the start time and allocated instance of a job that is currently being executed on a device instance which is online remain the same;\n- jobs whose expected end time is greater than the current time cannot be scheduled on a device instance that is offline;\n- precedences between jobs are respected;\n- the total penalty is no larger than the maximum total penalty.\nRescheduling a job\nWhenever a job needs to be re-scheduled after it has already started, the scheduler will need to re-schedule the complete job, i.e. it will discard the part of the job that has already performed. The output of the scheduler should indicate that the job has been re-scheduled.```\nGiven the following specification for the predicates format: \n```max_value(<mv>): maximum possible value for the numerical quantities\n\ndevice(<d>): d is a device\ninstances(<d>,<n>): device d has n instances\noffline_instance(<d>,<i>): instance 1 <= i <= n is offline\n\njob(<j>): j is a job\njob_device(<j>,<d>): j must be executed by device d\njob_len(<j>,<l>): the amount of time needed to perform j is l, where l is an integer\ndeadline(<j>,<dl>): the deadline of j is dl\nimportance(<j>,<imp>): the importance of j is imp >= 1\nprecedes(<j1>,<j2>): the end time of j1 must precede (be less than or equal to) the start time of j2\n\nmax_total_penalty(<mp>): the total penalty of the schedule must be less than or equal to mp.\n\ncurr_job_start(<j>,<st>): the start time of j in the current schedule is st\ncurr_on_instance(<j>,<i>): in the current schedule, j is scheduled to run on device instance i\n\ncurr_time(<ct>): the current time is ct```\nExtract the datalog facts from this text: \n```The maximum value that the numerical quantities can take is one thousand, four hundred and forty. The job 1 has an importance of 3, must be executed by device 1, need 6 timesteps to be performed. The job 21 has a deadline 31. The completion time of job 13 must occur before the start time of 14. Job 1 should end before 2 starts. Job 18 should begin only after the end time of 17. The job 3 has a deadline 14. The job 30 has a deadline 26. The job 14 has an importance of 3, must be executed by device 3, need 8 timesteps to be performed. The job 12 has a deadline 12, has an importance of 2, must be executed by device 5, need 12 timesteps to be performed. The completion time of job 16 must occur before the start time of 17. Instance number two from device 1 is offline. The schedule's total penalty must be at most 1339. The job 11 has an importance of 2, must be executed by device 3, need 15 timesteps to be performed. There are five devices: device 1 with two instances, device 2 with one instance, device 3 with two instances, device 4 with one instance, device 5 with one instance. The job 15 has a deadline 23, has an importance of 3, must be executed by device 5, need 5 timesteps to be performed. Time is on 0. Job 11 must be completed before 12 begins. Instance number three from device 2 is offline. Job 11 should begin only after the end time of 10. The job 24 has a deadline 38. Job 14 must finish before the start time of 15. Job 19 should end before 20 starts. The job 13 has an importance of 1, must be executed by device 2, need 14 timesteps to be performed. The job 27 has a deadline 24. The job 18 has a deadline 19. The job 16 has an importance of 3, must be executed by device 1, need 5 timesteps to be performed. The job 10 has an importance of 3, must be executed by device 1, need 17 timesteps to be performed.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7454086446571835703", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a required movement from (36,44) to (35,46). The chess board size is 62*62. The knight has to move from (40,11) to (39,13). There is a move from (1,42) to (2,44).", "output": "size(62). givemove(1,42,2,44). givemove(36,44,35,46). givemove(40,11,39,13).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a required movement from (36,44) to (35,46). The chess board size is 62*62. The knight has to move from (40,11) to (39,13). There is a move from (1,42) to (2,44).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "206614837271363097", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (56,5) to (55,7). The chess board size is 58*58. There is a required movement from (26,22) to (27,20). There is a move from (26,29) to (25,31). There is a required movement from (16,36) to (17,38).", "output": "size(58). givemove(16,36,17,38). givemove(26,22,27,20). givemove(26,29,25,31). givemove(56,5,55,7).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (56,5) to (55,7). The chess board size is 58*58. There is a required movement from (26,22) to (27,20). There is a move from (26,29) to (25,31). There is a required movement from (16,36) to (17,38).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3183314478208562049", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (1,6) to (2,8). There is a move from (19,10) to (20,8). There is a move from (2,4) to (1,6). The chess board size is 48*48.", "output": "size(48). givemove(1,6,2,8). givemove(19,10,20,8). givemove(2,4,1,6).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (1,6) to (2,8). There is a move from (19,10) to (20,8). There is a move from (2,4) to (1,6). The chess board size is 48*48.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5266601125610414422", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (9,1) to (7,2). There is a move from (50,20) to (48,19). The chess board size is 50*50. There is a move from (2,8) to (3,6).", "output": "size(50). givemove(2,8,3,6). givemove(50,20,48,19). givemove(9,1,7,2).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (9,1) to (7,2). There is a move from (50,20) to (48,19). The chess board size is 50*50. There is a move from (2,8) to (3,6).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1795994148095155494", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 58*58. There is a move from (27,8) to (28,10). There is a required movement from (27,22) to (28,20). There is a move from (37,13) to (36,15).", "output": "size(58). givemove(27,22,28,20). givemove(27,8,28,10). givemove(37,13,36,15).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 58*58. There is a move from (27,8) to (28,10). There is a required movement from (27,22) to (28,20). There is a move from (37,13) to (36,15).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1707294510476335512", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 56*56.", "output": "size(56).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 56*56.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "996786916128697529", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (30,3) to (31,1). There is a required movement from (40,20) to (41,22). There is a move from (33,18) to (32,20). The chess board size is 48*48.", "output": "size(48). givemove(30,3,31,1). givemove(33,18,32,20). givemove(40,20,41,22).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (30,3) to (31,1). There is a required movement from (40,20) to (41,22). There is a move from (33,18) to (32,20). The chess board size is 48*48.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4177855460064553477", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (44,7) to (45,5). The chess board size is 56*56. There is a required movement from (4,20) to (5,22). There is a required movement from (14,40) to (13,42).", "output": "size(56). givemove(14,40,13,42). givemove(4,20,5,22). givemove(44,7,45,5).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (44,7) to (45,5). The chess board size is 56*56. There is a required movement from (4,20) to (5,22). There is a required movement from (14,40) to (13,42).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5200091992818444189", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (4,20) to (5,22). The chess board size is 56*56. There is a move from (44,7) to (45,5). The knight has to move from (14,40) to (13,42).", "output": "size(56). givemove(14,40,13,42). givemove(4,20,5,22). givemove(44,7,45,5).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (4,20) to (5,22). The chess board size is 56*56. There is a move from (44,7) to (45,5). The knight has to move from (14,40) to (13,42).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3273536852567526353", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (9,1) to (7,2). The chess board size is 50*50. There is a move from (2,8) to (3,6). There is a required movement from (50,20) to (48,19).", "output": "size(50). givemove(2,8,3,6). givemove(50,20,48,19). givemove(9,1,7,2).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (9,1) to (7,2). The chess board size is 50*50. There is a move from (2,8) to (3,6). There is a required movement from (50,20) to (48,19).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2245946272348313456", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (58,61) to (56,62). There is a move from (30,39) to (28,40). There is a required movement from (19,26) to (20,24). The chess board size is 62*62. There is a move from (18,50) to (19,48).", "output": "size(62). givemove(18,50,19,48). givemove(19,26,20,24). givemove(30,39,28,40). givemove(58,61,56,62).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (58,61) to (56,62). There is a move from (30,39) to (28,40). There is a required movement from (19,26) to (20,24). The chess board size is 62*62. There is a move from (18,50) to (19,48).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2805068728765758602", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a required movement from (24,3) to (23,5). There is a move from (39,14) to (40,12). There is a move from (4,35) to (5,33). The chess board size is 50*50.", "output": "size(50). givemove(24,3,23,5). givemove(39,14,40,12). givemove(4,35,5,33).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a required movement from (24,3) to (23,5). There is a move from (39,14) to (40,12). There is a move from (4,35) to (5,33). The chess board size is 50*50.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3345752533324868323", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (40,6) to (41,4). The chess board size is 46*46. There is a required movement from (1,3) to (2,1). There is a move from (35,18) to (36,20). The knight has to move from (30,20) to (31,22).", "output": "size(46). givemove(1,3,2,1). givemove(30,20,31,22). givemove(35,18,36,20). givemove(40,6,41,4).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (40,6) to (41,4). The chess board size is 46*46. There is a required movement from (1,3) to (2,1). There is a move from (35,18) to (36,20). The knight has to move from (30,20) to (31,22).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4146714480584829072", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 56*56.", "output": "size(56).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 56*56.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2513651131631154368", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 48*48. The knight has to move from (30,3) to (31,1). There is a required movement from (40,20) to (41,22). The knight has to move from (33,18) to (32,20).", "output": "size(48). givemove(30,3,31,1). givemove(33,18,32,20). givemove(40,20,41,22).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 48*48. The knight has to move from (30,3) to (31,1). There is a required movement from (40,20) to (41,22). The knight has to move from (33,18) to (32,20).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3385347636808813282", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 62*62.", "output": "size(62).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 62*62.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6185841718534759018", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (48,6) to (49,4). There is a move from (58,6) to (56,5). The chess board size is 58*58. There is a required movement from (58,9) to (56,10).", "output": "size(58). givemove(48,6,49,4). givemove(58,6,56,5). givemove(58,9,56,10).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (48,6) to (49,4). There is a move from (58,6) to (56,5). The chess board size is 58*58. There is a required movement from (58,9) to (56,10).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3360936747655300119", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a required movement from (16,36) to (17,38). There is a required movement from (26,29) to (25,31). The chess board size is 58*58. There is a required movement from (56,5) to (55,7). The knight has to move from (26,22) to (27,20).", "output": "size(58). givemove(16,36,17,38). givemove(26,22,27,20). givemove(26,29,25,31). givemove(56,5,55,7).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a required movement from (16,36) to (17,38). There is a required movement from (26,29) to (25,31). The chess board size is 58*58. There is a required movement from (56,5) to (55,7). The knight has to move from (26,22) to (27,20).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4299298461708289482", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 48*48. The knight has to move from (18,46) to (17,44). There is a move from (44,28) to (42,29). There is a move from (3,47) to (1,48).", "output": "size(48). givemove(18,46,17,44). givemove(3,47,1,48). givemove(44,28,42,29).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 48*48. The knight has to move from (18,46) to (17,44). There is a move from (44,28) to (42,29). There is a move from (3,47) to (1,48).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6650491136216567377", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 50*50.", "output": "size(50).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 50*50.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5542644543685294326", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (19,26) to (20,24). The chess board size is 62*62. The knight has to move from (18,29) to (17,27). There is a required movement from (54,47) to (53,49). There is a move from (61,15) to (62,13). The knight has to move from (17,28) to (18,30).", "output": "size(62). givemove(17,28,18,30). givemove(18,29,17,27). givemove(19,26,20,24). givemove(54,47,53,49). givemove(61,15,62,13).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (19,26) to (20,24). The chess board size is 62*62. The knight has to move from (18,29) to (17,27). There is a required movement from (54,47) to (53,49). There is a move from (61,15) to (62,13). The knight has to move from (17,28) to (18,30).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5142015039729656266", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 48*48. There is a move from (19,10) to (20,8). There is a required movement from (1,6) to (2,8). There is a move from (2,4) to (1,6).", "output": "size(48). givemove(1,6,2,8). givemove(19,10,20,8). givemove(2,4,1,6).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 48*48. There is a move from (19,10) to (20,8). There is a required movement from (1,6) to (2,8). There is a move from (2,4) to (1,6).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6796669564042592875", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a required movement from (26,45) to (24,44). The knight has to move from (21,17) to (22,15). There is a required movement from (28,6) to (29,4). The chess board size is 46*46.", "output": "size(46). givemove(21,17,22,15). givemove(26,45,24,44). givemove(28,6,29,4).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a required movement from (26,45) to (24,44). The knight has to move from (21,17) to (22,15). There is a required movement from (28,6) to (29,4). The chess board size is 46*46.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2357480042012863905", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 58*58.", "output": "size(58).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 58*58.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6026164314913950023", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a move from (19,26) to (20,24). There is a move from (61,15) to (62,13). There is a required movement from (54,47) to (53,49). There is a required movement from (17,28) to (18,30). There is a move from (18,29) to (17,27). The chess board size is 62*62.", "output": "size(62). givemove(17,28,18,30). givemove(18,29,17,27). givemove(19,26,20,24). givemove(54,47,53,49). givemove(61,15,62,13).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a move from (19,26) to (20,24). There is a move from (61,15) to (62,13). There is a required movement from (54,47) to (53,49). There is a required movement from (17,28) to (18,30). There is a move from (18,29) to (17,27). The chess board size is 62*62.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6957418697346130345", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 46*46.", "output": "size(46).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 46*46.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5304470713380831160", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 58*58.", "output": "size(58).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 58*58.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "46468261776296553", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (19,26) to (20,24). There is a required movement from (30,39) to (28,40). There is a required movement from (58,61) to (56,62). The knight has to move from (18,50) to (19,48). The chess board size is 62*62.", "output": "size(62). givemove(18,50,19,48). givemove(19,26,20,24). givemove(30,39,28,40). givemove(58,61,56,62).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (19,26) to (20,24). There is a required movement from (30,39) to (28,40). There is a required movement from (58,61) to (56,62). The knight has to move from (18,50) to (19,48). The chess board size is 62*62.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9188795095356466465", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (37,13) to (36,15). The chess board size is 58*58. There is a move from (27,8) to (28,10). There is a required movement from (27,22) to (28,20).", "output": "size(58). givemove(27,22,28,20). givemove(27,8,28,10). givemove(37,13,36,15).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (37,13) to (36,15). The chess board size is 58*58. There is a move from (27,8) to (28,10). There is a required movement from (27,22) to (28,20).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4166509922228569618", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "There is a required movement from (18,42) to (19,44). The knight has to move from (48,19) to (47,21). There is a required movement from (43,1) to (41,2). The chess board size is 50*50.", "output": "size(50). givemove(18,42,19,44). givemove(43,1,41,2). givemove(48,19,47,21).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a required movement from (18,42) to (19,44). The knight has to move from (48,19) to (47,21). There is a required movement from (43,1) to (41,2). The chess board size is 50*50.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8500363706496375574", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The knight has to move from (48,6) to (49,4). The knight has to move from (58,9) to (56,10). There is a required movement from (58,6) to (56,5). The chess board size is 58*58.", "output": "size(58). givemove(48,6,49,4). givemove(58,6,56,5). givemove(58,9,56,10).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The knight has to move from (48,6) to (49,4). The knight has to move from (58,9) to (56,10). There is a required movement from (58,6) to (56,5). The chess board size is 58*58.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7665149602871921016", "problem_id": "11", "problem_name": "Knight Tour", "description": "Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.\n", "text": "The chess board size is 56*56.", "output": "size(56).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares, and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms givemove(X1,Y1,X2,Y2). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. In this way, each square can be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 56*56.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "890425471957913986", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (23, 52) is forbidden. There is a hole in position (48, 41). There is a hole in position (2, 50). The square in position (26, 26) is forbidden. There is a hole in position (16, 26). The square in position (24, 36) is forbidden. The chess board size is 70*70. The square in position (29, 4) is forbidden. There is a hole in position (32, 42).", "output": "size(70). forbidden(16,26). forbidden(2,50). forbidden(23,52). forbidden(24,36). forbidden(26,26). forbidden(29,4). forbidden(32,42). forbidden(48,41).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (23, 52) is forbidden. There is a hole in position (48, 41). There is a hole in position (2, 50). The square in position (26, 26) is forbidden. There is a hole in position (16, 26). The square in position (24, 36) is forbidden. The chess board size is 70*70. The square in position (29, 4) is forbidden. There is a hole in position (32, 42).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5315880802516183374", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (23, 9). The chess board size is 85*85. The square in position (2, 59) is forbidden. There is a hole in position (16, 1). There is a hole in position (27, 38). The square in position (32, 21) is forbidden. The square in position (12, 63) is forbidden. The square in position (3, 53) is forbidden. There is a hole in position (1, 81).", "output": "size(85). forbidden(1,81). forbidden(12,63). forbidden(16,1). forbidden(2,59). forbidden(23,9). forbidden(27,38). forbidden(3,53). forbidden(32,21).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (23, 9). The chess board size is 85*85. The square in position (2, 59) is forbidden. There is a hole in position (16, 1). There is a hole in position (27, 38). The square in position (32, 21) is forbidden. The square in position (12, 63) is forbidden. The square in position (3, 53) is forbidden. There is a hole in position (1, 81).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "317378215528202165", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The chess board size is 45*45. There is a hole in position (24, 32). The square in position (19, 26) is forbidden. There is a hole in position (16, 2). The square in position (22, 20) is forbidden. The square in position (17, 40) is forbidden. There is a hole in position (2, 12). There is a hole in position (14, 18). There is a hole in position (18, 29).", "output": "size(45). forbidden(14,18). forbidden(16,2). forbidden(17,40). forbidden(18,29). forbidden(19,26). forbidden(2,12). forbidden(22,20). forbidden(24,32).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 45*45. There is a hole in position (24, 32). The square in position (19, 26) is forbidden. There is a hole in position (16, 2). The square in position (22, 20) is forbidden. The square in position (17, 40) is forbidden. There is a hole in position (2, 12). There is a hole in position (14, 18). There is a hole in position (18, 29).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1311568919687595086", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (45, 42) is forbidden. There is a hole in position (25, 48). There is a hole in position (21, 9). The square in position (14, 35) is forbidden. The square in position (3, 38) is forbidden. The chess board size is 70*70. The square in position (27, 4) is forbidden. The square in position (31, 64) is forbidden. There is a hole in position (32, 47).", "output": "size(70). forbidden(14,35). forbidden(21,9). forbidden(25,48). forbidden(27,4). forbidden(3,38). forbidden(31,64). forbidden(32,47). forbidden(45,42).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (45, 42) is forbidden. There is a hole in position (25, 48). There is a hole in position (21, 9). The square in position (14, 35) is forbidden. The square in position (3, 38) is forbidden. The chess board size is 70*70. The square in position (27, 4) is forbidden. The square in position (31, 64) is forbidden. There is a hole in position (32, 47).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8565370767120607281", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (4, 65) is forbidden. The square in position (28, 81) is forbidden. The chess board size is 85*85. The square in position (4, 64) is forbidden. The square in position (42, 23) is forbidden. The square in position (24, 81) is forbidden. The square in position (41, 55) is forbidden. The square in position (22, 74) is forbidden. The square in position (20, 69) is forbidden.", "output": "size(85). forbidden(20,69). forbidden(22,74). forbidden(24,81). forbidden(28,81). forbidden(4,64). forbidden(4,65). forbidden(41,55). forbidden(42,23).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (4, 65) is forbidden. The square in position (28, 81) is forbidden. The chess board size is 85*85. The square in position (4, 64) is forbidden. The square in position (42, 23) is forbidden. The square in position (24, 81) is forbidden. The square in position (41, 55) is forbidden. The square in position (22, 74) is forbidden. The square in position (20, 69) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2872690038289881219", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (10, 20) is forbidden. There is a hole in position (16, 25). The square in position (13, 34) is forbidden. There is a hole in position (10, 17). The chess board size is 80*80. There is a hole in position (18, 21). There is a hole in position (10, 80). The square in position (15, 45) is forbidden. There is a hole in position (15, 27).", "output": "size(80). forbidden(10,17). forbidden(10,20). forbidden(10,80). forbidden(13,34). forbidden(15,27). forbidden(15,45). forbidden(16,25). forbidden(18,21).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (10, 20) is forbidden. There is a hole in position (16, 25). The square in position (13, 34) is forbidden. There is a hole in position (10, 17). The chess board size is 80*80. There is a hole in position (18, 21). There is a hole in position (10, 80). The square in position (15, 45) is forbidden. There is a hole in position (15, 27).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7942975131459892657", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (14, 60) is forbidden. The square in position (14, 33) is forbidden. The chess board size is 75*75. There is a hole in position (18, 60). The square in position (14, 32) is forbidden. The square in position (18, 70) is forbidden. The square in position (14, 26) is forbidden. The square in position (18, 68) is forbidden. The square in position (17, 62) is forbidden.", "output": "size(75). forbidden(14,26). forbidden(14,32). forbidden(14,33). forbidden(14,60). forbidden(17,62). forbidden(18,60). forbidden(18,68). forbidden(18,70).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (14, 60) is forbidden. The square in position (14, 33) is forbidden. The chess board size is 75*75. There is a hole in position (18, 60). The square in position (14, 32) is forbidden. The square in position (18, 70) is forbidden. The square in position (14, 26) is forbidden. The square in position (18, 68) is forbidden. The square in position (17, 62) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "389863812771988526", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (43, 6) is forbidden. The square in position (54, 12) is forbidden. The square in position (17, 48) is forbidden. The chess board size is 55*55. There is a hole in position (36, 37). The square in position (51, 3) is forbidden. There is a hole in position (51, 14). The square in position (4, 10) is forbidden.", "output": "size(55). forbidden(17,48). forbidden(36,37). forbidden(4,10). forbidden(43,6). forbidden(51,14). forbidden(51,3). forbidden(54,12).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (43, 6) is forbidden. The square in position (54, 12) is forbidden. The square in position (17, 48) is forbidden. The chess board size is 55*55. There is a hole in position (36, 37). The square in position (51, 3) is forbidden. There is a hole in position (51, 14). The square in position (4, 10) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4882949621687928428", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (14, 75) is forbidden. The chess board size is 80*80. The square in position (13, 9) is forbidden. There is a hole in position (20, 16). The square in position (14, 24) is forbidden. There is a hole in position (14, 63). The square in position (10, 33) is forbidden. There is a hole in position (12, 2). The square in position (16, 68) is forbidden.", "output": "size(80). forbidden(10,33). forbidden(12,2). forbidden(13,9). forbidden(14,24). forbidden(14,63). forbidden(14,75). forbidden(16,68). forbidden(20,16).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (14, 75) is forbidden. The chess board size is 80*80. The square in position (13, 9) is forbidden. There is a hole in position (20, 16). The square in position (14, 24) is forbidden. There is a hole in position (14, 63). The square in position (10, 33) is forbidden. There is a hole in position (12, 2). The square in position (16, 68) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8998823256169210397", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (20, 29) is forbidden. The chess board size is 30*30. There is a hole in position (12, 26). There is a hole in position (12, 5). The square in position (2, 17) is forbidden. There is a hole in position (15, 18). The square in position (15, 13) is forbidden. There is a hole in position (16, 1). The square in position (20, 18) is forbidden.", "output": "size(30). forbidden(12,26). forbidden(12,5). forbidden(15,13). forbidden(15,18). forbidden(16,1). forbidden(2,17). forbidden(20,18). forbidden(20,29).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (20, 29) is forbidden. The chess board size is 30*30. There is a hole in position (12, 26). There is a hole in position (12, 5). The square in position (2, 17) is forbidden. There is a hole in position (15, 18). The square in position (15, 13) is forbidden. There is a hole in position (16, 1). The square in position (20, 18) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6508758724547828709", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (11, 24) is forbidden. The square in position (2, 16) is forbidden. There is a hole in position (10, 31). The chess board size is 40*40. There is a hole in position (14, 33). The square in position (1, 8) is forbidden. The square in position (13, 27) is forbidden. There is a hole in position (15, 8). The square in position (14, 28) is forbidden.", "output": "size(40). forbidden(1,8). forbidden(10,31). forbidden(11,24). forbidden(13,27). forbidden(14,28). forbidden(14,33). forbidden(15,8). forbidden(2,16).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (11, 24) is forbidden. The square in position (2, 16) is forbidden. There is a hole in position (10, 31). The chess board size is 40*40. There is a hole in position (14, 33). The square in position (1, 8) is forbidden. The square in position (13, 27) is forbidden. There is a hole in position (15, 8). The square in position (14, 28) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "900948903366781741", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (14, 25) is forbidden. The square in position (10, 37) is forbidden. There is a hole in position (100, 23). There is a hole in position (1, 21). There is a hole in position (13, 70). The square in position (100, 52) is forbidden. There is a hole in position (12, 26). The square in position (14, 22) is forbidden. The chess board size is 100*100.", "output": "size(100). forbidden(1,21). forbidden(10,37). forbidden(100,23). forbidden(100,52). forbidden(12,26). forbidden(13,70). forbidden(14,22). forbidden(14,25).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (14, 25) is forbidden. The square in position (10, 37) is forbidden. There is a hole in position (100, 23). There is a hole in position (1, 21). There is a hole in position (13, 70). The square in position (100, 52) is forbidden. There is a hole in position (12, 26). The square in position (14, 22) is forbidden. The chess board size is 100*100.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4547980788530890883", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The chess board size is 45*45. There is a hole in position (1, 19). There is a hole in position (15, 9). There is a hole in position (13, 33). The square in position (16, 20) is forbidden. The square in position (14, 42) is forbidden. The square in position (13, 37) is forbidden. There is a hole in position (1, 24). There is a hole in position (1, 2).", "output": "size(45). forbidden(1,19). forbidden(1,2). forbidden(1,24). forbidden(13,33). forbidden(13,37). forbidden(14,42). forbidden(15,9). forbidden(16,20).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 45*45. There is a hole in position (1, 19). There is a hole in position (15, 9). There is a hole in position (13, 33). The square in position (16, 20) is forbidden. The square in position (14, 42) is forbidden. The square in position (13, 37) is forbidden. There is a hole in position (1, 24). There is a hole in position (1, 2).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "548115618684543554", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (18, 40) is forbidden. There is a hole in position (13, 23). There is a hole in position (16, 16). There is a hole in position (13, 42). The chess board size is 60*60. The square in position (11, 48) is forbidden. There is a hole in position (18, 30). There is a hole in position (18, 20). There is a hole in position (1, 18).", "output": "size(60). forbidden(1,18). forbidden(11,48). forbidden(13,23). forbidden(13,42). forbidden(16,16). forbidden(18,20). forbidden(18,30). forbidden(18,40).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (18, 40) is forbidden. There is a hole in position (13, 23). There is a hole in position (16, 16). There is a hole in position (13, 42). The chess board size is 60*60. The square in position (11, 48) is forbidden. There is a hole in position (18, 30). There is a hole in position (18, 20). There is a hole in position (1, 18).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8510619831613949669", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (25, 45). The square in position (27, 20) is forbidden. The square in position (11, 5) is forbidden. There is a hole in position (21, 14). The square in position (24, 5) is forbidden. The chess board size is 45*45. The square in position (40, 32) is forbidden. There is a hole in position (38, 26).", "output": "size(45). forbidden(11,5). forbidden(21,14). forbidden(24,5). forbidden(25,45). forbidden(27,20). forbidden(38,26). forbidden(40,32).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (25, 45). The square in position (27, 20) is forbidden. The square in position (11, 5) is forbidden. There is a hole in position (21, 14). The square in position (24, 5) is forbidden. The chess board size is 45*45. The square in position (40, 32) is forbidden. There is a hole in position (38, 26).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6862280170667319186", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (2, 37). The square in position (13, 33) is forbidden. There is a hole in position (10, 51). There is a hole in position (12, 48). The square in position (11, 49) is forbidden. The square in position (18, 60) is forbidden. The chess board size is 65*65. The square in position (19, 37) is forbidden. There is a hole in position (22, 11).", "output": "size(65). forbidden(10,51). forbidden(11,49). forbidden(12,48). forbidden(13,33). forbidden(18,60). forbidden(19,37). forbidden(2,37). forbidden(22,11).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (2, 37). The square in position (13, 33) is forbidden. There is a hole in position (10, 51). There is a hole in position (12, 48). The square in position (11, 49) is forbidden. The square in position (18, 60) is forbidden. The chess board size is 65*65. The square in position (19, 37) is forbidden. There is a hole in position (22, 11).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4771775438912799959", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (12, 23). The square in position (16, 24) is forbidden. There is a hole in position (10, 53). There is a hole in position (11, 46). There is a hole in position (11, 41). The chess board size is 60*60. The square in position (17, 5) is forbidden. The square in position (12, 22) is forbidden. There is a hole in position (10, 5).", "output": "size(60). forbidden(10,5). forbidden(10,53). forbidden(11,41). forbidden(11,46). forbidden(12,22). forbidden(12,23). forbidden(16,24). forbidden(17,5).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (12, 23). The square in position (16, 24) is forbidden. There is a hole in position (10, 53). There is a hole in position (11, 46). There is a hole in position (11, 41). The chess board size is 60*60. The square in position (17, 5) is forbidden. The square in position (12, 22) is forbidden. There is a hole in position (10, 5).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5123156147465161353", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (1, 20). The chess board size is 30*30. There is a hole in position (14, 10). The square in position (16, 6) is forbidden. The square in position (12, 15) is forbidden. The square in position (10, 11) is forbidden. The square in position (14, 23) is forbidden. There is a hole in position (10, 3). There is a hole in position (12, 26).", "output": "size(30). forbidden(1,20). forbidden(10,11). forbidden(10,3). forbidden(12,15). forbidden(12,26). forbidden(14,10). forbidden(14,23). forbidden(16,6).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (1, 20). The chess board size is 30*30. There is a hole in position (14, 10). The square in position (16, 6) is forbidden. The square in position (12, 15) is forbidden. The square in position (10, 11) is forbidden. The square in position (14, 23) is forbidden. There is a hole in position (10, 3). There is a hole in position (12, 26).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2035936201736883448", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (17, 24). The chess board size is 75*75. The square in position (10, 9) is forbidden. There is a hole in position (30, 14). The square in position (30, 20) is forbidden. There is a hole in position (18, 30). The square in position (13, 73) is forbidden. There is a hole in position (21, 31). There is a hole in position (10, 71).", "output": "size(75). forbidden(10,71). forbidden(10,9). forbidden(13,73). forbidden(17,24). forbidden(18,30). forbidden(21,31). forbidden(30,14). forbidden(30,20).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (17, 24). The chess board size is 75*75. The square in position (10, 9) is forbidden. There is a hole in position (30, 14). The square in position (30, 20) is forbidden. There is a hole in position (18, 30). The square in position (13, 73) is forbidden. There is a hole in position (21, 31). There is a hole in position (10, 71).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7652663007605013087", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (17, 20). The square in position (14, 11) is forbidden. There is a hole in position (15, 7). There is a hole in position (12, 7). The chess board size is 30*30. The square in position (15, 4) is forbidden. There is a hole in position (18, 30). There is a hole in position (11, 2). There is a hole in position (13, 27).", "output": "size(30). forbidden(11,2). forbidden(12,7). forbidden(13,27). forbidden(14,11). forbidden(15,4). forbidden(15,7). forbidden(17,20). forbidden(18,30).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (17, 20). The square in position (14, 11) is forbidden. There is a hole in position (15, 7). There is a hole in position (12, 7). The chess board size is 30*30. The square in position (15, 4) is forbidden. There is a hole in position (18, 30). There is a hole in position (11, 2). There is a hole in position (13, 27).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3018753439127117579", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (1, 17). The square in position (24, 29) is forbidden. The square in position (21, 38) is forbidden. The square in position (1, 8) is forbidden. The chess board size is 45*45. There is a hole in position (12, 35). The square in position (11, 20) is forbidden. The square in position (20, 12) is forbidden. The square in position (22, 18) is forbidden.", "output": "size(45). forbidden(1,17). forbidden(1,8). forbidden(11,20). forbidden(12,35). forbidden(20,12). forbidden(21,38). forbidden(22,18). forbidden(24,29).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (1, 17). The square in position (24, 29) is forbidden. The square in position (21, 38) is forbidden. The square in position (1, 8) is forbidden. The chess board size is 45*45. There is a hole in position (12, 35). The square in position (11, 20) is forbidden. The square in position (20, 12) is forbidden. The square in position (22, 18) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8966082971613613867", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (20, 27) is forbidden. There is a hole in position (14, 17). The chess board size is 60*60. The square in position (18, 44) is forbidden. The square in position (15, 3) is forbidden. The square in position (11, 27) is forbidden. There is a hole in position (2, 51). There is a hole in position (11, 2). There is a hole in position (16, 15).", "output": "size(60). forbidden(11,2). forbidden(11,27). forbidden(14,17). forbidden(15,3). forbidden(16,15). forbidden(18,44). forbidden(2,51). forbidden(20,27).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (20, 27) is forbidden. There is a hole in position (14, 17). The chess board size is 60*60. The square in position (18, 44) is forbidden. The square in position (15, 3) is forbidden. The square in position (11, 27) is forbidden. There is a hole in position (2, 51). There is a hole in position (11, 2). There is a hole in position (16, 15).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4132303132264019262", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (11, 49) is forbidden. There is a hole in position (14, 35). The square in position (1, 47) is forbidden. The square in position (16, 3) is forbidden. The square in position (15, 22) is forbidden. The square in position (18, 34) is forbidden. The chess board size is 55*55. The square in position (17, 13) is forbidden. There is a hole in position (18, 55).", "output": "size(55). forbidden(1,47). forbidden(11,49). forbidden(14,35). forbidden(15,22). forbidden(16,3). forbidden(17,13). forbidden(18,34). forbidden(18,55).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (11, 49) is forbidden. There is a hole in position (14, 35). The square in position (1, 47) is forbidden. The square in position (16, 3) is forbidden. The square in position (15, 22) is forbidden. The square in position (18, 34) is forbidden. The chess board size is 55*55. The square in position (17, 13) is forbidden. There is a hole in position (18, 55).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7727674001993635440", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (28, 47) is forbidden. There is a hole in position (17, 10). The square in position (15, 11) is forbidden. There is a hole in position (11, 68). There is a hole in position (13, 39). The square in position (25, 1) is forbidden. The chess board size is 95*95. There is a hole in position (15, 91). The square in position (14, 76) is forbidden.", "output": "size(95). forbidden(11,68). forbidden(13,39). forbidden(14,76). forbidden(15,11). forbidden(15,91). forbidden(17,10). forbidden(25,1). forbidden(28,47).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (28, 47) is forbidden. There is a hole in position (17, 10). The square in position (15, 11) is forbidden. There is a hole in position (11, 68). There is a hole in position (13, 39). The square in position (25, 1) is forbidden. The chess board size is 95*95. There is a hole in position (15, 91). The square in position (14, 76) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7922526261557460487", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (2, 36) is forbidden. The square in position (1, 38) is forbidden. The square in position (15, 72) is forbidden. There is a hole in position (20, 89). There is a hole in position (17, 10). There is a hole in position (17, 79). The chess board size is 90*90. There is a hole in position (13, 3). There is a hole in position (19, 57).", "output": "size(90). forbidden(1,38). forbidden(13,3). forbidden(15,72). forbidden(17,10). forbidden(17,79). forbidden(19,57). forbidden(2,36). forbidden(20,89).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (2, 36) is forbidden. The square in position (1, 38) is forbidden. The square in position (15, 72) is forbidden. There is a hole in position (20, 89). There is a hole in position (17, 10). There is a hole in position (17, 79). The chess board size is 90*90. There is a hole in position (13, 3). There is a hole in position (19, 57).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5654518683683344369", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (25, 74). There is a hole in position (25, 69). There is a hole in position (1, 26). The square in position (25, 64) is forbidden. There is a hole in position (12, 24). The chess board size is 95*95. The square in position (33, 8) is forbidden. The square in position (30, 88) is forbidden. The square in position (21, 74) is forbidden.", "output": "size(95). forbidden(1,26). forbidden(12,24). forbidden(21,74). forbidden(25,64). forbidden(25,69). forbidden(25,74). forbidden(30,88). forbidden(33,8).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (25, 74). There is a hole in position (25, 69). There is a hole in position (1, 26). The square in position (25, 64) is forbidden. There is a hole in position (12, 24). The chess board size is 95*95. The square in position (33, 8) is forbidden. The square in position (30, 88) is forbidden. The square in position (21, 74) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5961133095028299117", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (19, 16) is forbidden. The square in position (18, 13) is forbidden. There is a hole in position (1, 10). There is a hole in position (19, 42). The square in position (12, 21) is forbidden. There is a hole in position (1, 33). There is a hole in position (11, 44). The square in position (11, 69) is forbidden. The chess board size is 70*70.", "output": "size(70). forbidden(1,10). forbidden(1,33). forbidden(11,44). forbidden(11,69). forbidden(12,21). forbidden(18,13). forbidden(19,16). forbidden(19,42).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (19, 16) is forbidden. The square in position (18, 13) is forbidden. There is a hole in position (1, 10). There is a hole in position (19, 42). The square in position (12, 21) is forbidden. There is a hole in position (1, 33). There is a hole in position (11, 44). The square in position (11, 69) is forbidden. The chess board size is 70*70.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1642098416843445183", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The chess board size is 100*100. There is a hole in position (100, 43). The square in position (100, 92) is forbidden. The square in position (12, 20) is forbidden. There is a hole in position (11, 18). There is a hole in position (1, 16). There is a hole in position (12, 42). The square in position (10, 92) is forbidden. The square in position (10, 20) is forbidden.", "output": "size(100). forbidden(1,16). forbidden(10,20). forbidden(10,92). forbidden(100,43). forbidden(100,92). forbidden(11,18). forbidden(12,20). forbidden(12,42).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The chess board size is 100*100. There is a hole in position (100, 43). The square in position (100, 92) is forbidden. The square in position (12, 20) is forbidden. There is a hole in position (11, 18). There is a hole in position (1, 16). There is a hole in position (12, 42). The square in position (10, 92) is forbidden. The square in position (10, 20) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4634562180128978776", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (15, 40). The square in position (11, 74) is forbidden. There is a hole in position (12, 75). There is a hole in position (10, 11). There is a hole in position (1, 24). The square in position (1, 83) is forbidden. The chess board size is 95*95. There is a hole in position (12, 85). The square in position (10, 67) is forbidden.", "output": "size(95). forbidden(1,24). forbidden(1,83). forbidden(10,11). forbidden(10,67). forbidden(11,74). forbidden(12,75). forbidden(12,85). forbidden(15,40).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (15, 40). The square in position (11, 74) is forbidden. There is a hole in position (12, 75). There is a hole in position (10, 11). There is a hole in position (1, 24). The square in position (1, 83) is forbidden. The chess board size is 95*95. There is a hole in position (12, 85). The square in position (10, 67) is forbidden.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1794134720904964876", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "The square in position (11, 22) is forbidden. The square in position (19, 28) is forbidden. The square in position (12, 3) is forbidden. The square in position (10, 35) is forbidden. The chess board size is 35*35. The square in position (16, 17) is forbidden. The square in position (13, 33) is forbidden. There is a hole in position (15, 21). There is a hole in position (20, 3).", "output": "size(35). forbidden(10,35). forbidden(11,22). forbidden(12,3). forbidden(13,33). forbidden(15,21). forbidden(16,17). forbidden(19,28). forbidden(20,3).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```The square in position (11, 22) is forbidden. The square in position (19, 28) is forbidden. The square in position (12, 3) is forbidden. The square in position (10, 35) is forbidden. The chess board size is 35*35. The square in position (16, 17) is forbidden. The square in position (13, 33) is forbidden. There is a hole in position (15, 21). There is a hole in position (20, 3).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5150089252088752253", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (1, 36). There is a hole in position (11, 26). The chess board size is 60*60. The square in position (17, 15) is forbidden. There is a hole in position (18, 35). There is a hole in position (15, 56). The square in position (10, 10) is forbidden. The square in position (10, 14) is forbidden. There is a hole in position (19, 5).", "output": "size(60). forbidden(1,36). forbidden(10,10). forbidden(10,14). forbidden(11,26). forbidden(15,56). forbidden(17,15). forbidden(18,35). forbidden(19,5).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (1, 36). There is a hole in position (11, 26). The chess board size is 60*60. The square in position (17, 15) is forbidden. There is a hole in position (18, 35). There is a hole in position (15, 56). The square in position (10, 10) is forbidden. The square in position (10, 14) is forbidden. There is a hole in position (19, 5).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8188253934376021472", "problem_id": "46", "problem_name": "Knight Tour With Holes", "description": "Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.", "format": "The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.", "text": "There is a hole in position (29, 10). There is a hole in position (38, 8). There is a hole in position (28, 39). There is a hole in position (3, 28). The square in position (30, 4) is forbidden. The square in position (15, 34) is forbidden. The square in position (15, 10) is forbidden. The chess board size is 50*50. There is a hole in position (4, 5).", "output": "size(50). forbidden(15,10). forbidden(15,34). forbidden(28,39). forbidden(29,10). forbidden(3,28). forbidden(30,4). forbidden(38,8). forbidden(4,5).", "prompt": "Given the following problem description between triple backtips: \n ```Find a tour for the knight piece that starts at any square, travels all squares but the forbidden ones (representing holes on the board), and comes back to the origin, following the rules of chess.```\nGiven the following specification for the predicates format: \n```The input file contains one atom size(N), which states that the chess board size is N*N and a number of atoms forbidden(X1,Y1). The rows of the board are numbered 1, 2, and so on up to N from top to bottom, and the columns are numbered 1, 2, and so on up to N from left to right. Each square can thus be represented by a unique pair of coordinates.```\nExtract the datalog facts from this text: \n```There is a hole in position (29, 10). There is a hole in position (38, 8). There is a hole in position (28, 39). There is a hole in position (3, 28). The square in position (30, 4) is forbidden. The square in position (15, 34) is forbidden. The square in position (15, 10) is forbidden. The chess board size is 50*50. There is a hole in position (4, 5).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2395082714146636431", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the south: (1, 10), (1, 11), (1, 12), (1, 4), (1, 5), (1, 6), (1, 9), (10, 5). The following fields have connections to the north: (1, 11), (1, 12), (1, 3), (1, 6), (1, 9), (10, 13), (10, 3), (10, 5). The following fields have connections to the west: (1, 1), (1, 11), (1, 12), (1, 13), (1, 2), (1, 5), (1, 8), (1, 9). The fields of a quadratic 13x13 labyrinth are provided by instances of predicate \"field\" with values from 1 to 13 in both x and y coordinates. The goal field is positioned at (12, 10). You are allowed a maximum of thirteen pushes. The following fields have connections to the east: (1, 2), (1, 4), (1, 6), (1, 7), (1, 9), (10, 1), (10, 10), (10, 11). The starting location is (4, 1).", "output": "connect(1, 2, e). connect(1, 4, e). connect(1, 6, e). connect(1, 7, e). connect(1, 9, e). connect(10, 1, e). connect(10, 10, e). connect(10, 11, e). connect(1, 11, n). connect(1, 12, n). connect(1, 3, n). connect(1, 6, n). connect(1, 9, n). connect(10, 13, n). connect(10, 3, n). connect(10, 5, n). connect(1, 10, s). connect(1, 11, s). connect(1, 12, s). connect(1, 4, s). connect(1, 5, s). connect(1, 6, s). connect(1, 9, s). connect(10, 5, s). connect(1, 1, w). connect(1, 11, w). connect(1, 12, w). connect(1, 13, w). connect(1, 2, w). connect(1, 5, w). connect(1, 8, w). connect(1, 9, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(12,10). init_on(4,1). max_steps(13).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the south: (1, 10), (1, 11), (1, 12), (1, 4), (1, 5), (1, 6), (1, 9), (10, 5). The following fields have connections to the north: (1, 11), (1, 12), (1, 3), (1, 6), (1, 9), (10, 13), (10, 3), (10, 5). The following fields have connections to the west: (1, 1), (1, 11), (1, 12), (1, 13), (1, 2), (1, 5), (1, 8), (1, 9). The fields of a quadratic 13x13 labyrinth are provided by instances of predicate \"field\" with values from 1 to 13 in both x and y coordinates. The goal field is positioned at (12, 10). You are allowed a maximum of thirteen pushes. The following fields have connections to the east: (1, 2), (1, 4), (1, 6), (1, 7), (1, 9), (10, 1), (10, 10), (10, 11). The starting location is (4, 1).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8124289050540082888", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. The following fields have connections to the north: (1, 1), (1, 10), (1, 2), (1, 5), (1, 6), (10, 11), (10, 5), (10, 6). A maximum of eleven push/es is allowed. The starting field is at (2,3). The following fields have connections to the south: (1, 11), (1, 5), (1, 6), (10, 1), (10, 10), (10, 11), (10, 4), (10, 6). The following fields have connections to the west: (1, 3), (1, 4), (1, 5), (1, 6), (1, 8), (10, 10), (10, 11), (10, 7). The following fields have connections to the east: (1, 11), (1, 2), (1, 5), (1, 6), (1, 7), (1, 9), (10, 2), (10, 3). The goal field is placed at (11, 8).", "output": "connect(1, 11, e). connect(1, 2, e). connect(1, 5, e). connect(1, 6, e). connect(1, 7, e). connect(1, 9, e). connect(10, 2, e). connect(10, 3, e). connect(1, 1, n). connect(1, 10, n). connect(1, 2, n). connect(1, 5, n). connect(1, 6, n). connect(10, 11, n). connect(10, 5, n). connect(10, 6, n). connect(1, 11, s). connect(1, 5, s). connect(1, 6, s). connect(10, 1, s). connect(10, 10, s). connect(10, 11, s). connect(10, 4, s). connect(10, 6, s). connect(1, 3, w). connect(1, 4, w). connect(1, 5, w). connect(1, 6, w). connect(1, 8, w). connect(10, 10, w). connect(10, 11, w). connect(10, 7, w). field(1,1). field(1,10). field(1,11). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(2,1). field(2,10). field(2,11). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(11,8). init_on(2,3). max_steps(11).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. The following fields have connections to the north: (1, 1), (1, 10), (1, 2), (1, 5), (1, 6), (10, 11), (10, 5), (10, 6). A maximum of eleven push/es is allowed. The starting field is at (2,3). The following fields have connections to the south: (1, 11), (1, 5), (1, 6), (10, 1), (10, 10), (10, 11), (10, 4), (10, 6). The following fields have connections to the west: (1, 3), (1, 4), (1, 5), (1, 6), (1, 8), (10, 10), (10, 11), (10, 7). The following fields have connections to the east: (1, 11), (1, 2), (1, 5), (1, 6), (1, 7), (1, 9), (10, 2), (10, 3). The goal field is placed at (11, 8).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "392034151806606975", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the east: (1, 1), (1, 10), (1, 13), (1, 3), (1, 4), (1, 8), (1, 9), (10, 2). The coordinates for the starting position are (5,4). The goal field is positioned at (2, 3). The following fields have connections to the north: (1, 1), (1, 12), (1, 13), (1, 4), (1, 5), (1, 6), (1, 7), (10, 12). The following fields have connections to the west: (1, 10), (1, 11), (1, 12), (1, 2), (1, 4), (1, 7), (10, 1), (10, 10). The following fields have connections to the south: (1, 10), (1, 5), (1, 6), (1, 7), (10, 11), (10, 12), (10, 13), (10, 2). You are allowed a maximum of thirteen pushes. The fields of a quadratic 13x13 labyrinth are provided by instances of predicate \"field\" with values from 1 to 13 in both x and y coordinates.", "output": "connect(1, 1, e). connect(1, 10, e). connect(1, 13, e). connect(1, 3, e). connect(1, 4, e). connect(1, 8, e). connect(1, 9, e). connect(10, 2, e). connect(1, 1, n). connect(1, 12, n). connect(1, 13, n). connect(1, 4, n). connect(1, 5, n). connect(1, 6, n). connect(1, 7, n). connect(10, 12, n). connect(1, 10, s). connect(1, 5, s). connect(1, 6, s). connect(1, 7, s). connect(10, 11, s). connect(10, 12, s). connect(10, 13, s). connect(10, 2, s). connect(1, 10, w). connect(1, 11, w). connect(1, 12, w). connect(1, 2, w). connect(1, 4, w). connect(1, 7, w). connect(10, 1, w). connect(10, 10, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(2,3). init_on(5,4). max_steps(13).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the east: (1, 1), (1, 10), (1, 13), (1, 3), (1, 4), (1, 8), (1, 9), (10, 2). The coordinates for the starting position are (5,4). The goal field is positioned at (2, 3). The following fields have connections to the north: (1, 1), (1, 12), (1, 13), (1, 4), (1, 5), (1, 6), (1, 7), (10, 12). The following fields have connections to the west: (1, 10), (1, 11), (1, 12), (1, 2), (1, 4), (1, 7), (10, 1), (10, 10). The following fields have connections to the south: (1, 10), (1, 5), (1, 6), (1, 7), (10, 11), (10, 12), (10, 13), (10, 2). You are allowed a maximum of thirteen pushes. The fields of a quadratic 13x13 labyrinth are provided by instances of predicate \"field\" with values from 1 to 13 in both x and y coordinates.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5320824464146285262", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "A maximum of fourteen push/es is allowed. The starting point is located at (4,5). The goal field is located at position (14,6). The following fields have connections to the east: (1, 1), (1, 12), (1, 2), (1, 3), (1, 6), (1, 8), (1, 9), (10, 1). The following fields have connections to the south: (1, 12), (1, 3), (1, 4), (1, 6), (1, 7), (10, 1), (10, 10), (10, 11). The fields of a quadratic 14x14 labyrinth are provided by instances of predicate \"field\" with values from 1 to 14 in both x and y coordinates. The following fields have connections to the north: (1, 11), (1, 12), (1, 13), (1, 14), (1, 5), (1, 6), (1, 9), (10, 12). The following fields have connections to the west: (1, 10), (1, 11), (1, 14), (1, 2), (10, 1), (10, 10), (10, 12), (10, 13).", "output": "connect(1, 1, e). connect(1, 12, e). connect(1, 2, e). connect(1, 3, e). connect(1, 6, e). connect(1, 8, e). connect(1, 9, e). connect(10, 1, e). connect(1, 11, n). connect(1, 12, n). connect(1, 13, n). connect(1, 14, n). connect(1, 5, n). connect(1, 6, n). connect(1, 9, n). connect(10, 12, n). connect(1, 12, s). connect(1, 3, s). connect(1, 4, s). connect(1, 6, s). connect(1, 7, s). connect(10, 1, s). connect(10, 10, s). connect(10, 11, s). connect(1, 10, w). connect(1, 11, w). connect(1, 14, w). connect(1, 2, w). connect(10, 1, w). connect(10, 10, w). connect(10, 12, w). connect(10, 13, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(14,6). init_on(4,5). max_steps(14).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```A maximum of fourteen push/es is allowed. The starting point is located at (4,5). The goal field is located at position (14,6). The following fields have connections to the east: (1, 1), (1, 12), (1, 2), (1, 3), (1, 6), (1, 8), (1, 9), (10, 1). The following fields have connections to the south: (1, 12), (1, 3), (1, 4), (1, 6), (1, 7), (10, 1), (10, 10), (10, 11). The fields of a quadratic 14x14 labyrinth are provided by instances of predicate \"field\" with values from 1 to 14 in both x and y coordinates. The following fields have connections to the north: (1, 11), (1, 12), (1, 13), (1, 14), (1, 5), (1, 6), (1, 9), (10, 12). The following fields have connections to the west: (1, 10), (1, 11), (1, 14), (1, 2), (10, 1), (10, 10), (10, 12), (10, 13).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1356761636850509219", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The coordinates for the starting position are (7,7). The fields of a quadratic 17x17 labyrinth are provided by instances of predicate \"field\" with values from 1 to 17 in both x and y coordinates. The goal field is located at position (15,15). The following fields have connections to the north: (1, 12), (1, 14), (1, 15), (1, 17), (1, 8), (1, 9), (10, 11), (10, 14). No more than seventeen push/es are permitted. The following fields have connections to the west: (1, 1), (1, 13), (1, 14), (1, 16), (1, 17), (1, 4), (1, 6), (1, 7). The following fields have connections to the south: (1, 15), (1, 3), (1, 4), (10, 1), (10, 10), (10, 16), (11, 1), (11, 12). The following fields have connections to the east: (1, 10), (1, 11), (1, 14), (1, 15), (1, 2), (1, 4), (1, 5), (1, 8).", "output": "connect(1, 10, e). connect(1, 11, e). connect(1, 14, e). connect(1, 15, e). connect(1, 2, e). connect(1, 4, e). connect(1, 5, e). connect(1, 8, e). connect(1, 12, n). connect(1, 14, n). connect(1, 15, n). connect(1, 17, n). connect(1, 8, n). connect(1, 9, n). connect(10, 11, n). connect(10, 14, n). connect(1, 15, s). connect(1, 3, s). connect(1, 4, s). connect(10, 1, s). connect(10, 10, s). connect(10, 16, s). connect(11, 1, s). connect(11, 12, s). connect(1, 1, w). connect(1, 13, w). connect(1, 14, w). connect(1, 16, w). connect(1, 17, w). connect(1, 4, w). connect(1, 6, w). connect(1, 7, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,2). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(15,15). init_on(7,7). max_steps(17).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The coordinates for the starting position are (7,7). The fields of a quadratic 17x17 labyrinth are provided by instances of predicate \"field\" with values from 1 to 17 in both x and y coordinates. The goal field is located at position (15,15). The following fields have connections to the north: (1, 12), (1, 14), (1, 15), (1, 17), (1, 8), (1, 9), (10, 11), (10, 14). No more than seventeen push/es are permitted. The following fields have connections to the west: (1, 1), (1, 13), (1, 14), (1, 16), (1, 17), (1, 4), (1, 6), (1, 7). The following fields have connections to the south: (1, 15), (1, 3), (1, 4), (10, 1), (10, 10), (10, 16), (11, 1), (11, 12). The following fields have connections to the east: (1, 10), (1, 11), (1, 14), (1, 15), (1, 2), (1, 4), (1, 5), (1, 8).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4286680506760693590", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The fields of a quadratic 19x19 labyrinth are provided by instances of predicate \"field\" with values from 1 to 19 in both x and y coordinates. The coordinates for the starting position are (17,4). The following fields have connections to the east: (1, 10), (1, 11), (1, 14), (1, 16), (1, 3), (1, 4), (1, 5), (1, 7). The following fields have connections to the north: (1, 11), (1, 12), (1, 14), (1, 15), (1, 18), (1, 19), (1, 2), (1, 4). The following fields have connections to the west: (1, 1), (1, 12), (1, 13), (1, 14), (1, 16), (1, 17), (1, 3), (1, 6). The goal field is located at position (2,2). The following fields have connections to the south: (1, 12), (1, 16), (1, 17), (1, 4), (1, 6), (1, 7), (1, 9), (10, 10). No more than nineteen push/es are permitted.", "output": "connect(1, 10, e). connect(1, 11, e). connect(1, 14, e). connect(1, 16, e). connect(1, 3, e). connect(1, 4, e). connect(1, 5, e). connect(1, 7, e). connect(1, 11, n). connect(1, 12, n). connect(1, 14, n). connect(1, 15, n). connect(1, 18, n). connect(1, 19, n). connect(1, 2, n). connect(1, 4, n). connect(1, 12, s). connect(1, 16, s). connect(1, 17, s). connect(1, 4, s). connect(1, 6, s). connect(1, 7, s). connect(1, 9, s). connect(10, 10, s). connect(1, 1, w). connect(1, 12, w). connect(1, 13, w). connect(1, 14, w). connect(1, 16, w). connect(1, 17, w). connect(1, 3, w). connect(1, 6, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(2,2). init_on(17,4). max_steps(19).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The fields of a quadratic 19x19 labyrinth are provided by instances of predicate \"field\" with values from 1 to 19 in both x and y coordinates. The coordinates for the starting position are (17,4). The following fields have connections to the east: (1, 10), (1, 11), (1, 14), (1, 16), (1, 3), (1, 4), (1, 5), (1, 7). The following fields have connections to the north: (1, 11), (1, 12), (1, 14), (1, 15), (1, 18), (1, 19), (1, 2), (1, 4). The following fields have connections to the west: (1, 1), (1, 12), (1, 13), (1, 14), (1, 16), (1, 17), (1, 3), (1, 6). The goal field is located at position (2,2). The following fields have connections to the south: (1, 12), (1, 16), (1, 17), (1, 4), (1, 6), (1, 7), (1, 9), (10, 10). No more than nineteen push/es are permitted.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7985017635674338878", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "At most thirteen pushes are permitted. The fields of a quadratic 13x13 labyrinth are provided by instances of predicate \"field\" with values from 1 to 13 in both x and y coordinates. The starting coordinates are (2,12). The following fields have connections to the east: (1, 10), (1, 11), (1, 12), (1, 2), (1, 3), (1, 8), (10, 10), (10, 13). The following fields have connections to the west: (1, 10), (1, 12), (1, 13), (1, 2), (1, 6), (1, 7), (1, 8), (10, 1). The goal field is located at position (1,6). The following fields have connections to the south: (1, 1), (1, 10), (1, 13), (1, 2), (1, 3), (1, 4), (1, 5), (1, 8). The following fields have connections to the north: (1, 1), (1, 10), (1, 12), (1, 2), (1, 3), (1, 9), (10, 1), (10, 10).", "output": "connect(1, 10, e). connect(1, 11, e). connect(1, 12, e). connect(1, 2, e). connect(1, 3, e). connect(1, 8, e). connect(10, 10, e). connect(10, 13, e). connect(1, 1, n). connect(1, 10, n). connect(1, 12, n). connect(1, 2, n). connect(1, 3, n). connect(1, 9, n). connect(10, 1, n). connect(10, 10, n). connect(1, 1, s). connect(1, 10, s). connect(1, 13, s). connect(1, 2, s). connect(1, 3, s). connect(1, 4, s). connect(1, 5, s). connect(1, 8, s). connect(1, 10, w). connect(1, 12, w). connect(1, 13, w). connect(1, 2, w). connect(1, 6, w). connect(1, 7, w). connect(1, 8, w). connect(10, 1, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(1,6). init_on(2,12). max_steps(13).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```At most thirteen pushes are permitted. The fields of a quadratic 13x13 labyrinth are provided by instances of predicate \"field\" with values from 1 to 13 in both x and y coordinates. The starting coordinates are (2,12). The following fields have connections to the east: (1, 10), (1, 11), (1, 12), (1, 2), (1, 3), (1, 8), (10, 10), (10, 13). The following fields have connections to the west: (1, 10), (1, 12), (1, 13), (1, 2), (1, 6), (1, 7), (1, 8), (10, 1). The goal field is located at position (1,6). The following fields have connections to the south: (1, 1), (1, 10), (1, 13), (1, 2), (1, 3), (1, 4), (1, 5), (1, 8). The following fields have connections to the north: (1, 1), (1, 10), (1, 12), (1, 2), (1, 3), (1, 9), (10, 1), (10, 10).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6218445201565514428", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The starting field is at (14,6). You are allowed a maximum of fifteen pushes. The fields of a quadratic 15x15 labyrinth are provided by instances of predicate \"field\" with values from 1 to 15 in both x and y coordinates. The following fields have connections to the north: (1, 1), (1, 14), (1, 15), (1, 2), (1, 3), (1, 5), (1, 8), (1, 9). The following fields have connections to the east: (1, 10), (1, 12), (1, 3), (1, 4), (10, 1), (10, 12), (10, 4), (10, 8). The following fields have connections to the west: (1, 10), (1, 13), (1, 4), (1, 7), (1, 8), (10, 13), (10, 14), (10, 15). The goal field is positioned at (13, 10). The following fields have connections to the south: (1, 1), (1, 11), (1, 14), (1, 15), (1, 2), (1, 6), (10, 10), (10, 12).", "output": "connect(1, 10, e). connect(1, 12, e). connect(1, 3, e). connect(1, 4, e). connect(10, 1, e). connect(10, 12, e). connect(10, 4, e). connect(10, 8, e). connect(1, 1, n). connect(1, 14, n). connect(1, 15, n). connect(1, 2, n). connect(1, 3, n). connect(1, 5, n). connect(1, 8, n). connect(1, 9, n). connect(1, 1, s). connect(1, 11, s). connect(1, 14, s). connect(1, 15, s). connect(1, 2, s). connect(1, 6, s). connect(10, 10, s). connect(10, 12, s). connect(1, 10, w). connect(1, 13, w). connect(1, 4, w). connect(1, 7, w). connect(1, 8, w). connect(10, 13, w). connect(10, 14, w). connect(10, 15, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(13,10). init_on(14,6). max_steps(15).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The starting field is at (14,6). You are allowed a maximum of fifteen pushes. The fields of a quadratic 15x15 labyrinth are provided by instances of predicate \"field\" with values from 1 to 15 in both x and y coordinates. The following fields have connections to the north: (1, 1), (1, 14), (1, 15), (1, 2), (1, 3), (1, 5), (1, 8), (1, 9). The following fields have connections to the east: (1, 10), (1, 12), (1, 3), (1, 4), (10, 1), (10, 12), (10, 4), (10, 8). The following fields have connections to the west: (1, 10), (1, 13), (1, 4), (1, 7), (1, 8), (10, 13), (10, 14), (10, 15). The goal field is positioned at (13, 10). The following fields have connections to the south: (1, 1), (1, 11), (1, 14), (1, 15), (1, 2), (1, 6), (10, 10), (10, 12).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3154763554766578971", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 1), (1, 11), (1, 12), (1, 15), (1, 19), (1, 2), (1, 20), (1, 22). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. You are allowed a maximum of twenty-two pushes. The following fields have connections to the east: (1, 1), (1, 11), (1, 13), (1, 22), (1, 3), (1, 5), (1, 6), (10, 11). The following fields have connections to the south: (1, 1), (1, 10), (1, 13), (1, 15), (1, 17), (1, 19), (1, 20), (1, 21). The starting point is located at (5,19). The following fields have connections to the north: (1, 1), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16). The goal field can be found at position (8, 12).", "output": "connect(1, 1, e). connect(1, 11, e). connect(1, 13, e). connect(1, 22, e). connect(1, 3, e). connect(1, 5, e). connect(1, 6, e). connect(10, 11, e). connect(1, 1, n). connect(1, 10, n). connect(1, 11, n). connect(1, 12, n). connect(1, 13, n). connect(1, 14, n). connect(1, 15, n). connect(1, 16, n). connect(1, 1, s). connect(1, 10, s). connect(1, 13, s). connect(1, 15, s). connect(1, 17, s). connect(1, 19, s). connect(1, 20, s). connect(1, 21, s). connect(1, 1, w). connect(1, 11, w). connect(1, 12, w). connect(1, 15, w). connect(1, 19, w). connect(1, 2, w). connect(1, 20, w). connect(1, 22, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,21). field(1,22). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,21). field(10,22). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,21). field(11,22). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,21). field(12,22). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,21). field(13,22). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,21). field(14,22). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,21). field(15,22). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,21). field(16,22). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,21). field(17,22). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,21). field(18,22). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,21). field(19,22). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,21). field(2,22). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,21). field(20,22). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(21,1). field(21,10). field(21,11). field(21,12). field(21,13). field(21,14). field(21,15). field(21,16). field(21,17). field(21,18). field(21,19). field(21,2). field(21,20). field(21,21). field(21,22). field(21,3). field(21,4). field(21,5). field(21,6). field(21,7). field(21,8). field(21,9). field(22,1). field(22,10). field(22,11). field(22,12). field(22,13). field(22,14). field(22,15). field(22,16). field(22,17). field(22,18). field(22,19). field(22,2). field(22,20). field(22,21). field(22,22). field(22,3). field(22,4). field(22,5). field(22,6). field(22,7). field(22,8). field(22,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,21). field(3,22). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,21). field(4,22). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,21). field(5,22). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,21). field(6,22). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,21). field(7,22). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,21). field(8,22). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,21). field(9,22). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(8,12). init_on(5,19). max_steps(22).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 1), (1, 11), (1, 12), (1, 15), (1, 19), (1, 2), (1, 20), (1, 22). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. You are allowed a maximum of twenty-two pushes. The following fields have connections to the east: (1, 1), (1, 11), (1, 13), (1, 22), (1, 3), (1, 5), (1, 6), (10, 11). The following fields have connections to the south: (1, 1), (1, 10), (1, 13), (1, 15), (1, 17), (1, 19), (1, 20), (1, 21). The starting point is located at (5,19). The following fields have connections to the north: (1, 1), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16). The goal field can be found at position (8, 12).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5412765273048563844", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 1), (1, 5), (1, 6), (1, 7), (10, 1), (10, 3), (11, 10), (11, 11). The following fields have connections to the east: (1, 11), (1, 3), (1, 7), (1, 8), (10, 10), (10, 2), (10, 5), (10, 8). The starting field is at (8,10). The following fields have connections to the north: (1, 10), (1, 11), (1, 2), (1, 4), (1, 6), (1, 7), (1, 9), (10, 1). The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. A maximum of eleven push/es is allowed. The goal field is located at position (11,3). The following fields have connections to the south: (1, 1), (1, 7), (10, 1), (10, 11), (10, 5), (10, 8), (11, 3), (11, 6).", "output": "connect(1, 11, e). connect(1, 3, e). connect(1, 7, e). connect(1, 8, e). connect(10, 10, e). connect(10, 2, e). connect(10, 5, e). connect(10, 8, e). connect(1, 10, n). connect(1, 11, n). connect(1, 2, n). connect(1, 4, n). connect(1, 6, n). connect(1, 7, n). connect(1, 9, n). connect(10, 1, n). connect(1, 1, s). connect(1, 7, s). connect(10, 1, s). connect(10, 11, s). connect(10, 5, s). connect(10, 8, s). connect(11, 3, s). connect(11, 6, s). connect(1, 1, w). connect(1, 5, w). connect(1, 6, w). connect(1, 7, w). connect(10, 1, w). connect(10, 3, w). connect(11, 10, w). connect(11, 11, w). field(1,1). field(1,10). field(1,11). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(2,1). field(2,10). field(2,11). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(11,3). init_on(8,10). max_steps(11).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 1), (1, 5), (1, 6), (1, 7), (10, 1), (10, 3), (11, 10), (11, 11). The following fields have connections to the east: (1, 11), (1, 3), (1, 7), (1, 8), (10, 10), (10, 2), (10, 5), (10, 8). The starting field is at (8,10). The following fields have connections to the north: (1, 10), (1, 11), (1, 2), (1, 4), (1, 6), (1, 7), (1, 9), (10, 1). The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. A maximum of eleven push/es is allowed. The goal field is located at position (11,3). The following fields have connections to the south: (1, 1), (1, 7), (10, 1), (10, 11), (10, 5), (10, 8), (11, 3), (11, 6).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4124594176445095682", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The starting point is located at (5,21). The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 12), (1, 19), (1, 2), (1, 22), (1, 6). The following fields have connections to the west: (1, 1), (1, 10), (1, 13), (1, 14), (1, 20), (1, 21), (1, 3), (1, 5). The goal field is located at position (5,10). The following fields have connections to the east: (1, 1), (1, 10), (1, 15), (1, 16), (1, 17), (1, 19), (1, 2), (1, 7). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. No more than twenty-two push/es are permitted. The following fields have connections to the north: (1, 1), (1, 10), (1, 12), (1, 17), (1, 18), (1, 4), (10, 12), (10, 15).", "output": "connect(1, 1, e). connect(1, 10, e). connect(1, 15, e). connect(1, 16, e). connect(1, 17, e). connect(1, 19, e). connect(1, 2, e). connect(1, 7, e). connect(1, 1, n). connect(1, 10, n). connect(1, 12, n). connect(1, 17, n). connect(1, 18, n). connect(1, 4, n). connect(10, 12, n). connect(10, 15, n). connect(1, 1, s). connect(1, 10, s). connect(1, 11, s). connect(1, 12, s). connect(1, 19, s). connect(1, 2, s). connect(1, 22, s). connect(1, 6, s). connect(1, 1, w). connect(1, 10, w). connect(1, 13, w). connect(1, 14, w). connect(1, 20, w). connect(1, 21, w). connect(1, 3, w). connect(1, 5, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,21). field(1,22). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,21). field(10,22). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,21). field(11,22). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,21). field(12,22). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,21). field(13,22). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,21). field(14,22). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,21). field(15,22). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,21). field(16,22). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,21). field(17,22). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,21). field(18,22). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,21). field(19,22). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,21). field(2,22). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,21). field(20,22). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(21,1). field(21,10). field(21,11). field(21,12). field(21,13). field(21,14). field(21,15). field(21,16). field(21,17). field(21,18). field(21,19). field(21,2). field(21,20). field(21,21). field(21,22). field(21,3). field(21,4). field(21,5). field(21,6). field(21,7). field(21,8). field(21,9). field(22,1). field(22,10). field(22,11). field(22,12). field(22,13). field(22,14). field(22,15). field(22,16). field(22,17). field(22,18). field(22,19). field(22,2). field(22,20). field(22,21). field(22,22). field(22,3). field(22,4). field(22,5). field(22,6). field(22,7). field(22,8). field(22,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,21). field(3,22). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,21). field(4,22). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,21). field(5,22). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,21). field(6,22). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,21). field(7,22). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,21). field(8,22). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,21). field(9,22). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(5,10). init_on(5,21). max_steps(22).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The starting point is located at (5,21). The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 12), (1, 19), (1, 2), (1, 22), (1, 6). The following fields have connections to the west: (1, 1), (1, 10), (1, 13), (1, 14), (1, 20), (1, 21), (1, 3), (1, 5). The goal field is located at position (5,10). The following fields have connections to the east: (1, 1), (1, 10), (1, 15), (1, 16), (1, 17), (1, 19), (1, 2), (1, 7). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. No more than twenty-two push/es are permitted. The following fields have connections to the north: (1, 1), (1, 10), (1, 12), (1, 17), (1, 18), (1, 4), (10, 12), (10, 15).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5385872862228048871", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the south: (1, 11), (1, 14), (1, 15), (1, 6), (1, 8), (1, 9), (10, 1), (10, 14). The starting coordinates are (1,8). The following fields have connections to the west: (1, 10), (1, 13), (1, 14), (1, 4), (1, 6), (1, 8), (10, 1), (10, 10). The fields of a quadratic 16x16 labyrinth are provided by instances of predicate \"field\" with values from 1 to 16 in both x and y coordinates. The following fields have connections to the north: (1, 10), (1, 12), (1, 13), (1, 14), (1, 15), (1, 7), (1, 8), (10, 1). The following fields have connections to the east: (1, 1), (1, 10), (1, 11), (1, 13), (1, 14), (1, 15), (1, 16), (1, 2). The goal field can be found at position (13, 14). At most sixteen pushes are permitted.", "output": "connect(1, 1, e). connect(1, 10, e). connect(1, 11, e). connect(1, 13, e). connect(1, 14, e). connect(1, 15, e). connect(1, 16, e). connect(1, 2, e). connect(1, 10, n). connect(1, 12, n). connect(1, 13, n). connect(1, 14, n). connect(1, 15, n). connect(1, 7, n). connect(1, 8, n). connect(10, 1, n). connect(1, 11, s). connect(1, 14, s). connect(1, 15, s). connect(1, 6, s). connect(1, 8, s). connect(1, 9, s). connect(10, 1, s). connect(10, 14, s). connect(1, 10, w). connect(1, 13, w). connect(1, 14, w). connect(1, 4, w). connect(1, 6, w). connect(1, 8, w). connect(10, 1, w). connect(10, 10, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(13,14). init_on(1,8). max_steps(16).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the south: (1, 11), (1, 14), (1, 15), (1, 6), (1, 8), (1, 9), (10, 1), (10, 14). The starting coordinates are (1,8). The following fields have connections to the west: (1, 10), (1, 13), (1, 14), (1, 4), (1, 6), (1, 8), (10, 1), (10, 10). The fields of a quadratic 16x16 labyrinth are provided by instances of predicate \"field\" with values from 1 to 16 in both x and y coordinates. The following fields have connections to the north: (1, 10), (1, 12), (1, 13), (1, 14), (1, 15), (1, 7), (1, 8), (10, 1). The following fields have connections to the east: (1, 1), (1, 10), (1, 11), (1, 13), (1, 14), (1, 15), (1, 16), (1, 2). The goal field can be found at position (13, 14). At most sixteen pushes are permitted.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "816399943547084988", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 13), (1, 14), (1, 18), (1, 3), (1, 7), (10, 10), (10, 14), (10, 15). The coordinates for the starting position are (11,14). The fields of a quadratic 18x18 labyrinth are provided by instances of predicate \"field\" with values from 1 to 18 in both x and y coordinates. At most eighteen pushes are permitted. The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 15), (1, 16), (1, 17), (1, 18), (1, 2). The following fields have connections to the north: (1, 1), (1, 10), (1, 15), (1, 16), (1, 3), (1, 7), (10, 1), (10, 11). The goal field is positioned at (10, 9). The following fields have connections to the east: (1, 12), (1, 4), (1, 5), (1, 6), (1, 7), (1, 9), (10, 10), (10, 11).", "output": "connect(1, 12, e). connect(1, 4, e). connect(1, 5, e). connect(1, 6, e). connect(1, 7, e). connect(1, 9, e). connect(10, 10, e). connect(10, 11, e). connect(1, 1, n). connect(1, 10, n). connect(1, 15, n). connect(1, 16, n). connect(1, 3, n). connect(1, 7, n). connect(10, 1, n). connect(10, 11, n). connect(1, 1, s). connect(1, 10, s). connect(1, 11, s). connect(1, 15, s). connect(1, 16, s). connect(1, 17, s). connect(1, 18, s). connect(1, 2, s). connect(1, 13, w). connect(1, 14, w). connect(1, 18, w). connect(1, 3, w). connect(1, 7, w). connect(10, 10, w). connect(10, 14, w). connect(10, 15, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,2). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,2). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(10,9). init_on(11,14). max_steps(18).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 13), (1, 14), (1, 18), (1, 3), (1, 7), (10, 10), (10, 14), (10, 15). The coordinates for the starting position are (11,14). The fields of a quadratic 18x18 labyrinth are provided by instances of predicate \"field\" with values from 1 to 18 in both x and y coordinates. At most eighteen pushes are permitted. The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 15), (1, 16), (1, 17), (1, 18), (1, 2). The following fields have connections to the north: (1, 1), (1, 10), (1, 15), (1, 16), (1, 3), (1, 7), (10, 1), (10, 11). The goal field is positioned at (10, 9). The following fields have connections to the east: (1, 12), (1, 4), (1, 5), (1, 6), (1, 7), (1, 9), (10, 10), (10, 11).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7836419909906720594", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The starting coordinates are (6,9). The following fields have connections to the west: (1, 3), (1, 5), (1, 8), (10, 8), (11, 10), (11, 2), (11, 5), (11, 6). The following fields have connections to the east: (1, 10), (1, 6), (1, 8), (1, 9), (10, 1), (10, 11), (10, 3), (10, 6). The following fields have connections to the north: (1, 11), (1, 4), (1, 7), (1, 8), (1, 9), (10, 1), (10, 10), (10, 4). The goal field is located at position (6,8). The following fields have connections to the south: (1, 1), (1, 2), (1, 3), (1, 8), (10, 2), (10, 5), (10, 7), (11, 2). The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. No more than eleven push/es are permitted.", "output": "connect(1, 10, e). connect(1, 6, e). connect(1, 8, e). connect(1, 9, e). connect(10, 1, e). connect(10, 11, e). connect(10, 3, e). connect(10, 6, e). connect(1, 11, n). connect(1, 4, n). connect(1, 7, n). connect(1, 8, n). connect(1, 9, n). connect(10, 1, n). connect(10, 10, n). connect(10, 4, n). connect(1, 1, s). connect(1, 2, s). connect(1, 3, s). connect(1, 8, s). connect(10, 2, s). connect(10, 5, s). connect(10, 7, s). connect(11, 2, s). connect(1, 3, w). connect(1, 5, w). connect(1, 8, w). connect(10, 8, w). connect(11, 10, w). connect(11, 2, w). connect(11, 5, w). connect(11, 6, w). field(1,1). field(1,10). field(1,11). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(2,1). field(2,10). field(2,11). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(6,8). init_on(6,9). max_steps(11).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The starting coordinates are (6,9). The following fields have connections to the west: (1, 3), (1, 5), (1, 8), (10, 8), (11, 10), (11, 2), (11, 5), (11, 6). The following fields have connections to the east: (1, 10), (1, 6), (1, 8), (1, 9), (10, 1), (10, 11), (10, 3), (10, 6). The following fields have connections to the north: (1, 11), (1, 4), (1, 7), (1, 8), (1, 9), (10, 1), (10, 10), (10, 4). The goal field is located at position (6,8). The following fields have connections to the south: (1, 1), (1, 2), (1, 3), (1, 8), (10, 2), (10, 5), (10, 7), (11, 2). The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. No more than eleven push/es are permitted.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3718481565935979971", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 14), (1, 15), (1, 16), (1, 19), (1, 20), (1, 21), (1, 22), (1, 3). The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 16), (1, 19), (1, 2), (1, 22), (1, 4). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. No more than twenty-two push/es are permitted. The starting point is located at (6,10). The following fields have connections to the north: (1, 10), (1, 12), (1, 13), (1, 15), (1, 16), (1, 17), (1, 18), (1, 20). The goal field is located at position (20,19). The following fields have connections to the east: (1, 15), (1, 16), (1, 2), (1, 3), (1, 4), (1, 7), (1, 9), (10, 10).", "output": "connect(1, 15, e). connect(1, 16, e). connect(1, 2, e). connect(1, 3, e). connect(1, 4, e). connect(1, 7, e). connect(1, 9, e). connect(10, 10, e). connect(1, 10, n). connect(1, 12, n). connect(1, 13, n). connect(1, 15, n). connect(1, 16, n). connect(1, 17, n). connect(1, 18, n). connect(1, 20, n). connect(1, 1, s). connect(1, 10, s). connect(1, 11, s). connect(1, 16, s). connect(1, 19, s). connect(1, 2, s). connect(1, 22, s). connect(1, 4, s). connect(1, 14, w). connect(1, 15, w). connect(1, 16, w). connect(1, 19, w). connect(1, 20, w). connect(1, 21, w). connect(1, 22, w). connect(1, 3, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,21). field(1,22). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,21). field(10,22). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,21). field(11,22). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,21). field(12,22). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,21). field(13,22). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,21). field(14,22). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,21). field(15,22). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,21). field(16,22). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,21). field(17,22). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,21). field(18,22). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,21). field(19,22). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,21). field(2,22). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,21). field(20,22). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(21,1). field(21,10). field(21,11). field(21,12). field(21,13). field(21,14). field(21,15). field(21,16). field(21,17). field(21,18). field(21,19). field(21,2). field(21,20). field(21,21). field(21,22). field(21,3). field(21,4). field(21,5). field(21,6). field(21,7). field(21,8). field(21,9). field(22,1). field(22,10). field(22,11). field(22,12). field(22,13). field(22,14). field(22,15). field(22,16). field(22,17). field(22,18). field(22,19). field(22,2). field(22,20). field(22,21). field(22,22). field(22,3). field(22,4). field(22,5). field(22,6). field(22,7). field(22,8). field(22,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,21). field(3,22). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,21). field(4,22). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,21). field(5,22). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,21). field(6,22). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,21). field(7,22). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,21). field(8,22). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,21). field(9,22). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(20,19). init_on(6,10). max_steps(22).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 14), (1, 15), (1, 16), (1, 19), (1, 20), (1, 21), (1, 22), (1, 3). The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 16), (1, 19), (1, 2), (1, 22), (1, 4). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. No more than twenty-two push/es are permitted. The starting point is located at (6,10). The following fields have connections to the north: (1, 10), (1, 12), (1, 13), (1, 15), (1, 16), (1, 17), (1, 18), (1, 20). The goal field is located at position (20,19). The following fields have connections to the east: (1, 15), (1, 16), (1, 2), (1, 3), (1, 4), (1, 7), (1, 9), (10, 10).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2453598286518315127", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. The following fields have connections to the north: (1, 10), (1, 2), (1, 5), (1, 7), (10, 2), (10, 5), (10, 7), (10, 8). The goal field is located at position (8,10). The following fields have connections to the south: (1, 1), (1, 2), (1, 5), (1, 6), (1, 9), (10, 1), (10, 4), (10, 5). The following fields have connections to the east: (1, 10), (1, 11), (1, 4), (1, 6), (10, 10), (10, 11), (10, 3), (10, 5). The starting location is (7, 6). The following fields have connections to the west: (1, 10), (1, 2), (1, 3), (1, 8), (10, 1), (10, 3), (10, 5), (10, 6). No more than eleven push/es are permitted.", "output": "connect(1, 10, e). connect(1, 11, e). connect(1, 4, e). connect(1, 6, e). connect(10, 10, e). connect(10, 11, e). connect(10, 3, e). connect(10, 5, e). connect(1, 10, n). connect(1, 2, n). connect(1, 5, n). connect(1, 7, n). connect(10, 2, n). connect(10, 5, n). connect(10, 7, n). connect(10, 8, n). connect(1, 1, s). connect(1, 2, s). connect(1, 5, s). connect(1, 6, s). connect(1, 9, s). connect(10, 1, s). connect(10, 4, s). connect(10, 5, s). connect(1, 10, w). connect(1, 2, w). connect(1, 3, w). connect(1, 8, w). connect(10, 1, w). connect(10, 3, w). connect(10, 5, w). connect(10, 6, w). field(1,1). field(1,10). field(1,11). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(2,1). field(2,10). field(2,11). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(8,10). init_on(7,6). max_steps(11).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. The following fields have connections to the north: (1, 10), (1, 2), (1, 5), (1, 7), (10, 2), (10, 5), (10, 7), (10, 8). The goal field is located at position (8,10). The following fields have connections to the south: (1, 1), (1, 2), (1, 5), (1, 6), (1, 9), (10, 1), (10, 4), (10, 5). The following fields have connections to the east: (1, 10), (1, 11), (1, 4), (1, 6), (10, 10), (10, 11), (10, 3), (10, 5). The starting location is (7, 6). The following fields have connections to the west: (1, 10), (1, 2), (1, 3), (1, 8), (10, 1), (10, 3), (10, 5), (10, 6). No more than eleven push/es are permitted.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "287475845078787886", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. The following fields have connections to the south: (1, 1), (1, 10), (1, 2), (1, 5), (1, 6), (1, 8), (1, 9), (10, 10). The starting location is (6, 4). The following fields have connections to the north: (1, 11), (1, 5), (1, 6), (1, 8), (1, 9), (10, 1), (10, 2), (10, 3). The following fields have connections to the west: (1, 1), (1, 10), (1, 2), (1, 4), (1, 8), (10, 11), (10, 2), (10, 3). No more than eleven push/es are permitted. The following fields have connections to the east: (1, 10), (1, 2), (1, 3), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9). The goal field can be found at position (3, 7).", "output": "connect(1, 10, e). connect(1, 2, e). connect(1, 3, e). connect(1, 5, e). connect(1, 6, e). connect(1, 7, e). connect(1, 8, e). connect(1, 9, e). connect(1, 11, n). connect(1, 5, n). connect(1, 6, n). connect(1, 8, n). connect(1, 9, n). connect(10, 1, n). connect(10, 2, n). connect(10, 3, n). connect(1, 1, s). connect(1, 10, s). connect(1, 2, s). connect(1, 5, s). connect(1, 6, s). connect(1, 8, s). connect(1, 9, s). connect(10, 10, s). connect(1, 1, w). connect(1, 10, w). connect(1, 2, w). connect(1, 4, w). connect(1, 8, w). connect(10, 11, w). connect(10, 2, w). connect(10, 3, w). field(1,1). field(1,10). field(1,11). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(2,1). field(2,10). field(2,11). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(3,7). init_on(6,4). max_steps(11).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The fields of a quadratic 11x11 labyrinth are provided by instances of predicate \"field\" with values from 1 to 11 in both x and y coordinates. The following fields have connections to the south: (1, 1), (1, 10), (1, 2), (1, 5), (1, 6), (1, 8), (1, 9), (10, 10). The starting location is (6, 4). The following fields have connections to the north: (1, 11), (1, 5), (1, 6), (1, 8), (1, 9), (10, 1), (10, 2), (10, 3). The following fields have connections to the west: (1, 1), (1, 10), (1, 2), (1, 4), (1, 8), (10, 11), (10, 2), (10, 3). No more than eleven push/es are permitted. The following fields have connections to the east: (1, 10), (1, 2), (1, 3), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9). The goal field can be found at position (3, 7).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7025626065877801958", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the north: (1, 11), (1, 12), (1, 3), (1, 4), (1, 6), (1, 7), (1, 8), (10, 1). The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 12), (1, 14), (1, 15), (1, 2), (1, 3). The goal field is located at position (7,1). The following fields have connections to the west: (1, 14), (1, 4), (10, 12), (10, 13), (10, 3), (10, 5), (10, 6), (10, 9). The following fields have connections to the east: (1, 11), (1, 12), (1, 13), (1, 14), (1, 2), (1, 4), (1, 5), (1, 6). The coordinates for the starting position are (3,14). At most fifteen pushes are permitted. The fields of a quadratic 15x15 labyrinth are provided by instances of predicate \"field\" with values from 1 to 15 in both x and y coordinates.", "output": "connect(1, 11, e). connect(1, 12, e). connect(1, 13, e). connect(1, 14, e). connect(1, 2, e). connect(1, 4, e). connect(1, 5, e). connect(1, 6, e). connect(1, 11, n). connect(1, 12, n). connect(1, 3, n). connect(1, 4, n). connect(1, 6, n). connect(1, 7, n). connect(1, 8, n). connect(10, 1, n). connect(1, 1, s). connect(1, 10, s). connect(1, 11, s). connect(1, 12, s). connect(1, 14, s). connect(1, 15, s). connect(1, 2, s). connect(1, 3, s). connect(1, 14, w). connect(1, 4, w). connect(10, 12, w). connect(10, 13, w). connect(10, 3, w). connect(10, 5, w). connect(10, 6, w). connect(10, 9, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(7,1). init_on(3,14). max_steps(15).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the north: (1, 11), (1, 12), (1, 3), (1, 4), (1, 6), (1, 7), (1, 8), (10, 1). The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 12), (1, 14), (1, 15), (1, 2), (1, 3). The goal field is located at position (7,1). The following fields have connections to the west: (1, 14), (1, 4), (10, 12), (10, 13), (10, 3), (10, 5), (10, 6), (10, 9). The following fields have connections to the east: (1, 11), (1, 12), (1, 13), (1, 14), (1, 2), (1, 4), (1, 5), (1, 6). The coordinates for the starting position are (3,14). At most fifteen pushes are permitted. The fields of a quadratic 15x15 labyrinth are provided by instances of predicate \"field\" with values from 1 to 15 in both x and y coordinates.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5261020902173833730", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the south: (1, 1), (1, 13), (1, 16), (1, 18), (1, 19), (1, 3), (1, 6), (1, 8). At most twenty pushes are permitted. The following fields have connections to the north: (1, 12), (1, 3), (10, 10), (10, 12), (10, 13), (10, 14), (10, 15), (10, 19). The goal field is placed at (11, 13). The fields of a quadratic 20x20 labyrinth are provided by instances of predicate \"field\" with values from 1 to 20 in both x and y coordinates. The coordinates for the starting position are (4,2). The following fields have connections to the west: (1, 1), (1, 10), (1, 11), (1, 13), (1, 14), (1, 17), (1, 19), (1, 2). The following fields have connections to the east: (1, 1), (1, 10), (1, 11), (1, 13), (1, 15), (1, 20), (1, 4), (1, 5).", "output": "connect(1, 1, e). connect(1, 10, e). connect(1, 11, e). connect(1, 13, e). connect(1, 15, e). connect(1, 20, e). connect(1, 4, e). connect(1, 5, e). connect(1, 12, n). connect(1, 3, n). connect(10, 10, n). connect(10, 12, n). connect(10, 13, n). connect(10, 14, n). connect(10, 15, n). connect(10, 19, n). connect(1, 1, s). connect(1, 13, s). connect(1, 16, s). connect(1, 18, s). connect(1, 19, s). connect(1, 3, s). connect(1, 6, s). connect(1, 8, s). connect(1, 1, w). connect(1, 10, w). connect(1, 11, w). connect(1, 13, w). connect(1, 14, w). connect(1, 17, w). connect(1, 19, w). connect(1, 2, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(11,13). init_on(4,2). max_steps(20).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the south: (1, 1), (1, 13), (1, 16), (1, 18), (1, 19), (1, 3), (1, 6), (1, 8). At most twenty pushes are permitted. The following fields have connections to the north: (1, 12), (1, 3), (10, 10), (10, 12), (10, 13), (10, 14), (10, 15), (10, 19). The goal field is placed at (11, 13). The fields of a quadratic 20x20 labyrinth are provided by instances of predicate \"field\" with values from 1 to 20 in both x and y coordinates. The coordinates for the starting position are (4,2). The following fields have connections to the west: (1, 1), (1, 10), (1, 11), (1, 13), (1, 14), (1, 17), (1, 19), (1, 2). The following fields have connections to the east: (1, 1), (1, 10), (1, 11), (1, 13), (1, 15), (1, 20), (1, 4), (1, 5).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2947945800385778961", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 11), (1, 2), (1, 4), (1, 6), (1, 9), (10, 11), (10, 13), (10, 14). The goal field is positioned at (13, 3). No more than eighteen push/es are permitted. The following fields have connections to the south: (1, 1), (1, 11), (1, 12), (1, 13), (1, 14), (1, 16), (1, 17), (1, 4). The starting point is located at (5,7). The following fields have connections to the north: (1, 10), (1, 11), (1, 12), (1, 5), (1, 8), (10, 1), (10, 13), (10, 14). The following fields have connections to the east: (1, 1), (1, 10), (1, 11), (1, 12), (1, 13), (1, 15), (1, 18), (1, 3). The fields of a quadratic 18x18 labyrinth are provided by instances of predicate \"field\" with values from 1 to 18 in both x and y coordinates.", "output": "connect(1, 1, e). connect(1, 10, e). connect(1, 11, e). connect(1, 12, e). connect(1, 13, e). connect(1, 15, e). connect(1, 18, e). connect(1, 3, e). connect(1, 10, n). connect(1, 11, n). connect(1, 12, n). connect(1, 5, n). connect(1, 8, n). connect(10, 1, n). connect(10, 13, n). connect(10, 14, n). connect(1, 1, s). connect(1, 11, s). connect(1, 12, s). connect(1, 13, s). connect(1, 14, s). connect(1, 16, s). connect(1, 17, s). connect(1, 4, s). connect(1, 11, w). connect(1, 2, w). connect(1, 4, w). connect(1, 6, w). connect(1, 9, w). connect(10, 11, w). connect(10, 13, w). connect(10, 14, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,2). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,2). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(13,3). init_on(5,7). max_steps(18).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 11), (1, 2), (1, 4), (1, 6), (1, 9), (10, 11), (10, 13), (10, 14). The goal field is positioned at (13, 3). No more than eighteen push/es are permitted. The following fields have connections to the south: (1, 1), (1, 11), (1, 12), (1, 13), (1, 14), (1, 16), (1, 17), (1, 4). The starting point is located at (5,7). The following fields have connections to the north: (1, 10), (1, 11), (1, 12), (1, 5), (1, 8), (10, 1), (10, 13), (10, 14). The following fields have connections to the east: (1, 1), (1, 10), (1, 11), (1, 12), (1, 13), (1, 15), (1, 18), (1, 3). The fields of a quadratic 18x18 labyrinth are provided by instances of predicate \"field\" with values from 1 to 18 in both x and y coordinates.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "519686343093442805", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 1), (1, 11), (1, 12), (1, 4), (1, 9), (10, 1), (10, 10), (10, 11). The following fields have connections to the north: (1, 12), (1, 2), (1, 4), (1, 5), (1, 8), (1, 9), (10, 11), (10, 12). The fields of a quadratic 12x12 labyrinth are provided by instances of predicate \"field\" with values from 1 to 12 in both x and y coordinates. The following fields have connections to the south: (1, 12), (1, 2), (1, 6), (1, 9), (10, 1), (10, 11), (10, 5), (10, 6). The starting location is (6, 3). You are allowed a maximum of twelve pushes. The goal field is placed at (3, 4). The following fields have connections to the east: (1, 10), (1, 12), (1, 2), (1, 3), (1, 4), (1, 7), (10, 1), (10, 7).", "output": "connect(1, 10, e). connect(1, 12, e). connect(1, 2, e). connect(1, 3, e). connect(1, 4, e). connect(1, 7, e). connect(10, 1, e). connect(10, 7, e). connect(1, 12, n). connect(1, 2, n). connect(1, 4, n). connect(1, 5, n). connect(1, 8, n). connect(1, 9, n). connect(10, 11, n). connect(10, 12, n). connect(1, 12, s). connect(1, 2, s). connect(1, 6, s). connect(1, 9, s). connect(10, 1, s). connect(10, 11, s). connect(10, 5, s). connect(10, 6, s). connect(1, 1, w). connect(1, 11, w). connect(1, 12, w). connect(1, 4, w). connect(1, 9, w). connect(10, 1, w). connect(10, 10, w). connect(10, 11, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(3,4). init_on(6,3). max_steps(12).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 1), (1, 11), (1, 12), (1, 4), (1, 9), (10, 1), (10, 10), (10, 11). The following fields have connections to the north: (1, 12), (1, 2), (1, 4), (1, 5), (1, 8), (1, 9), (10, 11), (10, 12). The fields of a quadratic 12x12 labyrinth are provided by instances of predicate \"field\" with values from 1 to 12 in both x and y coordinates. The following fields have connections to the south: (1, 12), (1, 2), (1, 6), (1, 9), (10, 1), (10, 11), (10, 5), (10, 6). The starting location is (6, 3). You are allowed a maximum of twelve pushes. The goal field is placed at (3, 4). The following fields have connections to the east: (1, 10), (1, 12), (1, 2), (1, 3), (1, 4), (1, 7), (10, 1), (10, 7).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "215895722239566277", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the north: (1, 10), (1, 12), (1, 14), (1, 3), (1, 8), (10, 1), (10, 10), (10, 14). The following fields have connections to the west: (1, 15), (1, 16), (1, 2), (1, 3), (1, 5), (1, 7), (1, 8), (1, 9). The starting location is (14, 9). The fields of a quadratic 16x16 labyrinth are provided by instances of predicate \"field\" with values from 1 to 16 in both x and y coordinates. No more than sixteen push/es are permitted. The following fields have connections to the south: (1, 1), (1, 10), (1, 13), (1, 16), (1, 6), (10, 13), (10, 14), (10, 2). The following fields have connections to the east: (1, 10), (1, 11), (1, 13), (1, 16), (1, 3), (1, 4), (1, 5), (1, 8). The goal field is positioned at (10, 10).", "output": "connect(1, 10, e). connect(1, 11, e). connect(1, 13, e). connect(1, 16, e). connect(1, 3, e). connect(1, 4, e). connect(1, 5, e). connect(1, 8, e). connect(1, 10, n). connect(1, 12, n). connect(1, 14, n). connect(1, 3, n). connect(1, 8, n). connect(10, 1, n). connect(10, 10, n). connect(10, 14, n). connect(1, 1, s). connect(1, 10, s). connect(1, 13, s). connect(1, 16, s). connect(1, 6, s). connect(10, 13, s). connect(10, 14, s). connect(10, 2, s). connect(1, 15, w). connect(1, 16, w). connect(1, 2, w). connect(1, 3, w). connect(1, 5, w). connect(1, 7, w). connect(1, 8, w). connect(1, 9, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(10,10). init_on(14,9). max_steps(16).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the north: (1, 10), (1, 12), (1, 14), (1, 3), (1, 8), (10, 1), (10, 10), (10, 14). The following fields have connections to the west: (1, 15), (1, 16), (1, 2), (1, 3), (1, 5), (1, 7), (1, 8), (1, 9). The starting location is (14, 9). The fields of a quadratic 16x16 labyrinth are provided by instances of predicate \"field\" with values from 1 to 16 in both x and y coordinates. No more than sixteen push/es are permitted. The following fields have connections to the south: (1, 1), (1, 10), (1, 13), (1, 16), (1, 6), (10, 13), (10, 14), (10, 2). The following fields have connections to the east: (1, 10), (1, 11), (1, 13), (1, 16), (1, 3), (1, 4), (1, 5), (1, 8). The goal field is positioned at (10, 10).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6245029333791704107", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The fields of a quadratic 12x12 labyrinth are provided by instances of predicate \"field\" with values from 1 to 12 in both x and y coordinates. The starting point is located at (7,3). The following fields have connections to the south: (1, 1), (1, 12), (1, 4), (1, 5), (1, 9), (10, 7), (10, 8), (10, 9). The following fields have connections to the west: (1, 2), (1, 3), (1, 7), (1, 8), (10, 11), (10, 2), (10, 4), (10, 5). The following fields have connections to the east: (1, 1), (1, 12), (1, 2), (1, 4), (1, 8), (10, 1), (10, 12), (10, 5). The following fields have connections to the north: (1, 10), (1, 11), (1, 4), (1, 6), (1, 8), (10, 1), (10, 10), (10, 3). The goal field is positioned at (11, 1). You are allowed a maximum of twelve pushes.", "output": "connect(1, 1, e). connect(1, 12, e). connect(1, 2, e). connect(1, 4, e). connect(1, 8, e). connect(10, 1, e). connect(10, 12, e). connect(10, 5, e). connect(1, 10, n). connect(1, 11, n). connect(1, 4, n). connect(1, 6, n). connect(1, 8, n). connect(10, 1, n). connect(10, 10, n). connect(10, 3, n). connect(1, 1, s). connect(1, 12, s). connect(1, 4, s). connect(1, 5, s). connect(1, 9, s). connect(10, 7, s). connect(10, 8, s). connect(10, 9, s). connect(1, 2, w). connect(1, 3, w). connect(1, 7, w). connect(1, 8, w). connect(10, 11, w). connect(10, 2, w). connect(10, 4, w). connect(10, 5, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(11,1). init_on(7,3). max_steps(12).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The fields of a quadratic 12x12 labyrinth are provided by instances of predicate \"field\" with values from 1 to 12 in both x and y coordinates. The starting point is located at (7,3). The following fields have connections to the south: (1, 1), (1, 12), (1, 4), (1, 5), (1, 9), (10, 7), (10, 8), (10, 9). The following fields have connections to the west: (1, 2), (1, 3), (1, 7), (1, 8), (10, 11), (10, 2), (10, 4), (10, 5). The following fields have connections to the east: (1, 1), (1, 12), (1, 2), (1, 4), (1, 8), (10, 1), (10, 12), (10, 5). The following fields have connections to the north: (1, 10), (1, 11), (1, 4), (1, 6), (1, 8), (10, 1), (10, 10), (10, 3). The goal field is positioned at (11, 1). You are allowed a maximum of twelve pushes.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "73445284326111855", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 2), (1, 5). The fields of a quadratic 14x14 labyrinth are provided by instances of predicate \"field\" with values from 1 to 14 in both x and y coordinates. The following fields have connections to the north: (1, 1), (1, 10), (1, 12), (1, 5), (1, 7), (1, 9), (10, 1), (10, 12). You are allowed a maximum of fourteen pushes. The goal field is located at position (11,12). The starting location is (10, 3). The following fields have connections to the west: (1, 1), (1, 3), (1, 6), (1, 7), (1, 8), (10, 12), (10, 6), (11, 4). The following fields have connections to the east: (1, 14), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (10, 11), (10, 12).", "output": "connect(1, 14, e). connect(1, 4, e). connect(1, 5, e). connect(1, 6, e). connect(1, 7, e). connect(1, 8, e). connect(10, 11, e). connect(10, 12, e). connect(1, 1, n). connect(1, 10, n). connect(1, 12, n). connect(1, 5, n). connect(1, 7, n). connect(1, 9, n). connect(10, 1, n). connect(10, 12, n). connect(1, 1, s). connect(1, 10, s). connect(1, 11, s). connect(1, 12, s). connect(1, 13, s). connect(1, 14, s). connect(1, 2, s). connect(1, 5, s). connect(1, 1, w). connect(1, 3, w). connect(1, 6, w). connect(1, 7, w). connect(1, 8, w). connect(10, 12, w). connect(10, 6, w). connect(11, 4, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(11,12). init_on(10,3). max_steps(14).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the south: (1, 1), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 2), (1, 5). The fields of a quadratic 14x14 labyrinth are provided by instances of predicate \"field\" with values from 1 to 14 in both x and y coordinates. The following fields have connections to the north: (1, 1), (1, 10), (1, 12), (1, 5), (1, 7), (1, 9), (10, 1), (10, 12). You are allowed a maximum of fourteen pushes. The goal field is located at position (11,12). The starting location is (10, 3). The following fields have connections to the west: (1, 1), (1, 3), (1, 6), (1, 7), (1, 8), (10, 12), (10, 6), (11, 4). The following fields have connections to the east: (1, 14), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (10, 11), (10, 12).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7609168548036447338", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the east: (1, 15), (1, 2), (1, 3), (1, 4), (1, 7), (1, 8), (1, 9), (10, 1). The following fields have connections to the west: (1, 11), (1, 14), (1, 15), (1, 3), (1, 5), (10, 10), (10, 11), (10, 13). The following fields have connections to the north: (1, 16), (1, 2), (1, 5), (1, 6), (1, 7), (10, 1), (10, 12), (10, 2). The fields of a quadratic 16x16 labyrinth are provided by instances of predicate \"field\" with values from 1 to 16 in both x and y coordinates. The coordinates for the starting position are (14,16). The goal field is positioned at (6, 5). You are allowed a maximum of sixteen pushes. The following fields have connections to the south: (1, 1), (1, 10), (1, 12), (1, 13), (1, 3), (1, 7), (1, 8), (10, 1).", "output": "connect(1, 15, e). connect(1, 2, e). connect(1, 3, e). connect(1, 4, e). connect(1, 7, e). connect(1, 8, e). connect(1, 9, e). connect(10, 1, e). connect(1, 16, n). connect(1, 2, n). connect(1, 5, n). connect(1, 6, n). connect(1, 7, n). connect(10, 1, n). connect(10, 12, n). connect(10, 2, n). connect(1, 1, s). connect(1, 10, s). connect(1, 12, s). connect(1, 13, s). connect(1, 3, s). connect(1, 7, s). connect(1, 8, s). connect(10, 1, s). connect(1, 11, w). connect(1, 14, w). connect(1, 15, w). connect(1, 3, w). connect(1, 5, w). connect(10, 10, w). connect(10, 11, w). connect(10, 13, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(6,5). init_on(14,16). max_steps(16).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the east: (1, 15), (1, 2), (1, 3), (1, 4), (1, 7), (1, 8), (1, 9), (10, 1). The following fields have connections to the west: (1, 11), (1, 14), (1, 15), (1, 3), (1, 5), (10, 10), (10, 11), (10, 13). The following fields have connections to the north: (1, 16), (1, 2), (1, 5), (1, 6), (1, 7), (10, 1), (10, 12), (10, 2). The fields of a quadratic 16x16 labyrinth are provided by instances of predicate \"field\" with values from 1 to 16 in both x and y coordinates. The coordinates for the starting position are (14,16). The goal field is positioned at (6, 5). You are allowed a maximum of sixteen pushes. The following fields have connections to the south: (1, 1), (1, 10), (1, 12), (1, 13), (1, 3), (1, 7), (1, 8), (10, 1).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5049853897862458364", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The goal field is positioned at (2, 5). The following fields have connections to the south: (1, 1), (1, 11), (1, 17), (1, 18), (1, 19), (1, 20), (1, 3), (1, 5). The starting point is located at (19,16). The following fields have connections to the west: (1, 12), (1, 15), (1, 16), (1, 2), (1, 3), (1, 7), (1, 8), (1, 9). You are allowed a maximum of twenty pushes. The following fields have connections to the north: (1, 10), (1, 13), (1, 20), (1, 3), (1, 7), (10, 10), (10, 11), (10, 13). The fields of a quadratic 20x20 labyrinth are provided by instances of predicate \"field\" with values from 1 to 20 in both x and y coordinates. The following fields have connections to the east: (1, 12), (1, 14), (1, 17), (1, 3), (1, 4), (1, 5), (1, 8), (10, 1).", "output": "connect(1, 12, e). connect(1, 14, e). connect(1, 17, e). connect(1, 3, e). connect(1, 4, e). connect(1, 5, e). connect(1, 8, e). connect(10, 1, e). connect(1, 10, n). connect(1, 13, n). connect(1, 20, n). connect(1, 3, n). connect(1, 7, n). connect(10, 10, n). connect(10, 11, n). connect(10, 13, n). connect(1, 1, s). connect(1, 11, s). connect(1, 17, s). connect(1, 18, s). connect(1, 19, s). connect(1, 20, s). connect(1, 3, s). connect(1, 5, s). connect(1, 12, w). connect(1, 15, w). connect(1, 16, w). connect(1, 2, w). connect(1, 3, w). connect(1, 7, w). connect(1, 8, w). connect(1, 9, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(2,5). init_on(19,16). max_steps(20).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The goal field is positioned at (2, 5). The following fields have connections to the south: (1, 1), (1, 11), (1, 17), (1, 18), (1, 19), (1, 20), (1, 3), (1, 5). The starting point is located at (19,16). The following fields have connections to the west: (1, 12), (1, 15), (1, 16), (1, 2), (1, 3), (1, 7), (1, 8), (1, 9). You are allowed a maximum of twenty pushes. The following fields have connections to the north: (1, 10), (1, 13), (1, 20), (1, 3), (1, 7), (10, 10), (10, 11), (10, 13). The fields of a quadratic 20x20 labyrinth are provided by instances of predicate \"field\" with values from 1 to 20 in both x and y coordinates. The following fields have connections to the east: (1, 12), (1, 14), (1, 17), (1, 3), (1, 4), (1, 5), (1, 8), (10, 1).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3822990322526387449", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The goal field is placed at (13, 13). The following fields have connections to the west: (1, 10), (1, 11), (1, 12), (1, 17), (1, 18), (1, 20), (1, 4), (1, 5). The following fields have connections to the east: (1, 1), (1, 10), (1, 14), (1, 16), (1, 17), (1, 19), (1, 2), (1, 21). The starting point is located at (13,5). The following fields have connections to the south: (1, 12), (1, 18), (1, 20), (1, 6), (1, 8), (1, 9), (10, 1), (10, 10). A maximum of twenty-one push/es is allowed. The fields of a quadratic 21x21 labyrinth are provided by instances of predicate \"field\" with values from 1 to 21 in both x and y coordinates. The following fields have connections to the north: (1, 13), (1, 15), (1, 17), (1, 20), (1, 6), (1, 7), (1, 8), (1, 9).", "output": "connect(1, 1, e). connect(1, 10, e). connect(1, 14, e). connect(1, 16, e). connect(1, 17, e). connect(1, 19, e). connect(1, 2, e). connect(1, 21, e). connect(1, 13, n). connect(1, 15, n). connect(1, 17, n). connect(1, 20, n). connect(1, 6, n). connect(1, 7, n). connect(1, 8, n). connect(1, 9, n). connect(1, 12, s). connect(1, 18, s). connect(1, 20, s). connect(1, 6, s). connect(1, 8, s). connect(1, 9, s). connect(10, 1, s). connect(10, 10, s). connect(1, 10, w). connect(1, 11, w). connect(1, 12, w). connect(1, 17, w). connect(1, 18, w). connect(1, 20, w). connect(1, 4, w). connect(1, 5, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,21). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,21). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,21). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,21). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,21). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,21). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,21). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,21). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,21). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,21). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,21). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,21). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,21). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(21,1). field(21,10). field(21,11). field(21,12). field(21,13). field(21,14). field(21,15). field(21,16). field(21,17). field(21,18). field(21,19). field(21,2). field(21,20). field(21,21). field(21,3). field(21,4). field(21,5). field(21,6). field(21,7). field(21,8). field(21,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,21). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,21). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,21). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,21). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,21). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,21). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,21). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(13,13). init_on(13,5). max_steps(21).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The goal field is placed at (13, 13). The following fields have connections to the west: (1, 10), (1, 11), (1, 12), (1, 17), (1, 18), (1, 20), (1, 4), (1, 5). The following fields have connections to the east: (1, 1), (1, 10), (1, 14), (1, 16), (1, 17), (1, 19), (1, 2), (1, 21). The starting point is located at (13,5). The following fields have connections to the south: (1, 12), (1, 18), (1, 20), (1, 6), (1, 8), (1, 9), (10, 1), (10, 10). A maximum of twenty-one push/es is allowed. The fields of a quadratic 21x21 labyrinth are provided by instances of predicate \"field\" with values from 1 to 21 in both x and y coordinates. The following fields have connections to the north: (1, 13), (1, 15), (1, 17), (1, 20), (1, 6), (1, 7), (1, 8), (1, 9).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4068316752809799046", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the south: (1, 10), (1, 12), (1, 14), (1, 2), (1, 20), (1, 21), (1, 3), (1, 5). The goal field can be found at position (18, 5). The following fields have connections to the east: (1, 1), (1, 14), (1, 16), (1, 21), (1, 22), (1, 3), (1, 4), (1, 8). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. The following fields have connections to the west: (1, 12), (1, 13), (1, 15), (1, 17), (1, 18), (1, 19), (1, 21), (1, 22). The following fields have connections to the north: (1, 1), (1, 10), (1, 11), (1, 12), (1, 14), (1, 17), (1, 21), (1, 3). A maximum of twenty-two push/es is allowed. The starting location is (14, 21).", "output": "connect(1, 1, e). connect(1, 14, e). connect(1, 16, e). connect(1, 21, e). connect(1, 22, e). connect(1, 3, e). connect(1, 4, e). connect(1, 8, e). connect(1, 1, n). connect(1, 10, n). connect(1, 11, n). connect(1, 12, n). connect(1, 14, n). connect(1, 17, n). connect(1, 21, n). connect(1, 3, n). connect(1, 10, s). connect(1, 12, s). connect(1, 14, s). connect(1, 2, s). connect(1, 20, s). connect(1, 21, s). connect(1, 3, s). connect(1, 5, s). connect(1, 12, w). connect(1, 13, w). connect(1, 15, w). connect(1, 17, w). connect(1, 18, w). connect(1, 19, w). connect(1, 21, w). connect(1, 22, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,20). field(1,21). field(1,22). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,20). field(10,21). field(10,22). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,20). field(11,21). field(11,22). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,20). field(12,21). field(12,22). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,20). field(13,21). field(13,22). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,20). field(14,21). field(14,22). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,20). field(15,21). field(15,22). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,20). field(16,21). field(16,22). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,20). field(17,21). field(17,22). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,20). field(18,21). field(18,22). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,20). field(19,21). field(19,22). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,20). field(2,21). field(2,22). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(20,1). field(20,10). field(20,11). field(20,12). field(20,13). field(20,14). field(20,15). field(20,16). field(20,17). field(20,18). field(20,19). field(20,2). field(20,20). field(20,21). field(20,22). field(20,3). field(20,4). field(20,5). field(20,6). field(20,7). field(20,8). field(20,9). field(21,1). field(21,10). field(21,11). field(21,12). field(21,13). field(21,14). field(21,15). field(21,16). field(21,17). field(21,18). field(21,19). field(21,2). field(21,20). field(21,21). field(21,22). field(21,3). field(21,4). field(21,5). field(21,6). field(21,7). field(21,8). field(21,9). field(22,1). field(22,10). field(22,11). field(22,12). field(22,13). field(22,14). field(22,15). field(22,16). field(22,17). field(22,18). field(22,19). field(22,2). field(22,20). field(22,21). field(22,22). field(22,3). field(22,4). field(22,5). field(22,6). field(22,7). field(22,8). field(22,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,20). field(3,21). field(3,22). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,20). field(4,21). field(4,22). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,20). field(5,21). field(5,22). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,20). field(6,21). field(6,22). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,20). field(7,21). field(7,22). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,20). field(8,21). field(8,22). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,20). field(9,21). field(9,22). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(18,5). init_on(14,21). max_steps(22).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the south: (1, 10), (1, 12), (1, 14), (1, 2), (1, 20), (1, 21), (1, 3), (1, 5). The goal field can be found at position (18, 5). The following fields have connections to the east: (1, 1), (1, 14), (1, 16), (1, 21), (1, 22), (1, 3), (1, 4), (1, 8). The fields of a quadratic 22x22 labyrinth are provided by instances of predicate \"field\" with values from 1 to 22 in both x and y coordinates. The following fields have connections to the west: (1, 12), (1, 13), (1, 15), (1, 17), (1, 18), (1, 19), (1, 21), (1, 22). The following fields have connections to the north: (1, 1), (1, 10), (1, 11), (1, 12), (1, 14), (1, 17), (1, 21), (1, 3). A maximum of twenty-two push/es is allowed. The starting location is (14, 21).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2892567184663428", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The fields of a quadratic 10x10 labyrinth are provided by instances of predicate \"field\" with values from 1 to 10 in both x and y coordinates. The following fields have connections to the west: (1, 1), (1, 10), (1, 3), (1, 4), (1, 5), (1, 7), (1, 9), (10, 10). The following fields have connections to the south: (1, 3), (1, 8), (10, 10), (10, 2), (10, 3), (10, 4), (10, 6), (10, 7). The following fields have connections to the north: (1, 10), (1, 2), (1, 6), (10, 10), (10, 2), (10, 5), (10, 6), (10, 7). The goal field can be found at position (9, 3). The starting field is at (1,3). The following fields have connections to the east: (1, 7), (1, 9), (10, 1), (10, 10), (10, 3), (10, 4), (10, 7), (2, 2). At most ten pushes are permitted.", "output": "connect(1, 7, e). connect(1, 9, e). connect(10, 1, e). connect(10, 10, e). connect(10, 3, e). connect(10, 4, e). connect(10, 7, e). connect(2, 2, e). connect(1, 10, n). connect(1, 2, n). connect(1, 6, n). connect(10, 10, n). connect(10, 2, n). connect(10, 5, n). connect(10, 6, n). connect(10, 7, n). connect(1, 3, s). connect(1, 8, s). connect(10, 10, s). connect(10, 2, s). connect(10, 3, s). connect(10, 4, s). connect(10, 6, s). connect(10, 7, s). connect(1, 1, w). connect(1, 10, w). connect(1, 3, w). connect(1, 4, w). connect(1, 5, w). connect(1, 7, w). connect(1, 9, w). connect(10, 10, w). field(1,1). field(1,10). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(2,1). field(2,10). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(9,3). init_on(1,3). max_steps(10).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The fields of a quadratic 10x10 labyrinth are provided by instances of predicate \"field\" with values from 1 to 10 in both x and y coordinates. The following fields have connections to the west: (1, 1), (1, 10), (1, 3), (1, 4), (1, 5), (1, 7), (1, 9), (10, 10). The following fields have connections to the south: (1, 3), (1, 8), (10, 10), (10, 2), (10, 3), (10, 4), (10, 6), (10, 7). The following fields have connections to the north: (1, 10), (1, 2), (1, 6), (10, 10), (10, 2), (10, 5), (10, 6), (10, 7). The goal field can be found at position (9, 3). The starting field is at (1,3). The following fields have connections to the east: (1, 7), (1, 9), (10, 1), (10, 10), (10, 3), (10, 4), (10, 7), (2, 2). At most ten pushes are permitted.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1798256110665596057", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the west: (1, 10), (1, 5), (1, 6), (1, 7), (10, 10), (10, 3), (10, 4), (10, 5). The fields of a quadratic 10x10 labyrinth are provided by instances of predicate \"field\" with values from 1 to 10 in both x and y coordinates. The following fields have connections to the south: (1, 5), (1, 8), (10, 10), (10, 2), (10, 7), (2, 1), (2, 10), (2, 2). The goal field can be found at position (5, 1). The following fields have connections to the east: (1, 2), (1, 3), (1, 5), (1, 9), (10, 10), (10, 4), (10, 6), (10, 7). The coordinates for the starting position are (2,5). At most ten pushes are permitted. The following fields have connections to the north: (1, 1), (1, 10), (1, 3), (1, 4), (10, 1), (10, 4), (10, 5), (10, 7).", "output": "connect(1, 2, e). connect(1, 3, e). connect(1, 5, e). connect(1, 9, e). connect(10, 10, e). connect(10, 4, e). connect(10, 6, e). connect(10, 7, e). connect(1, 1, n). connect(1, 10, n). connect(1, 3, n). connect(1, 4, n). connect(10, 1, n). connect(10, 4, n). connect(10, 5, n). connect(10, 7, n). connect(1, 5, s). connect(1, 8, s). connect(10, 10, s). connect(10, 2, s). connect(10, 7, s). connect(2, 1, s). connect(2, 10, s). connect(2, 2, s). connect(1, 10, w). connect(1, 5, w). connect(1, 6, w). connect(1, 7, w). connect(10, 10, w). connect(10, 3, w). connect(10, 4, w). connect(10, 5, w). field(1,1). field(1,10). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(2,1). field(2,10). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(5,1). init_on(2,5). max_steps(10).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the west: (1, 10), (1, 5), (1, 6), (1, 7), (10, 10), (10, 3), (10, 4), (10, 5). The fields of a quadratic 10x10 labyrinth are provided by instances of predicate \"field\" with values from 1 to 10 in both x and y coordinates. The following fields have connections to the south: (1, 5), (1, 8), (10, 10), (10, 2), (10, 7), (2, 1), (2, 10), (2, 2). The goal field can be found at position (5, 1). The following fields have connections to the east: (1, 2), (1, 3), (1, 5), (1, 9), (10, 10), (10, 4), (10, 6), (10, 7). The coordinates for the starting position are (2,5). At most ten pushes are permitted. The following fields have connections to the north: (1, 1), (1, 10), (1, 3), (1, 4), (10, 1), (10, 4), (10, 5), (10, 7).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "692315638935600530", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the north: (1, 10), (1, 15), (1, 17), (1, 19), (1, 2), (1, 4), (1, 5), (1, 6). The goal field is placed at (17, 17). The following fields have connections to the south: (1, 10), (1, 14), (1, 17), (1, 18), (1, 2), (10, 1), (10, 10), (10, 11). The following fields have connections to the east: (1, 10), (1, 11), (1, 13), (1, 17), (1, 2), (1, 3), (1, 5), (1, 8). The fields of a quadratic 19x19 labyrinth are provided by instances of predicate \"field\" with values from 1 to 19 in both x and y coordinates. The following fields have connections to the west: (1, 1), (1, 12), (1, 13), (1, 16), (1, 18), (1, 2), (1, 5), (1, 7). The starting point is located at (8,15). No more than nineteen push/es are permitted.", "output": "connect(1, 10, e). connect(1, 11, e). connect(1, 13, e). connect(1, 17, e). connect(1, 2, e). connect(1, 3, e). connect(1, 5, e). connect(1, 8, e). connect(1, 10, n). connect(1, 15, n). connect(1, 17, n). connect(1, 19, n). connect(1, 2, n). connect(1, 4, n). connect(1, 5, n). connect(1, 6, n). connect(1, 10, s). connect(1, 14, s). connect(1, 17, s). connect(1, 18, s). connect(1, 2, s). connect(10, 1, s). connect(10, 10, s). connect(10, 11, s). connect(1, 1, w). connect(1, 12, w). connect(1, 13, w). connect(1, 16, w). connect(1, 18, w). connect(1, 2, w). connect(1, 5, w). connect(1, 7, w). field(1,1). field(1,10). field(1,11). field(1,12). field(1,13). field(1,14). field(1,15). field(1,16). field(1,17). field(1,18). field(1,19). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,11). field(10,12). field(10,13). field(10,14). field(10,15). field(10,16). field(10,17). field(10,18). field(10,19). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(11,1). field(11,10). field(11,11). field(11,12). field(11,13). field(11,14). field(11,15). field(11,16). field(11,17). field(11,18). field(11,19). field(11,2). field(11,3). field(11,4). field(11,5). field(11,6). field(11,7). field(11,8). field(11,9). field(12,1). field(12,10). field(12,11). field(12,12). field(12,13). field(12,14). field(12,15). field(12,16). field(12,17). field(12,18). field(12,19). field(12,2). field(12,3). field(12,4). field(12,5). field(12,6). field(12,7). field(12,8). field(12,9). field(13,1). field(13,10). field(13,11). field(13,12). field(13,13). field(13,14). field(13,15). field(13,16). field(13,17). field(13,18). field(13,19). field(13,2). field(13,3). field(13,4). field(13,5). field(13,6). field(13,7). field(13,8). field(13,9). field(14,1). field(14,10). field(14,11). field(14,12). field(14,13). field(14,14). field(14,15). field(14,16). field(14,17). field(14,18). field(14,19). field(14,2). field(14,3). field(14,4). field(14,5). field(14,6). field(14,7). field(14,8). field(14,9). field(15,1). field(15,10). field(15,11). field(15,12). field(15,13). field(15,14). field(15,15). field(15,16). field(15,17). field(15,18). field(15,19). field(15,2). field(15,3). field(15,4). field(15,5). field(15,6). field(15,7). field(15,8). field(15,9). field(16,1). field(16,10). field(16,11). field(16,12). field(16,13). field(16,14). field(16,15). field(16,16). field(16,17). field(16,18). field(16,19). field(16,2). field(16,3). field(16,4). field(16,5). field(16,6). field(16,7). field(16,8). field(16,9). field(17,1). field(17,10). field(17,11). field(17,12). field(17,13). field(17,14). field(17,15). field(17,16). field(17,17). field(17,18). field(17,19). field(17,2). field(17,3). field(17,4). field(17,5). field(17,6). field(17,7). field(17,8). field(17,9). field(18,1). field(18,10). field(18,11). field(18,12). field(18,13). field(18,14). field(18,15). field(18,16). field(18,17). field(18,18). field(18,19). field(18,2). field(18,3). field(18,4). field(18,5). field(18,6). field(18,7). field(18,8). field(18,9). field(19,1). field(19,10). field(19,11). field(19,12). field(19,13). field(19,14). field(19,15). field(19,16). field(19,17). field(19,18). field(19,19). field(19,2). field(19,3). field(19,4). field(19,5). field(19,6). field(19,7). field(19,8). field(19,9). field(2,1). field(2,10). field(2,11). field(2,12). field(2,13). field(2,14). field(2,15). field(2,16). field(2,17). field(2,18). field(2,19). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,11). field(3,12). field(3,13). field(3,14). field(3,15). field(3,16). field(3,17). field(3,18). field(3,19). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,11). field(4,12). field(4,13). field(4,14). field(4,15). field(4,16). field(4,17). field(4,18). field(4,19). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,11). field(5,12). field(5,13). field(5,14). field(5,15). field(5,16). field(5,17). field(5,18). field(5,19). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,11). field(6,12). field(6,13). field(6,14). field(6,15). field(6,16). field(6,17). field(6,18). field(6,19). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,11). field(7,12). field(7,13). field(7,14). field(7,15). field(7,16). field(7,17). field(7,18). field(7,19). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,11). field(8,12). field(8,13). field(8,14). field(8,15). field(8,16). field(8,17). field(8,18). field(8,19). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,11). field(9,12). field(9,13). field(9,14). field(9,15). field(9,16). field(9,17). field(9,18). field(9,19). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(17,17). init_on(8,15). max_steps(19).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the north: (1, 10), (1, 15), (1, 17), (1, 19), (1, 2), (1, 4), (1, 5), (1, 6). The goal field is placed at (17, 17). The following fields have connections to the south: (1, 10), (1, 14), (1, 17), (1, 18), (1, 2), (10, 1), (10, 10), (10, 11). The following fields have connections to the east: (1, 10), (1, 11), (1, 13), (1, 17), (1, 2), (1, 3), (1, 5), (1, 8). The fields of a quadratic 19x19 labyrinth are provided by instances of predicate \"field\" with values from 1 to 19 in both x and y coordinates. The following fields have connections to the west: (1, 1), (1, 12), (1, 13), (1, 16), (1, 18), (1, 2), (1, 5), (1, 7). The starting point is located at (8,15). No more than nineteen push/es are permitted.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8142214326679595592", "problem_id": "18", "problem_name": "Labyrinth", "description": "Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.", "format": "The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).", "text": "The following fields have connections to the south: (1, 3), (10, 1), (10, 10), (10, 3), (10, 4), (10, 9), (2, 3), (2, 5). The following fields have connections to the east: (1, 3), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (10, 1), (10, 10). The fields of a quadratic 10x10 labyrinth are provided by instances of predicate \"field\" with values from 1 to 10 in both x and y coordinates. No more than ten push/es are permitted. The starting coordinates are (7,1). The following fields have connections to the west: (1, 10), (1, 2), (1, 4), (1, 5), (1, 6), (1, 8), (10, 1), (10, 10). The goal field is located at position (4,3). The following fields have connections to the north: (1, 1), (1, 3), (1, 5), (1, 6), (1, 8), (10, 1), (10, 4), (10, 8).", "output": "connect(1, 3, e). connect(1, 5, e). connect(1, 6, e). connect(1, 7, e). connect(1, 8, e). connect(1, 9, e). connect(10, 1, e). connect(10, 10, e). connect(1, 1, n). connect(1, 3, n). connect(1, 5, n). connect(1, 6, n). connect(1, 8, n). connect(10, 1, n). connect(10, 4, n). connect(10, 8, n). connect(1, 3, s). connect(10, 1, s). connect(10, 10, s). connect(10, 3, s). connect(10, 4, s). connect(10, 9, s). connect(2, 3, s). connect(2, 5, s). connect(1, 10, w). connect(1, 2, w). connect(1, 4, w). connect(1, 5, w). connect(1, 6, w). connect(1, 8, w). connect(10, 1, w). connect(10, 10, w). field(1,1). field(1,10). field(1,2). field(1,3). field(1,4). field(1,5). field(1,6). field(1,7). field(1,8). field(1,9). field(10,1). field(10,10). field(10,2). field(10,3). field(10,4). field(10,5). field(10,6). field(10,7). field(10,8). field(10,9). field(2,1). field(2,10). field(2,2). field(2,3). field(2,4). field(2,5). field(2,6). field(2,7). field(2,8). field(2,9). field(3,1). field(3,10). field(3,2). field(3,3). field(3,4). field(3,5). field(3,6). field(3,7). field(3,8). field(3,9). field(4,1). field(4,10). field(4,2). field(4,3). field(4,4). field(4,5). field(4,6). field(4,7). field(4,8). field(4,9). field(5,1). field(5,10). field(5,2). field(5,3). field(5,4). field(5,5). field(5,6). field(5,7). field(5,8). field(5,9). field(6,1). field(6,10). field(6,2). field(6,3). field(6,4). field(6,5). field(6,6). field(6,7). field(6,8). field(6,9). field(7,1). field(7,10). field(7,2). field(7,3). field(7,4). field(7,5). field(7,6). field(7,7). field(7,8). field(7,9). field(8,1). field(8,10). field(8,2). field(8,3). field(8,4). field(8,5). field(8,6). field(8,7). field(8,8). field(8,9). field(9,1). field(9,10). field(9,2). field(9,3). field(9,4). field(9,5). field(9,6). field(9,7). field(9,8). field(9,9). goal_on(4,3). init_on(7,1). max_steps(10).", "prompt": "Given the following problem description between triple backtips: \n ```Ravensburger's Labyrinth game deals with guiding an avatar through a dynamically changing labyrinth to certain fields. The labyrinth is represented by a quadratic board whose fields can (but do not have to) be connected in the four cardinal directions. The shape of the labyrinth changes over time as its rows and columns can be pushed either horizontally or vertically, which involves moving fields out of and into the board. To get to another field, in each turn, the avatar can follow paths that starting from the avatar's location traverse pairwisely connected fields.\nWe here consider a variation of the original game in which:\n- The field of the labyrinth pushed out of the board (possibly hosting the avatar) immediately returns into the board (possibly with the avatar still residing on it) on the other end of the pushed row or column, respectively.\n- After a push, the avatar can move to any field reachable via a path in which every (non-terminal) field has a connection to its successor, and vice versa. (Note that there always is a path to a field the avatar already resides on.)\n- There is a unique starting and a unique goal field in the labyrinth.\n- A solution is represented by pushes of the labyrinth's rows and columns such that the avatar can from its starting field (which changes its location when pushed) reach the goal field (which also changes its location when pushed) by a move along some path after each push.\n- There is a maximum number of pushes, and the avatar must be able to reach the goal field (which can be relocated by pushes) by moving along some path after each push.\nThe proposed variant of the Labyrinth game is a hard (presumably NP-complete) search problem.```\nGiven the following specification for the predicates format: \n```The fields of a quadratic NxN-labyrinth are provided by instances of predicate \"field\" as follows:\nfield(1,1). field(1,2). ... field(1,N). field(2,1). field(2,2). ... field(2,N). ... field(N,1). field(N,2). ... field(N,N).\n\nThe starting and the goal field are specified by exactly one instance of \"init_on\" and exactly one instance of \"goal_on\":\ninit_on(x_i,y_i). goal_on(x_g,y_g).\n\nIt always holds that 1 \u2264 x_i,y_i,x_g,y_g \u2264 N.\nThe connections of fields are given by instances of \"connect\" looking as follows: connect(x,y,d).\n\nAgain, we have 1 \u2264 x,y \u2264 N. Furthermore, direction d can be \"n\" for north, \"s\" for south, \"e\" for east, or \"w\" for west.\nFinally, the maximum number of pushes is determined by exactly one instance of \"max_steps\": max_steps(m).\n\nArgument m is a positive integer. An exemplary input for the above example looks as follows:\nfield(1,1). ... field(1,4). .... field(4,1). ... field(4,4). init_on(3,2). goal_on(1,4). connect(1,1,s). connect(1,1,w). connect(1,2,n). connect(1,2,e). connect(1,2,w). connect(1,3,e). connect(1,4,n). connect(1,4,w). ... connect(4,4,w). max_steps(2).```\nExtract the datalog facts from this text: \n```The following fields have connections to the south: (1, 3), (10, 1), (10, 10), (10, 3), (10, 4), (10, 9), (2, 3), (2, 5). The following fields have connections to the east: (1, 3), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (10, 1), (10, 10). The fields of a quadratic 10x10 labyrinth are provided by instances of predicate \"field\" with values from 1 to 10 in both x and y coordinates. No more than ten push/es are permitted. The starting coordinates are (7,1). The following fields have connections to the west: (1, 10), (1, 2), (1, 4), (1, 5), (1, 6), (1, 8), (10, 1), (10, 10). The goal field is located at position (4,3). The following fields have connections to the north: (1, 1), (1, 3), (1, 5), (1, 6), (1, 8), (10, 1), (10, 4), (10, 8).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4550011246964744096", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Vertices 1 and 10 are connected. Nodes 1 and 1010 are connected by an edge. Vertices 1 and 1008 are connected. There is an edge between nodes 1 and 101. There is an edge between nodes 1 and 1000. There is a link between nodes 1 and 1013. There is a connection between 1 and 1007. Vertices 1 and 100 are connected. There are thirteen nodes: 1007, 101, 1010, 1008, 10, 1013, 1001, 1002, 1, 1003, 1000, 1004 and 100.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1007). edge(1,1008). edge(1,101). edge(1,1010). edge(1,1013). node(1007) node(101) node(1010) node(1008) node(10) node(1013) node(1001) node(1002) node(1) node(1003) node(1000) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Vertices 1 and 10 are connected. Nodes 1 and 1010 are connected by an edge. Vertices 1 and 1008 are connected. There is an edge between nodes 1 and 101. There is an edge between nodes 1 and 1000. There is a link between nodes 1 and 1013. There is a connection between 1 and 1007. Vertices 1 and 100 are connected. There are thirteen nodes: 1007, 101, 1010, 1008, 10, 1013, 1001, 1002, 1, 1003, 1000, 1004 and 100.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8070487115949163765", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Vertices 1 and 1000 are connected. Vertices 1 and 1009 are connected. Nodes 1 and 1012 are connected by an edge. Nodes 1 and 1010 are connected by an edge. There is an edge between nodes 1 and 1003. There is a link between nodes 1 and 100. Vertices 1 and 1011 are connected. There are thirteen nodes: 101, 1010, 10, 1001, 1003, 1002, 1, 1000, 1011, 1012, 1004, 1009 and 100. There is a connection between 1 and 101.", "output": "edge(1,100). edge(1,1000). edge(1,1003). edge(1,1009). edge(1,101). edge(1,1010). edge(1,1011). edge(1,1012). node(101) node(1010) node(10) node(1001) node(1003) node(1002) node(1) node(1000) node(1011) node(1012) node(1004) node(1009) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Vertices 1 and 1000 are connected. Vertices 1 and 1009 are connected. Nodes 1 and 1012 are connected by an edge. Nodes 1 and 1010 are connected by an edge. There is an edge between nodes 1 and 1003. There is a link between nodes 1 and 100. Vertices 1 and 1011 are connected. There are thirteen nodes: 101, 1010, 10, 1001, 1003, 1002, 1, 1000, 1011, 1012, 1004, 1009 and 100. There is a connection between 1 and 101.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5249180058723592278", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is an edge between nodes 1 and 1004. There is a connection between 1 and 100. There is an edge between nodes 1 and 1000. Vertices 1 and 1007 are connected. Nodes 1 and 101 are connected by an edge. There is a link between nodes 1 and 1001. There is a link between nodes 1 and 10. There are eleven nodes: 1007, 101, 1008, 10, 1001, 1002, 1003, 1, 1000, 1004 and 100. There is a link between nodes 1 and 1008.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1004). edge(1,1007). edge(1,1008). edge(1,101). node(1007) node(101) node(1008) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 1004. There is a connection between 1 and 100. There is an edge between nodes 1 and 1000. Vertices 1 and 1007 are connected. Nodes 1 and 101 are connected by an edge. There is a link between nodes 1 and 1001. There is a link between nodes 1 and 10. There are eleven nodes: 1007, 101, 1008, 10, 1001, 1002, 1003, 1, 1000, 1004 and 100. There is a link between nodes 1 and 1008.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8295244128822719125", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 107. There is a connection between 1 and 108. Vertices 1 and 11 are connected. Nodes 1 and 1000 are connected by an edge. There is a connection between 1 and 106. There are thirteen nodes: 107, 104, 101, 108, 106, 1, 102, 1000, 103, 100, 11, 109 and 10. There is a link between nodes 1 and 101. Vertices 1 and 10 are connected. There is a link between nodes 1 and 109.", "output": "edge(1,10). edge(1,1000). edge(1,101). edge(1,106). edge(1,107). edge(1,108). edge(1,109). edge(1,11). node(107) node(104) node(101) node(108) node(106) node(1) node(102) node(1000) node(103) node(100) node(11) node(109) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 107. There is a connection between 1 and 108. Vertices 1 and 11 are connected. Nodes 1 and 1000 are connected by an edge. There is a connection between 1 and 106. There are thirteen nodes: 107, 104, 101, 108, 106, 1, 102, 1000, 103, 100, 11, 109 and 10. There is a link between nodes 1 and 101. Vertices 1 and 10 are connected. There is a link between nodes 1 and 109.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3442264668063895682", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There are ten nodes: 1008, 10, 1001, 1002, 1003, 1, 1000, 1009, 1004 and 100. Vertices 1 and 1000 are connected. Vertices 1 and 1008 are connected. Nodes 1 and 100 are connected by an edge. Nodes 1 and 1004 are connected by an edge. Nodes 1 and 1001 are connected by an edge. There is a link between nodes 1 and 1009. There is a connection between 1 and 10. There is an edge between nodes 1 and 1002.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1004). edge(1,1008). edge(1,1009). node(1008) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1009) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There are ten nodes: 1008, 10, 1001, 1002, 1003, 1, 1000, 1009, 1004 and 100. Vertices 1 and 1000 are connected. Vertices 1 and 1008 are connected. Nodes 1 and 100 are connected by an edge. Nodes 1 and 1004 are connected by an edge. Nodes 1 and 1001 are connected by an edge. There is a link between nodes 1 and 1009. There is a connection between 1 and 10. There is an edge between nodes 1 and 1002.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8580714257015711964", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a link between nodes 1 and 100. Nodes 1 and 10 are connected by an edge. There is an edge between nodes 1 and 1006. There are eleven nodes: 1007, 10, 1001, 1002, 1003, 1, 1000, 1005, 1006, 1004 and 100. Vertices 1 and 1005 are connected. There is an edge between nodes 1 and 1007. There is a link between nodes 1 and 1001. There is an edge between nodes 1 and 1002. There is a connection between 1 and 1004.", "output": "edge(1,10). edge(1,100). edge(1,1001). edge(1,1002). edge(1,1004). edge(1,1005). edge(1,1006). edge(1,1007). node(1007) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1005) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 100. Nodes 1 and 10 are connected by an edge. There is an edge between nodes 1 and 1006. There are eleven nodes: 1007, 10, 1001, 1002, 1003, 1, 1000, 1005, 1006, 1004 and 100. Vertices 1 and 1005 are connected. There is an edge between nodes 1 and 1007. There is a link between nodes 1 and 1001. There is an edge between nodes 1 and 1002. There is a connection between 1 and 1004.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1400390797096393366", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 1008. There is a link between nodes 1 and 1005. There is a connection between 1 and 1001. There is a connection between 1 and 1004. There are eleven nodes: 1008, 10, 1001, 1002, 1003, 1, 1000, 1005, 1006, 1004 and 100. There is a connection between 1 and 1002. There is a link between nodes 1 and 1006. Nodes 1 and 1000 are connected by an edge. Nodes 1 and 100 are connected by an edge.", "output": "edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1004). edge(1,1005). edge(1,1006). edge(1,1008). node(1008) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1005) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 1008. There is a link between nodes 1 and 1005. There is a connection between 1 and 1001. There is a connection between 1 and 1004. There are eleven nodes: 1008, 10, 1001, 1002, 1003, 1, 1000, 1005, 1006, 1004 and 100. There is a connection between 1 and 1002. There is a link between nodes 1 and 1006. Nodes 1 and 1000 are connected by an edge. Nodes 1 and 100 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8435373596730930769", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There are twelve nodes: 1007, 1008, 1001, 1003, 1002, 1, 1000, 1005, 100, 1006, 1004 and 10. There is an edge between nodes 1 and 1005. Vertices 1 and 10 are connected. Nodes 1 and 1003 are connected by an edge. There is a link between nodes 1 and 1006. There is a connection between 1 and 1004. Vertices 1 and 1007 are connected. There is an edge between nodes 1 and 1008. Nodes 1 and 1000 are connected by an edge.", "output": "edge(1,10). edge(1,1000). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1006). edge(1,1007). edge(1,1008). node(1007) node(1008) node(1001) node(1003) node(1002) node(1) node(1000) node(1005) node(100) node(1006) node(1004) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There are twelve nodes: 1007, 1008, 1001, 1003, 1002, 1, 1000, 1005, 100, 1006, 1004 and 10. There is an edge between nodes 1 and 1005. Vertices 1 and 10 are connected. Nodes 1 and 1003 are connected by an edge. There is a link between nodes 1 and 1006. There is a connection between 1 and 1004. Vertices 1 and 1007 are connected. There is an edge between nodes 1 and 1008. Nodes 1 and 1000 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7902566987120854912", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There are twelve nodes: 1007, 1002, 1003, 1001, 1, 1000, 1005, 1009, 1006, 100, 1004 and 10. There is a link between nodes 1 and 1005. There is a link between nodes 1 and 1006. Vertices 1 and 1002 are connected. Vertices 1 and 1004 are connected. Vertices 1 and 1003 are connected. There is a link between nodes 1 and 1007. There is a connection between 1 and 1009. Nodes 1 and 10 are connected by an edge.", "output": "edge(1,10). edge(1,1002). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1006). edge(1,1007). edge(1,1009). node(1007) node(1002) node(1003) node(1001) node(1) node(1000) node(1005) node(1009) node(1006) node(100) node(1004) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There are twelve nodes: 1007, 1002, 1003, 1001, 1, 1000, 1005, 1009, 1006, 100, 1004 and 10. There is a link between nodes 1 and 1005. There is a link between nodes 1 and 1006. Vertices 1 and 1002 are connected. Vertices 1 and 1004 are connected. Vertices 1 and 1003 are connected. There is a link between nodes 1 and 1007. There is a connection between 1 and 1009. Nodes 1 and 10 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4583600559905434548", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 104 are connected by an edge. There are eleven nodes: 104, 101, 10, 106, 1, 102, 111, 103, 11, 105 and 100. There is an edge between nodes 1 and 105. Nodes 1 and 111 are connected by an edge. There is a connection between 1 and 101. There is a connection between 1 and 102. There is an edge between nodes 1 and 11. There is a connection between 1 and 106. There is a link between nodes 1 and 100.", "output": "edge(1,100). edge(1,101). edge(1,102). edge(1,104). edge(1,105). edge(1,106). edge(1,11). edge(1,111). node(104) node(101) node(10) node(106) node(1) node(102) node(111) node(103) node(11) node(105) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 104 are connected by an edge. There are eleven nodes: 104, 101, 10, 106, 1, 102, 111, 103, 11, 105 and 100. There is an edge between nodes 1 and 105. Nodes 1 and 111 are connected by an edge. There is a connection between 1 and 101. There is a connection between 1 and 102. There is an edge between nodes 1 and 11. There is a connection between 1 and 106. There is a link between nodes 1 and 100.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7625377409794506718", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a link between nodes 1 and 1005. Vertices 1 and 1000 are connected. There is a link between nodes 1 and 1006. Nodes 1 and 100 are connected by an edge. There is an edge between nodes 1 and 1001. There is a link between nodes 1 and 1004. There is a connection between 1 and 1002. There are eleven nodes: 1007, 10, 1001, 1002, 1003, 1, 1000, 1005, 1006, 1004 and 100. There is a link between nodes 1 and 1007.", "output": "edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1004). edge(1,1005). edge(1,1006). edge(1,1007). node(1007) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1005) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 1005. Vertices 1 and 1000 are connected. There is a link between nodes 1 and 1006. Nodes 1 and 100 are connected by an edge. There is an edge between nodes 1 and 1001. There is a link between nodes 1 and 1004. There is a connection between 1 and 1002. There are eleven nodes: 1007, 10, 1001, 1002, 1003, 1, 1000, 1005, 1006, 1004 and 100. There is a link between nodes 1 and 1007.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5252303456256615548", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is an edge between nodes 1 and 1003. There is a connection between 1 and 1004. There is a link between nodes 1 and 10. Vertices 1 and 1005 are connected. Nodes 1 and 100 are connected by an edge. There is a link between nodes 1 and 1001. Vertices 1 and 1006 are connected. There are ten nodes: 10, 1001, 1003, 1002, 1, 1000, 1005, 1006, 1004 and 100. There is a connection between 1 and 1000.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1006). node(10) node(1001) node(1003) node(1002) node(1) node(1000) node(1005) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 1003. There is a connection between 1 and 1004. There is a link between nodes 1 and 10. Vertices 1 and 1005 are connected. Nodes 1 and 100 are connected by an edge. There is a link between nodes 1 and 1001. Vertices 1 and 1006 are connected. There are ten nodes: 10, 1001, 1003, 1002, 1, 1000, 1005, 1006, 1004 and 100. There is a connection between 1 and 1000.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8126783374720179298", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 1001 are connected by an edge. Vertices 1 and 10 are connected. Nodes 1 and 100 are connected by an edge. Vertices 1 and 1005 are connected. There is a link between nodes 1 and 1004. There is a connection between 1 and 1002. There are nine nodes: 10, 1001, 1002, 1003, 1, 1000, 1005, 1004 and 100. Nodes 1 and 1003 are connected by an edge. There is a connection between 1 and 1000.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1003). edge(1,1004). edge(1,1005). node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1005) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 1001 are connected by an edge. Vertices 1 and 10 are connected. Nodes 1 and 100 are connected by an edge. Vertices 1 and 1005 are connected. There is a link between nodes 1 and 1004. There is a connection between 1 and 1002. There are nine nodes: 10, 1001, 1002, 1003, 1, 1000, 1005, 1004 and 100. Nodes 1 and 1003 are connected by an edge. There is a connection between 1 and 1000.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3098154878104394907", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Vertices 1 and 10 are connected. There are ten nodes: 1007, 10, 1001, 1002, 1003, 1, 1000, 1006, 1004 and 100. There is a link between nodes 1 and 1001. There is a link between nodes 1 and 1000. Vertices 1 and 1007 are connected. Vertices 1 and 1002 are connected. There is a connection between 1 and 1006. There is a connection between 1 and 100. Nodes 1 and 1003 are connected by an edge.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1003). edge(1,1006). edge(1,1007). node(1007) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Vertices 1 and 10 are connected. There are ten nodes: 1007, 10, 1001, 1002, 1003, 1, 1000, 1006, 1004 and 100. There is a link between nodes 1 and 1001. There is a link between nodes 1 and 1000. Vertices 1 and 1007 are connected. Vertices 1 and 1002 are connected. There is a connection between 1 and 1006. There is a connection between 1 and 100. Nodes 1 and 1003 are connected by an edge.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7385529885456713156", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 1008 are connected by an edge. There is an edge between nodes 1 and 1006. There is a link between nodes 1 and 1009. There are thirteen nodes: 1010, 1008, 1001, 1002, 1003, 1, 1000, 100, 1006, 1012, 1004, 1009 and 10. Nodes 1 and 1010 are connected by an edge. Nodes 1 and 1012 are connected by an edge. Nodes 1 and 1001 are connected by an edge. There is a connection between 1 and 1000. Vertices 1 and 10 are connected.", "output": "edge(1,10). edge(1,1000). edge(1,1001). edge(1,1006). edge(1,1008). edge(1,1009). edge(1,1010). edge(1,1012). node(1010) node(1008) node(1001) node(1002) node(1003) node(1) node(1000) node(100) node(1006) node(1012) node(1004) node(1009) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 1008 are connected by an edge. There is an edge between nodes 1 and 1006. There is a link between nodes 1 and 1009. There are thirteen nodes: 1010, 1008, 1001, 1002, 1003, 1, 1000, 100, 1006, 1012, 1004, 1009 and 10. Nodes 1 and 1010 are connected by an edge. Nodes 1 and 1012 are connected by an edge. Nodes 1 and 1001 are connected by an edge. There is a connection between 1 and 1000. Vertices 1 and 10 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7263141912582982114", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 108 are connected by an edge. There is a connection between 1 and 112. Nodes 1 and 106 are connected by an edge. There is an edge between nodes 1 and 105. Nodes 1 and 107 are connected by an edge. There are thirteen nodes: 107, 104, 101, 108, 106, 1, 102, 103, 112, 100, 105, 110 and 10. Vertices 1 and 110 are connected. There is an edge between nodes 1 and 101. Vertices 1 and 103 are connected.", "output": "edge(1,101). edge(1,103). edge(1,105). edge(1,106). edge(1,107). edge(1,108). edge(1,110). edge(1,112). node(107) node(104) node(101) node(108) node(106) node(1) node(102) node(103) node(112) node(100) node(105) node(110) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 108 are connected by an edge. There is a connection between 1 and 112. Nodes 1 and 106 are connected by an edge. There is an edge between nodes 1 and 105. Nodes 1 and 107 are connected by an edge. There are thirteen nodes: 107, 104, 101, 108, 106, 1, 102, 103, 112, 100, 105, 110 and 10. Vertices 1 and 110 are connected. There is an edge between nodes 1 and 101. Vertices 1 and 103 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1562993391214339007", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 10. Nodes 1 and 100 are connected by an edge. Nodes 1 and 1008 are connected by an edge. There is an edge between nodes 1 and 1011. There are thirteen nodes: 101, 1008, 10, 1001, 1002, 1003, 1, 1011, 1000, 1006, 1004, 1009 and 100. There is a link between nodes 1 and 1001. There is an edge between nodes 1 and 1009. There is a link between nodes 1 and 101. Vertices 1 and 1006 are connected.", "output": "edge(1,10). edge(1,100). edge(1,1001). edge(1,1006). edge(1,1008). edge(1,1009). edge(1,101). edge(1,1011). node(101) node(1008) node(10) node(1001) node(1002) node(1003) node(1) node(1011) node(1000) node(1006) node(1004) node(1009) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 10. Nodes 1 and 100 are connected by an edge. Nodes 1 and 1008 are connected by an edge. There is an edge between nodes 1 and 1011. There are thirteen nodes: 101, 1008, 10, 1001, 1002, 1003, 1, 1011, 1000, 1006, 1004, 1009 and 100. There is a link between nodes 1 and 1001. There is an edge between nodes 1 and 1009. There is a link between nodes 1 and 101. Vertices 1 and 1006 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "249266760730306211", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a link between nodes 1 and 1007. There are thirteen nodes: 1007, 1008, 10, 1001, 1003, 1002, 1, 1000, 1005, 1006, 1004, 1009 and 100. There is a connection between 1 and 1009. There is a link between nodes 1 and 100. Nodes 1 and 1000 are connected by an edge. There is an edge between nodes 1 and 1003. Nodes 1 and 1005 are connected by an edge. Vertices 1 and 1008 are connected. There is a link between nodes 1 and 1006.", "output": "edge(1,100). edge(1,1000). edge(1,1003). edge(1,1005). edge(1,1006). edge(1,1007). edge(1,1008). edge(1,1009). node(1007) node(1008) node(10) node(1001) node(1003) node(1002) node(1) node(1000) node(1005) node(1006) node(1004) node(1009) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 1007. There are thirteen nodes: 1007, 1008, 10, 1001, 1003, 1002, 1, 1000, 1005, 1006, 1004, 1009 and 100. There is a connection between 1 and 1009. There is a link between nodes 1 and 100. Nodes 1 and 1000 are connected by an edge. There is an edge between nodes 1 and 1003. Nodes 1 and 1005 are connected by an edge. Vertices 1 and 1008 are connected. There is a link between nodes 1 and 1006.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1086819217688606822", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is an edge between nodes 1 and 100. Nodes 1 and 103 are connected by an edge. There is an edge between nodes 1 and 1000. Vertices 1 and 104 are connected. Vertices 1 and 102 are connected. There are nine nodes: 104, 101, 10, 1, 102, 1000, 103, 105 and 100. Vertices 1 and 105 are connected. Nodes 1 and 10 are connected by an edge. There is a connection between 1 and 101.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,101). edge(1,102). edge(1,103). edge(1,104). edge(1,105). node(104) node(101) node(10) node(1) node(102) node(1000) node(103) node(105) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 100. Nodes 1 and 103 are connected by an edge. There is an edge between nodes 1 and 1000. Vertices 1 and 104 are connected. Vertices 1 and 102 are connected. There are nine nodes: 104, 101, 10, 1, 102, 1000, 103, 105 and 100. Vertices 1 and 105 are connected. Nodes 1 and 10 are connected by an edge. There is a connection between 1 and 101.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4532402061628108695", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a link between nodes 1 and 1001. There is a link between nodes 1 and 1003. There is a connection between 1 and 1007. There is a connection between 1 and 1002. There is an edge between nodes 1 and 1006. Vertices 1 and 1009 are connected. Vertices 1 and 10 are connected. There is a connection between 1 and 101. There are twelve nodes: 1007, 101, 1001, 1003, 1002, 1, 1000, 100, 1006, 1004, 1009 and 10.", "output": "edge(1,10). edge(1,1001). edge(1,1002). edge(1,1003). edge(1,1006). edge(1,1007). edge(1,1009). edge(1,101). node(1007) node(101) node(1001) node(1003) node(1002) node(1) node(1000) node(100) node(1006) node(1004) node(1009) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 1001. There is a link between nodes 1 and 1003. There is a connection between 1 and 1007. There is a connection between 1 and 1002. There is an edge between nodes 1 and 1006. Vertices 1 and 1009 are connected. Vertices 1 and 10 are connected. There is a connection between 1 and 101. There are twelve nodes: 1007, 101, 1001, 1003, 1002, 1, 1000, 100, 1006, 1004, 1009 and 10.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6993074628071428006", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 1005. There is a connection between 1 and 1008. Nodes 1 and 1010 are connected by an edge. There are thirteen nodes: 1010, 1008, 10, 1013, 1003, 1001, 1, 1002, 1000, 1005, 1009, 1004 and 100. Nodes 1 and 1013 are connected by an edge. There is a connection between 1 and 100. Nodes 1 and 1003 are connected by an edge. Nodes 1 and 1009 are connected by an edge. Vertices 1 and 1004 are connected.", "output": "edge(1,100). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1008). edge(1,1009). edge(1,1010). edge(1,1013). node(1010) node(1008) node(10) node(1013) node(1003) node(1001) node(1) node(1002) node(1000) node(1005) node(1009) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 1005. There is a connection between 1 and 1008. Nodes 1 and 1010 are connected by an edge. There are thirteen nodes: 1010, 1008, 10, 1013, 1003, 1001, 1, 1002, 1000, 1005, 1009, 1004 and 100. Nodes 1 and 1013 are connected by an edge. There is a connection between 1 and 100. Nodes 1 and 1003 are connected by an edge. Nodes 1 and 1009 are connected by an edge. Vertices 1 and 1004 are connected.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3291519713974640877", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a link between nodes 1 and 100. Nodes 1 and 1003 are connected by an edge. There is a connection between 1 and 1001. Nodes 1 and 1000 are connected by an edge. Vertices 1 and 1004 are connected. There is a connection between 1 and 10. There is a connection between 1 and 1008. There are ten nodes: 1008, 10, 1001, 1003, 1002, 1, 1000, 1006, 1004 and 100. There is a connection between 1 and 1006.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1003). edge(1,1004). edge(1,1006). edge(1,1008). node(1008) node(10) node(1001) node(1003) node(1002) node(1) node(1000) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a link between nodes 1 and 100. Nodes 1 and 1003 are connected by an edge. There is a connection between 1 and 1001. Nodes 1 and 1000 are connected by an edge. Vertices 1 and 1004 are connected. There is a connection between 1 and 10. There is a connection between 1 and 1008. There are ten nodes: 1008, 10, 1001, 1003, 1002, 1, 1000, 1006, 1004 and 100. There is a connection between 1 and 1006.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4742411770677746098", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 1005. There is an edge between nodes 1 and 1008. Vertices 1 and 1004 are connected. There is an edge between nodes 1 and 1003. Nodes 1 and 10 are connected by an edge. Vertices 1 and 1007 are connected. There is a link between nodes 1 and 100. Vertices 1 and 1010 are connected. There are twelve nodes: 1007, 1010, 1008, 10, 1001, 1003, 1002, 1, 1000, 1005, 1004 and 100.", "output": "edge(1,10). edge(1,100). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1007). edge(1,1008). edge(1,1010). node(1007) node(1010) node(1008) node(10) node(1001) node(1003) node(1002) node(1) node(1000) node(1005) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 1005. There is an edge between nodes 1 and 1008. Vertices 1 and 1004 are connected. There is an edge between nodes 1 and 1003. Nodes 1 and 10 are connected by an edge. Vertices 1 and 1007 are connected. There is a link between nodes 1 and 100. Vertices 1 and 1010 are connected. There are twelve nodes: 1007, 1010, 1008, 10, 1001, 1003, 1002, 1, 1000, 1005, 1004 and 100.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3834328060670255132", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 1005 are connected by an edge. There is a link between nodes 1 and 1007. There is a connection between 1 and 1006. Vertices 1 and 10 are connected. There are eleven nodes: 1007, 10, 1002, 1003, 1001, 1, 1000, 1005, 1006, 1004 and 100. Nodes 1 and 1002 are connected by an edge. There is an edge between nodes 1 and 100. There is an edge between nodes 1 and 1004. There is an edge between nodes 1 and 1003.", "output": "edge(1,10). edge(1,100). edge(1,1002). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1006). edge(1,1007). node(1007) node(10) node(1002) node(1003) node(1001) node(1) node(1000) node(1005) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 1005 are connected by an edge. There is a link between nodes 1 and 1007. There is a connection between 1 and 1006. Vertices 1 and 10 are connected. There are eleven nodes: 1007, 10, 1002, 1003, 1001, 1, 1000, 1005, 1006, 1004 and 100. Nodes 1 and 1002 are connected by an edge. There is an edge between nodes 1 and 100. There is an edge between nodes 1 and 1004. There is an edge between nodes 1 and 1003.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "511554351771212276", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 1007. There is a link between nodes 1 and 1014. Nodes 1 and 1009 are connected by an edge. There is a connection between 1 and 1010. There is a connection between 1 and 1002. There is a link between nodes 1 and 1001. There are thirteen nodes: 1007, 1010, 10, 1001, 1002, 1003, 1, 1000, 1014, 1006, 1004, 1009 and 100. There is an edge between nodes 1 and 100. There is an edge between nodes 1 and 1006.", "output": "edge(1,100). edge(1,1001). edge(1,1002). edge(1,1006). edge(1,1007). edge(1,1009). edge(1,1010). edge(1,1014). node(1007) node(1010) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1014) node(1006) node(1004) node(1009) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 1007. There is a link between nodes 1 and 1014. Nodes 1 and 1009 are connected by an edge. There is a connection between 1 and 1010. There is a connection between 1 and 1002. There is a link between nodes 1 and 1001. There are thirteen nodes: 1007, 1010, 10, 1001, 1002, 1003, 1, 1000, 1014, 1006, 1004, 1009 and 100. There is an edge between nodes 1 and 100. There is an edge between nodes 1 and 1006.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3491459261188368122", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 1001 are connected by an edge. There is a link between nodes 1 and 1004. There is a link between nodes 1 and 100. Vertices 1 and 1009 are connected. There are ten nodes: 10, 1001, 1003, 1002, 1, 1000, 1009, 1006, 1004 and 100. There is an edge between nodes 1 and 1006. There is a connection between 1 and 1000. Nodes 1 and 1003 are connected by an edge. There is an edge between nodes 1 and 10.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1003). edge(1,1004). edge(1,1006). edge(1,1009). node(10) node(1001) node(1003) node(1002) node(1) node(1000) node(1009) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 1001 are connected by an edge. There is a link between nodes 1 and 1004. There is a link between nodes 1 and 100. Vertices 1 and 1009 are connected. There are ten nodes: 10, 1001, 1003, 1002, 1, 1000, 1009, 1006, 1004 and 100. There is an edge between nodes 1 and 1006. There is a connection between 1 and 1000. Nodes 1 and 1003 are connected by an edge. There is an edge between nodes 1 and 10.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4398579118291073857", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 1012 are connected by an edge. Nodes 1 and 1008 are connected by an edge. Vertices 1 and 1002 are connected. Nodes 1 and 10 are connected by an edge. Nodes 1 and 1005 are connected by an edge. There is a link between nodes 1 and 1003. There is a connection between 1 and 1004. There is an edge between nodes 1 and 101. There are twelve nodes: 101, 1008, 1002, 1003, 1001, 1, 1000, 1005, 100, 1012, 1004 and 10.", "output": "edge(1,10). edge(1,1002). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1008). edge(1,101). edge(1,1012). node(101) node(1008) node(1002) node(1003) node(1001) node(1) node(1000) node(1005) node(100) node(1012) node(1004) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 1012 are connected by an edge. Nodes 1 and 1008 are connected by an edge. Vertices 1 and 1002 are connected. Nodes 1 and 10 are connected by an edge. Nodes 1 and 1005 are connected by an edge. There is a link between nodes 1 and 1003. There is a connection between 1 and 1004. There is an edge between nodes 1 and 101. There are twelve nodes: 101, 1008, 1002, 1003, 1001, 1, 1000, 1005, 100, 1012, 1004 and 10.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7216192152431565323", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is an edge between nodes 1 and 1002. There is a link between nodes 1 and 1000. Nodes 1 and 1004 are connected by an edge. There is a link between nodes 1 and 10. Nodes 1 and 1003 are connected by an edge. There is a link between nodes 1 and 1001. There is an edge between nodes 1 and 1005. There are nine nodes: 10, 1001, 1002, 1003, 1, 1000, 1005, 1004 and 100. There is a connection between 1 and 100.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1003). edge(1,1004). edge(1,1005). node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1005) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is an edge between nodes 1 and 1002. There is a link between nodes 1 and 1000. Nodes 1 and 1004 are connected by an edge. There is a link between nodes 1 and 10. Nodes 1 and 1003 are connected by an edge. There is a link between nodes 1 and 1001. There is an edge between nodes 1 and 1005. There are nine nodes: 10, 1001, 1002, 1003, 1, 1000, 1005, 1004 and 100. There is a connection between 1 and 100.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2447033439532444279", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There are twelve nodes: 101, 1010, 1008, 1001, 1003, 1002, 1, 1000, 1005, 100, 1004 and 10. Nodes 1 and 1005 are connected by an edge. There is a link between nodes 1 and 1004. There is a link between nodes 1 and 10. There is an edge between nodes 1 and 1003. There is an edge between nodes 1 and 101. Vertices 1 and 1001 are connected. There is a connection between 1 and 1008. There is a connection between 1 and 1010.", "output": "edge(1,10). edge(1,1001). edge(1,1003). edge(1,1004). edge(1,1005). edge(1,1008). edge(1,101). edge(1,1010). node(101) node(1010) node(1008) node(1001) node(1003) node(1002) node(1) node(1000) node(1005) node(100) node(1004) node(10)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There are twelve nodes: 101, 1010, 1008, 1001, 1003, 1002, 1, 1000, 1005, 100, 1004 and 10. Nodes 1 and 1005 are connected by an edge. There is a link between nodes 1 and 1004. There is a link between nodes 1 and 10. There is an edge between nodes 1 and 1003. There is an edge between nodes 1 and 101. Vertices 1 and 1001 are connected. There is a connection between 1 and 1008. There is a connection between 1 and 1010.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "819340435982743744", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 1001. Vertices 1 and 100 are connected. There is a connection between 1 and 1006. There is a connection between 1 and 1008. Nodes 1 and 10 are connected by an edge. There are eleven nodes: 1008, 10, 1001, 1002, 1003, 1, 1000, 1009, 1006, 1004 and 100. There is a connection between 1 and 1002. Nodes 1 and 1009 are connected by an edge. There is a connection between 1 and 1004.", "output": "edge(1,10). edge(1,100). edge(1,1001). edge(1,1002). edge(1,1004). edge(1,1006). edge(1,1008). edge(1,1009). node(1008) node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1009) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 1001. Vertices 1 and 100 are connected. There is a connection between 1 and 1006. There is a connection between 1 and 1008. Nodes 1 and 10 are connected by an edge. There are eleven nodes: 1008, 10, 1001, 1002, 1003, 1, 1000, 1009, 1006, 1004 and 100. There is a connection between 1 and 1002. Nodes 1 and 1009 are connected by an edge. There is a connection between 1 and 1004.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1848934821793728014", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "Nodes 1 and 1006 are connected by an edge. There is a link between nodes 1 and 1005. There are eleven nodes: 1007, 10, 1002, 1003, 1001, 1, 1000, 1005, 1006, 1004 and 100. Nodes 1 and 10 are connected by an edge. There is an edge between nodes 1 and 1003. There is a connection between 1 and 1007. Nodes 1 and 100 are connected by an edge. There is an edge between nodes 1 and 1000. There is a link between nodes 1 and 1002.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1002). edge(1,1003). edge(1,1005). edge(1,1006). edge(1,1007). node(1007) node(10) node(1002) node(1003) node(1001) node(1) node(1000) node(1005) node(1006) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```Nodes 1 and 1006 are connected by an edge. There is a link between nodes 1 and 1005. There are eleven nodes: 1007, 10, 1002, 1003, 1001, 1, 1000, 1005, 1006, 1004 and 100. Nodes 1 and 10 are connected by an edge. There is an edge between nodes 1 and 1003. There is a connection between 1 and 1007. Nodes 1 and 100 are connected by an edge. There is an edge between nodes 1 and 1000. There is a link between nodes 1 and 1002.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4673200176198594564", "problem_id": "17", "problem_name": "Maximal Clique Problem", "description": "This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).", "format": "As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary", "text": "There is a connection between 1 and 10. There are nine nodes: 10, 1001, 1002, 1003, 1, 1000, 1005, 1004 and 100. There is an edge between nodes 1 and 100. Vertices 1 and 1001 are connected. There is a connection between 1 and 1000. There is an edge between nodes 1 and 1003. Vertices 1 and 1002 are connected. There is a link between nodes 1 and 1004. There is a connection between 1 and 1005.", "output": "edge(1,10). edge(1,100). edge(1,1000). edge(1,1001). edge(1,1002). edge(1,1003). edge(1,1004). edge(1,1005). node(10) node(1001) node(1002) node(1003) node(1) node(1000) node(1005) node(1004) node(100)", "prompt": "Given the following problem description between triple backtips: \n ```This is the problem of finding a maximal clique C in an undirected graph G. That is, for each other clique C' in G, the number of nodes in C should be larger than or equal to the number of nodes in C'.\nAs input, a directed graph is given, encoded by facts over the predicates node/1 and edge/2, providing respectively the nodes and the edges. A solution to the problem is a maximal clique in the undirected version of the input graph (i.e., in the symmetric closure of the input graph). A solution is encoded by the predicate clique/1: the set of nodes v such that clique(v) holds should form a maximal clique (possibly one of maximum cardinality).```\nGiven the following specification for the predicates format: \n```As input, a directed graph is given. An instance is a sequence of facts (atoms followed by the dot \".\" character) with only predicates of the input vocabulary, possibly separated by spaces and line breaks. A solution is the largest clique in the symmetric closure of this input graph. The nodes of the input graph are given by facts of the form node(i). The edges of the graph are given by facts of the form edge(i,j). Examples for facts: node(a)., edge(a,b). The terms a and b are positive integers belonging to the vocabulary```\nExtract the datalog facts from this text: \n```There is a connection between 1 and 10. There are nine nodes: 10, 1001, 1002, 1003, 1, 1000, 1005, 1004 and 100. There is an edge between nodes 1 and 100. Vertices 1 and 1001 are connected. There is a connection between 1 and 1000. There is an edge between nodes 1 and 1003. Vertices 1 and 1002 are connected. There is a link between nodes 1 and 1004. There is a connection between 1 and 1005.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1028538669983112421", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The object p1 begins at location l3. The package p2 must stay at location l0. The cost of traveling from l1 to l0 is one unit/s. It requires four unit/s to travel between l5 and l0. Traveling between locations l0 and l1 costs one unit/s. Object p0 is initially located at l5. The object p5 is positioned at location l1 initially. The cost of traveling from l4 to l3 is thirteen unit/s. Initially, p3 is found at location l0. The final location for package p3 is l5. four unit/s are required to travel between locations l0 and l5. The package p5 must remain at location l5. The fuel amount in truck t0 at the beginning is forty-two. twenty-four unit/s are required to travel between locations l5 and l2. Initially, p2 is found at location l4. The travel cost between l2 and l5 is twenty-four unit/s. The package p0 must stay at location l2. Initially, p4 is found at location l2. Object t0 is initially located at l3. The destination for package p4 is l0. thirteen unit/s are required to travel between locations l3 and l4. The final location for package p1 is l2. Eight steps are provided: step 1 to step 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l5). at(p1,l3). at(p2,l4). at(p3,l0). at(p4,l2). at(p5,l1). at(t0,l3). fuel(t0,42). fuelcost(1,l0,l1). fuelcost(1,l1,l0). fuelcost(13,l3,l4). fuelcost(13,l4,l3). fuelcost(24,l2,l5). fuelcost(24,l5,l2). fuelcost(4,l0,l5). fuelcost(4,l5,l0). goal(p0,l2). goal(p1,l2). goal(p2,l0). goal(p3,l5). goal(p4,l0). goal(p5,l5).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The object p1 begins at location l3. The package p2 must stay at location l0. The cost of traveling from l1 to l0 is one unit/s. It requires four unit/s to travel between l5 and l0. Traveling between locations l0 and l1 costs one unit/s. Object p0 is initially located at l5. The object p5 is positioned at location l1 initially. The cost of traveling from l4 to l3 is thirteen unit/s. Initially, p3 is found at location l0. The final location for package p3 is l5. four unit/s are required to travel between locations l0 and l5. The package p5 must remain at location l5. The fuel amount in truck t0 at the beginning is forty-two. twenty-four unit/s are required to travel between locations l5 and l2. Initially, p2 is found at location l4. The travel cost between l2 and l5 is twenty-four unit/s. The package p0 must stay at location l2. Initially, p4 is found at location l2. Object t0 is initially located at l3. The destination for package p4 is l0. thirteen unit/s are required to travel between locations l3 and l4. The final location for package p1 is l2. Eight steps are provided: step 1 to step 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6442984147896199770", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Package p4 will be delivered to l4. The package p1 must remain at location l4. It requires eighteen unit/s to travel between l4 and l0. The package p0 must remain at location l0. The starting location of object t0 is l3. It cost one unit/s for traveling between locations l3 and l2. The final location for package p3 is l1. Truck t0 is provided with forty-seven fuel initially. Initially, p3 is found at location l0. The travel cost between l4 and l2 is eleven unit/s. The destination for package p2 is l3. It takes eighteen unit/s to travel between locations l0 and l4. Traveling between locations l4 and l1 costs seventeen unit/s. The starting location of object p0 is l3. The object p4 is initially at location l2. Eight steps can be followed, from step 1 to step 8. Initially, p2 is found at location l4. Initially, p1 is found at location l2. It requires one unit/s to travel between l2 and l3. The cost of traveling from l2 to l4 is eleven unit/s. Traveling between locations l1 and l4 costs seventeen unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l3). at(p1,l2). at(p2,l4). at(p3,l0). at(p4,l2). at(t0,l3). fuel(t0,47). fuelcost(1,l2,l3). fuelcost(1,l3,l2). fuelcost(11,l2,l4). fuelcost(11,l4,l2). fuelcost(17,l1,l4). fuelcost(17,l4,l1). fuelcost(18,l0,l4). fuelcost(18,l4,l0). goal(p0,l0). goal(p1,l4). goal(p2,l3). goal(p3,l1). goal(p4,l4).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Package p4 will be delivered to l4. The package p1 must remain at location l4. It requires eighteen unit/s to travel between l4 and l0. The package p0 must remain at location l0. The starting location of object t0 is l3. It cost one unit/s for traveling between locations l3 and l2. The final location for package p3 is l1. Truck t0 is provided with forty-seven fuel initially. Initially, p3 is found at location l0. The travel cost between l4 and l2 is eleven unit/s. The destination for package p2 is l3. It takes eighteen unit/s to travel between locations l0 and l4. Traveling between locations l4 and l1 costs seventeen unit/s. The starting location of object p0 is l3. The object p4 is initially at location l2. Eight steps can be followed, from step 1 to step 8. Initially, p2 is found at location l4. Initially, p1 is found at location l2. It requires one unit/s to travel between l2 and l3. The cost of traveling from l2 to l4 is eleven unit/s. Traveling between locations l1 and l4 costs seventeen unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2020893337165660356", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The last location for package p2 is l1. The cost of traveling from l2 to l3 is eighteen unit/s. The cost of traveling from l3 to l0 is eighteen unit/s. The destination for package p0 is l3. The starting location of object t0 is l3. The starting location of object p0 is l1. The package p1 must stay at location l1. It cost eleven unit/s for traveling between locations l3 and l1. It cost eleven unit/s for traveling between locations l1 and l3. The starting location of object p3 is l1. The starting location of object p1 is l0. It takes eighteen unit/s to travel between locations l0 and l3. It takes twenty-two unit/s to travel between locations l1 and l2. The object p2 is positioned at location l2 initially. It cost eighteen unit/s for traveling between locations l3 and l2. Truck t0 has an initial fuel amount of fifty-two. It requires twenty-two unit/s to travel between l2 and l1. The destination for package p3 is l2. Eight steps can be followed, from step 1 to step 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l1). at(p1,l0). at(p2,l2). at(p3,l1). at(t0,l3). fuel(t0,52). fuelcost(11,l1,l3). fuelcost(11,l3,l1). fuelcost(18,l0,l3). fuelcost(18,l2,l3). fuelcost(18,l3,l0). fuelcost(18,l3,l2). fuelcost(22,l1,l2). fuelcost(22,l2,l1). goal(p0,l3). goal(p1,l1). goal(p2,l1). goal(p3,l2).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The last location for package p2 is l1. The cost of traveling from l2 to l3 is eighteen unit/s. The cost of traveling from l3 to l0 is eighteen unit/s. The destination for package p0 is l3. The starting location of object t0 is l3. The starting location of object p0 is l1. The package p1 must stay at location l1. It cost eleven unit/s for traveling between locations l3 and l1. It cost eleven unit/s for traveling between locations l1 and l3. The starting location of object p3 is l1. The starting location of object p1 is l0. It takes eighteen unit/s to travel between locations l0 and l3. It takes twenty-two unit/s to travel between locations l1 and l2. The object p2 is positioned at location l2 initially. It cost eighteen unit/s for traveling between locations l3 and l2. Truck t0 has an initial fuel amount of fifty-two. It requires twenty-two unit/s to travel between l2 and l1. The destination for package p3 is l2. Eight steps can be followed, from step 1 to step 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9163330426780682305", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Initially, p5 is found at location l1. It requires twelve unit/s to travel between l3 and l5. The object p0 is initially at location l5. It cost ten unit/s for traveling between locations l5 and l2. The starting location of object p1 is l5. A total of eight steps are available: step 1 to step 8. The last location for package p5 is l3. The starting fuel for truck t0 is fifty-six. The travel cost between l1 and l3 is twelve unit/s. The travel cost between l5 and l3 is twelve unit/s. The cost of traveling from l3 to l1 is twelve unit/s. Initially, p3 is found at location l0. The object p4 begins at location l1. The object p2 is initially at location l1. It takes ten unit/s to travel between locations l2 and l5. twelve unit/s are required to travel between locations l0 and l5. Initially, t0 is found at location l4. The cost of traveling from l5 to l0 is twelve unit/s. The package p2 must remain at location l5. The last location for package p4 is l4. The destination for package p1 is l4. Package p3 will be delivered to l2. The package p0 must stay at location l3.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l5). at(p1,l5). at(p2,l1). at(p3,l0). at(p4,l1). at(p5,l1). at(t0,l4). fuel(t0,56). fuelcost(10,l2,l5). fuelcost(10,l5,l2). fuelcost(12,l0,l5). fuelcost(12,l1,l3). fuelcost(12,l3,l1). fuelcost(12,l3,l5). fuelcost(12,l5,l0). fuelcost(12,l5,l3). goal(p0,l3). goal(p1,l4). goal(p2,l5). goal(p3,l2). goal(p4,l4). goal(p5,l3).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Initially, p5 is found at location l1. It requires twelve unit/s to travel between l3 and l5. The object p0 is initially at location l5. It cost ten unit/s for traveling between locations l5 and l2. The starting location of object p1 is l5. A total of eight steps are available: step 1 to step 8. The last location for package p5 is l3. The starting fuel for truck t0 is fifty-six. The travel cost between l1 and l3 is twelve unit/s. The travel cost between l5 and l3 is twelve unit/s. The cost of traveling from l3 to l1 is twelve unit/s. Initially, p3 is found at location l0. The object p4 begins at location l1. The object p2 is initially at location l1. It takes ten unit/s to travel between locations l2 and l5. twelve unit/s are required to travel between locations l0 and l5. Initially, t0 is found at location l4. The cost of traveling from l5 to l0 is twelve unit/s. The package p2 must remain at location l5. The last location for package p4 is l4. The destination for package p1 is l4. Package p3 will be delivered to l2. The package p0 must stay at location l3.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1769308880953018441", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The last location for package p0 is l0. The object p7 begins at location l7. It requires twelve unit/s to travel between l0 and l1. It cost eleven unit/s for traveling between locations l4 and l1. The final location for package p6 is l1. The destination for package p4 is l6. Object p0 is initially located at l2. The starting location of object p4 is l7. The last location for package p7 is l0. Initially, p5 is found at location l6. The object p1 is initially at location l5. The package p5 must remain at location l1. Traveling between locations l1 and l4 costs eleven unit/s. fourteen unit/s are required to travel between locations l1 and l6. The object p3 is positioned at location l6 initially. The fuel amount in truck t0 at the beginning is one hundred and twenty-three. It takes one unit/s to travel between locations l2 and l3. Object p2 is initially located at l7. Eight steps can be followed, from step 1 to step 8. It takes one unit/s to travel between locations l3 and l2. The final location for package p1 is l0. The package p3 must stay at location l3. The package p2 must stay at location l6. Initially, p6 is found at location l0. It cost fourteen unit/s for traveling between locations l6 and l1. The travel cost between l1 and l0 is twelve unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l2). at(p1,l5). at(p2,l7). at(p3,l6). at(p4,l7). at(p5,l6). at(p6,l0). at(p7,l7). fuel(t0,123). fuelcost(1,l2,l3). fuelcost(1,l3,l2). fuelcost(11,l1,l4). fuelcost(11,l4,l1). fuelcost(12,l0,l1). fuelcost(12,l1,l0). fuelcost(14,l1,l6). fuelcost(14,l6,l1). goal(p0,l0). goal(p1,l0). goal(p2,l6). goal(p3,l3). goal(p4,l6). goal(p5,l1). goal(p6,l1). goal(p7,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The last location for package p0 is l0. The object p7 begins at location l7. It requires twelve unit/s to travel between l0 and l1. It cost eleven unit/s for traveling between locations l4 and l1. The final location for package p6 is l1. The destination for package p4 is l6. Object p0 is initially located at l2. The starting location of object p4 is l7. The last location for package p7 is l0. Initially, p5 is found at location l6. The object p1 is initially at location l5. The package p5 must remain at location l1. Traveling between locations l1 and l4 costs eleven unit/s. fourteen unit/s are required to travel between locations l1 and l6. The object p3 is positioned at location l6 initially. The fuel amount in truck t0 at the beginning is one hundred and twenty-three. It takes one unit/s to travel between locations l2 and l3. Object p2 is initially located at l7. Eight steps can be followed, from step 1 to step 8. It takes one unit/s to travel between locations l3 and l2. The final location for package p1 is l0. The package p3 must stay at location l3. The package p2 must stay at location l6. Initially, p6 is found at location l0. It cost fourteen unit/s for traveling between locations l6 and l1. The travel cost between l1 and l0 is twelve unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1933470220184286338", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Initially, p0 is found at location l4. It cost ten unit/s for traveling between locations l3 and l4. The object p1 begins at location l4. Package p4 will be delivered to l0. The travel cost between l3 and l1 is nineteen unit/s. The object p3 begins at location l3. It takes ten unit/s to travel between locations l4 and l3. The object p4 is positioned at location l2 initially. The fuel amount in truck t0 at the beginning is thirty-six. It takes sixteen unit/s to travel between locations l4 and l0. Object t0 is initially located at l0. nineteen unit/s are required to travel between locations l1 and l3. The last location for package p0 is l3. It cost one unit/s for traveling between locations l0 and l2. Traveling between locations l0 and l4 costs sixteen unit/s. Package p2 will be delivered to l0. Initially, p2 is found at location l1. The final location for package p3 is l4. The package p1 must stay at location l3. Eight steps are provided: step 1 to step 8. one unit/s are required to travel between locations l2 and l0.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l4). at(p1,l4). at(p2,l1). at(p3,l3). at(p4,l2). at(t0,l0). fuel(t0,36). fuelcost(1,l0,l2). fuelcost(1,l2,l0). fuelcost(10,l3,l4). fuelcost(10,l4,l3). fuelcost(16,l0,l4). fuelcost(16,l4,l0). fuelcost(19,l1,l3). fuelcost(19,l3,l1). goal(p0,l3). goal(p1,l3). goal(p2,l0). goal(p3,l4). goal(p4,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Initially, p0 is found at location l4. It cost ten unit/s for traveling between locations l3 and l4. The object p1 begins at location l4. Package p4 will be delivered to l0. The travel cost between l3 and l1 is nineteen unit/s. The object p3 begins at location l3. It takes ten unit/s to travel between locations l4 and l3. The object p4 is positioned at location l2 initially. The fuel amount in truck t0 at the beginning is thirty-six. It takes sixteen unit/s to travel between locations l4 and l0. Object t0 is initially located at l0. nineteen unit/s are required to travel between locations l1 and l3. The last location for package p0 is l3. It cost one unit/s for traveling between locations l0 and l2. Traveling between locations l0 and l4 costs sixteen unit/s. Package p2 will be delivered to l0. Initially, p2 is found at location l1. The final location for package p3 is l4. The package p1 must stay at location l3. Eight steps are provided: step 1 to step 8. one unit/s are required to travel between locations l2 and l0.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4838237902302118802", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The final location for package p1 is l0. The initial fuel available for truck t0 is thirty-one. The cost of traveling from l2 to l3 is eleven unit/s. The travel cost between l0 and l1 is fourteen unit/s. The object p3 is positioned at location l1 initially. The last location for package p3 is l0. It cost eleven unit/s for traveling between locations l3 and l2. It requires sixteen unit/s to travel between l1 and l3. Eight allowed steps are available: step(1) through step(8). fourteen unit/s are required to travel between locations l1 and l0. It requires twelve unit/s to travel between l2 and l1. It requires twelve unit/s to travel between l1 and l2. Object p1 is initially located at l2. The starting location of object p0 is l1. sixteen unit/s are required to travel between locations l3 and l1. Package p2 will be delivered to l0. The object p2 begins at location l1. Initially, t0 is found at location l1. The destination for package p0 is l2.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l1). at(p1,l2). at(p2,l1). at(p3,l1). at(t0,l1). fuel(t0,31). fuelcost(11,l2,l3). fuelcost(11,l3,l2). fuelcost(12,l1,l2). fuelcost(12,l2,l1). fuelcost(14,l0,l1). fuelcost(14,l1,l0). fuelcost(16,l1,l3). fuelcost(16,l3,l1). goal(p0,l2). goal(p1,l0). goal(p2,l0). goal(p3,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The final location for package p1 is l0. The initial fuel available for truck t0 is thirty-one. The cost of traveling from l2 to l3 is eleven unit/s. The travel cost between l0 and l1 is fourteen unit/s. The object p3 is positioned at location l1 initially. The last location for package p3 is l0. It cost eleven unit/s for traveling between locations l3 and l2. It requires sixteen unit/s to travel between l1 and l3. Eight allowed steps are available: step(1) through step(8). fourteen unit/s are required to travel between locations l1 and l0. It requires twelve unit/s to travel between l2 and l1. It requires twelve unit/s to travel between l1 and l2. Object p1 is initially located at l2. The starting location of object p0 is l1. sixteen unit/s are required to travel between locations l3 and l1. Package p2 will be delivered to l0. The object p2 begins at location l1. Initially, t0 is found at location l1. The destination for package p0 is l2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6112390130945680506", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Initially, p1 is found at location l1. The last location for package p1 is l3. Object p2 is initially located at l0. The object t0 is initially at location l5. The object p5 is initially at location l5. Traveling between locations l1 and l5 costs fourteen unit/s. Traveling between locations l3 and l5 costs fourteen unit/s. Package p5 will be delivered to l6. The object p3 is initially at location l5. Eight allowed steps are available: step(1) through step(8). two unit/s are required to travel between locations l2 and l0. The last location for package p2 is l4. It takes two unit/s to travel between locations l0 and l2. Package p0 will be delivered to l3. fourteen unit/s are required to travel between locations l5 and l1. Package p6 will be delivered to l5. The cost of traveling from l1 to l4 is ten unit/s. The initial amount of fuel for truck t0 is sixty-nine. The cost of traveling from l4 to l1 is ten unit/s. The destination for package p4 is l5. It requires fourteen unit/s to travel between l5 and l3. Object p6 is initially located at l1. The starting location of object p4 is l1. Initially, p0 is found at location l2. The package p3 must stay at location l1.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l2). at(p1,l1). at(p2,l0). at(p3,l5). at(p4,l1). at(p5,l5). at(p6,l1). at(t0,l5). fuel(t0,69). fuelcost(10,l1,l4). fuelcost(10,l4,l1). fuelcost(14,l1,l5). fuelcost(14,l3,l5). fuelcost(14,l5,l1). fuelcost(14,l5,l3). fuelcost(2,l0,l2). fuelcost(2,l2,l0). goal(p0,l3). goal(p1,l3). goal(p2,l4). goal(p3,l1). goal(p4,l5). goal(p5,l6). goal(p6,l5).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Initially, p1 is found at location l1. The last location for package p1 is l3. Object p2 is initially located at l0. The object t0 is initially at location l5. The object p5 is initially at location l5. Traveling between locations l1 and l5 costs fourteen unit/s. Traveling between locations l3 and l5 costs fourteen unit/s. Package p5 will be delivered to l6. The object p3 is initially at location l5. Eight allowed steps are available: step(1) through step(8). two unit/s are required to travel between locations l2 and l0. The last location for package p2 is l4. It takes two unit/s to travel between locations l0 and l2. Package p0 will be delivered to l3. fourteen unit/s are required to travel between locations l5 and l1. Package p6 will be delivered to l5. The cost of traveling from l1 to l4 is ten unit/s. The initial amount of fuel for truck t0 is sixty-nine. The cost of traveling from l4 to l1 is ten unit/s. The destination for package p4 is l5. It requires fourteen unit/s to travel between l5 and l3. Object p6 is initially located at l1. The starting location of object p4 is l1. Initially, p0 is found at location l2. The package p3 must stay at location l1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "244716138576507901", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "twelve unit/s are required to travel between locations l6 and l7. The destination for package p1 is l7. Eight allowed steps are available: step(1) through step(8). Truck t0 has an initial fuel amount of one hundred and seventeen. Initially, p2 is found at location l6. It cost one unit/s for traveling between locations l8 and l1. Initially, p5 is found at location l2. The destination for package p4 is l2. It takes fourteen unit/s to travel between locations l2 and l3. The object p3 is positioned at location l4 initially. The object p7 is positioned at location l7 initially. It cost twelve unit/s for traveling between locations l7 and l6. It takes fourteen unit/s to travel between locations l0 and l7. The package p6 must remain at location l6. It requires fourteen unit/s to travel between l3 and l2. fourteen unit/s are required to travel between locations l7 and l0. The object p6 is positioned at location l2 initially. The destination for package p0 is l6. The object p4 is initially at location l8. The package p3 must remain at location l0. The travel cost between l1 and l8 is one unit/s. Package p7 will be delivered to l1. The object p1 begins at location l4. The final location for package p2 is l5. The object p0 is initially at location l8. The destination for package p5 is l1.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l8). at(p1,l4). at(p2,l6). at(p3,l4). at(p4,l8). at(p5,l2). at(p6,l2). at(p7,l7). fuel(t0,117). fuelcost(1,l1,l8). fuelcost(1,l8,l1). fuelcost(12,l6,l7). fuelcost(12,l7,l6). fuelcost(14,l0,l7). fuelcost(14,l2,l3). fuelcost(14,l3,l2). fuelcost(14,l7,l0). goal(p0,l6). goal(p1,l7). goal(p2,l5). goal(p3,l0). goal(p4,l2). goal(p5,l1). goal(p6,l6). goal(p7,l1).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```twelve unit/s are required to travel between locations l6 and l7. The destination for package p1 is l7. Eight allowed steps are available: step(1) through step(8). Truck t0 has an initial fuel amount of one hundred and seventeen. Initially, p2 is found at location l6. It cost one unit/s for traveling between locations l8 and l1. Initially, p5 is found at location l2. The destination for package p4 is l2. It takes fourteen unit/s to travel between locations l2 and l3. The object p3 is positioned at location l4 initially. The object p7 is positioned at location l7 initially. It cost twelve unit/s for traveling between locations l7 and l6. It takes fourteen unit/s to travel between locations l0 and l7. The package p6 must remain at location l6. It requires fourteen unit/s to travel between l3 and l2. fourteen unit/s are required to travel between locations l7 and l0. The object p6 is positioned at location l2 initially. The destination for package p0 is l6. The object p4 is initially at location l8. The package p3 must remain at location l0. The travel cost between l1 and l8 is one unit/s. Package p7 will be delivered to l1. The object p1 begins at location l4. The final location for package p2 is l5. The object p0 is initially at location l8. The destination for package p5 is l1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8336862175590986420", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The last location for package p1 is l3. The package p4 must stay at location l2. The travel cost between l3 and l1 is fifteen unit/s. The object p3 is initially at location l4. The package p5 must stay at location l4. The travel cost between l5 and l4 is twelve unit/s. Truck t0 starts with ninety-seven as fuel quantity. It takes eleven unit/s to travel between locations l2 and l3. It requires eleven unit/s to travel between l3 and l2. It cost fifteen unit/s for traveling between locations l1 and l3. The travel cost between l1 and l0 is fourteen unit/s. The starting location of object p5 is l5. It takes twelve unit/s to travel between locations l4 and l5. The object p0 is initially at location l4. Object p4 is initially located at l0. The object p1 is positioned at location l5 initially. The travel cost between l0 and l1 is fourteen unit/s. The package p3 must stay at location l3. The last location for package p2 is l0. Object p2 is initially located at l1. Object t0 is initially located at l2. The package p0 must remain at location l0. Eight steps are provided: step 1 to step 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l4). at(p1,l5). at(p2,l1). at(p3,l4). at(p4,l0). at(p5,l5). at(t0,l2). fuel(t0,97). fuelcost(11,l2,l3). fuelcost(11,l3,l2). fuelcost(12,l4,l5). fuelcost(12,l5,l4). fuelcost(14,l0,l1). fuelcost(14,l1,l0). fuelcost(15,l1,l3). fuelcost(15,l3,l1). goal(p0,l0). goal(p1,l3). goal(p2,l0). goal(p3,l3). goal(p4,l2). goal(p5,l4).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The last location for package p1 is l3. The package p4 must stay at location l2. The travel cost between l3 and l1 is fifteen unit/s. The object p3 is initially at location l4. The package p5 must stay at location l4. The travel cost between l5 and l4 is twelve unit/s. Truck t0 starts with ninety-seven as fuel quantity. It takes eleven unit/s to travel between locations l2 and l3. It requires eleven unit/s to travel between l3 and l2. It cost fifteen unit/s for traveling between locations l1 and l3. The travel cost between l1 and l0 is fourteen unit/s. The starting location of object p5 is l5. It takes twelve unit/s to travel between locations l4 and l5. The object p0 is initially at location l4. Object p4 is initially located at l0. The object p1 is positioned at location l5 initially. The travel cost between l0 and l1 is fourteen unit/s. The package p3 must stay at location l3. The last location for package p2 is l0. Object p2 is initially located at l1. Object t0 is initially located at l2. The package p0 must remain at location l0. Eight steps are provided: step 1 to step 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5729861385781045957", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The destination for package p1 is l7. Initially, p5 is found at location l0. Truck t0 starts with ninety-one as fuel quantity. The travel cost between l0 and l5 is eighteen unit/s. It cost fifteen unit/s for traveling between locations l7 and l2. Object p0 is initially located at l7. The package p5 must remain at location l6. fifteen unit/s are required to travel between locations l2 and l7. It cost sixteen unit/s for traveling between locations l2 and l0. The destination for package p3 is l5. The travel cost between l0 and l2 is sixteen unit/s. Object p4 is initially located at l7. The package p4 must remain at location l2. The destination for package p7 is l6. The cost of traveling from l5 to l1 is two unit/s. The final location for package p2 is l5. Eight steps are provided: step 1 to step 8. The last location for package p0 is l6. Initially, p6 is found at location l1. The object p2 begins at location l7. The object p3 is positioned at location l3 initially. The starting location of object p7 is l7. Traveling between locations l5 and l0 costs eighteen unit/s. The starting location of object p1 is l4. It requires two unit/s to travel between l1 and l5. The destination for package p6 is l4.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l7). at(p1,l4). at(p2,l7). at(p3,l3). at(p4,l7). at(p5,l0). at(p6,l1). at(p7,l7). fuel(t0,91). fuelcost(15,l2,l7). fuelcost(15,l7,l2). fuelcost(16,l0,l2). fuelcost(16,l2,l0). fuelcost(18,l0,l5). fuelcost(18,l5,l0). fuelcost(2,l1,l5). fuelcost(2,l5,l1). goal(p0,l6). goal(p1,l7). goal(p2,l5). goal(p3,l5). goal(p4,l2). goal(p5,l6). goal(p6,l4). goal(p7,l6).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The destination for package p1 is l7. Initially, p5 is found at location l0. Truck t0 starts with ninety-one as fuel quantity. The travel cost between l0 and l5 is eighteen unit/s. It cost fifteen unit/s for traveling between locations l7 and l2. Object p0 is initially located at l7. The package p5 must remain at location l6. fifteen unit/s are required to travel between locations l2 and l7. It cost sixteen unit/s for traveling between locations l2 and l0. The destination for package p3 is l5. The travel cost between l0 and l2 is sixteen unit/s. Object p4 is initially located at l7. The package p4 must remain at location l2. The destination for package p7 is l6. The cost of traveling from l5 to l1 is two unit/s. The final location for package p2 is l5. Eight steps are provided: step 1 to step 8. The last location for package p0 is l6. Initially, p6 is found at location l1. The object p2 begins at location l7. The object p3 is positioned at location l3 initially. The starting location of object p7 is l7. Traveling between locations l5 and l0 costs eighteen unit/s. The starting location of object p1 is l4. It requires two unit/s to travel between l1 and l5. The destination for package p6 is l4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5012297811608568597", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The final location for package p5 is l0. The cost of traveling from l2 to l4 is fourteen unit/s. Traveling between locations l0 and l2 costs fifteen unit/s. Initially, p4 is found at location l0. The object p0 is initially at location l1. The last location for package p2 is l4. It cost twelve unit/s for traveling between locations l3 and l2. The package p3 must stay at location l0. A total of eight steps are available: step 1 to step 8. It requires twelve unit/s to travel between l2 and l3. Initially, p2 is found at location l0. The starting location of object t0 is l1. The travel cost between l4 and l2 is fourteen unit/s. The package p4 must remain at location l4. The initial fuel available for truck t0 is sixty-eight. The starting location of object p5 is l5. The package p1 must stay at location l1. It requires twelve unit/s to travel between l0 and l3. twelve unit/s are required to travel between locations l3 and l0. The starting location of object p3 is l4. The destination for package p0 is l2. Object p1 is initially located at l5. The cost of traveling from l2 to l0 is fifteen unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l1). at(p1,l5). at(p2,l0). at(p3,l4). at(p4,l0). at(p5,l5). at(t0,l1). fuel(t0,68). fuelcost(12,l0,l3). fuelcost(12,l2,l3). fuelcost(12,l3,l0). fuelcost(12,l3,l2). fuelcost(14,l2,l4). fuelcost(14,l4,l2). fuelcost(15,l0,l2). fuelcost(15,l2,l0). goal(p0,l2). goal(p1,l1). goal(p2,l4). goal(p3,l0). goal(p4,l4). goal(p5,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The final location for package p5 is l0. The cost of traveling from l2 to l4 is fourteen unit/s. Traveling between locations l0 and l2 costs fifteen unit/s. Initially, p4 is found at location l0. The object p0 is initially at location l1. The last location for package p2 is l4. It cost twelve unit/s for traveling between locations l3 and l2. The package p3 must stay at location l0. A total of eight steps are available: step 1 to step 8. It requires twelve unit/s to travel between l2 and l3. Initially, p2 is found at location l0. The starting location of object t0 is l1. The travel cost between l4 and l2 is fourteen unit/s. The package p4 must remain at location l4. The initial fuel available for truck t0 is sixty-eight. The starting location of object p5 is l5. The package p1 must stay at location l1. It requires twelve unit/s to travel between l0 and l3. twelve unit/s are required to travel between locations l3 and l0. The starting location of object p3 is l4. The destination for package p0 is l2. Object p1 is initially located at l5. The cost of traveling from l2 to l0 is fifteen unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2093148021887301133", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Traveling between locations l0 and l2 costs twelve unit/s. The cost of traveling from l1 to l6 is thirteen unit/s. The starting location of object p6 is l0. The package p4 must remain at location l1. The object p2 is initially at location l1. The starting location of object p4 is l3. The final location for package p3 is l6. It requires twelve unit/s to travel between l2 and l0. The starting location of object p1 is l5. The cost of traveling from l6 to l1 is thirteen unit/s. The object p0 is initially at location l7. Traveling between locations l6 and l0 costs fourteen unit/s. Truck t0 is provided with one hundred and seventeen fuel initially. The package p6 must remain at location l7. The package p0 must remain at location l2. Traveling between locations l5 and l0 costs fifteen unit/s. The starting location of object p3 is l2. Object p7 is initially located at l5. The last location for package p5 is l1. Eight allowed steps are available: step(1) through step(8). Initially, p5 is found at location l0. Traveling between locations l0 and l5 costs fifteen unit/s. The last location for package p7 is l3. The package p1 must stay at location l3. The package p2 must remain at location l2. The cost of traveling from l0 to l6 is fourteen unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l7). at(p1,l5). at(p2,l1). at(p3,l2). at(p4,l3). at(p5,l0). at(p6,l0). at(p7,l5). fuel(t0,117). fuelcost(12,l0,l2). fuelcost(12,l2,l0). fuelcost(13,l1,l6). fuelcost(13,l6,l1). fuelcost(14,l0,l6). fuelcost(14,l6,l0). fuelcost(15,l0,l5). fuelcost(15,l5,l0). goal(p0,l2). goal(p1,l3). goal(p2,l2). goal(p3,l6). goal(p4,l1). goal(p5,l1). goal(p6,l7). goal(p7,l3).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Traveling between locations l0 and l2 costs twelve unit/s. The cost of traveling from l1 to l6 is thirteen unit/s. The starting location of object p6 is l0. The package p4 must remain at location l1. The object p2 is initially at location l1. The starting location of object p4 is l3. The final location for package p3 is l6. It requires twelve unit/s to travel between l2 and l0. The starting location of object p1 is l5. The cost of traveling from l6 to l1 is thirteen unit/s. The object p0 is initially at location l7. Traveling between locations l6 and l0 costs fourteen unit/s. Truck t0 is provided with one hundred and seventeen fuel initially. The package p6 must remain at location l7. The package p0 must remain at location l2. Traveling between locations l5 and l0 costs fifteen unit/s. The starting location of object p3 is l2. Object p7 is initially located at l5. The last location for package p5 is l1. Eight allowed steps are available: step(1) through step(8). Initially, p5 is found at location l0. Traveling between locations l0 and l5 costs fifteen unit/s. The last location for package p7 is l3. The package p1 must stay at location l3. The package p2 must remain at location l2. The cost of traveling from l0 to l6 is fourteen unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "96619790179033304", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "thirteen unit/s are required to travel between locations l6 and l5. The package p1 must stay at location l6. Package p5 will be delivered to l2. Initially, p5 is found at location l1. Package p6 will be delivered to l1. The initial fuel available for truck t0 is one hundred and ten. The object p1 is positioned at location l7 initially. Traveling between locations l1 and l4 costs fourteen unit/s. The package p3 must remain at location l5. Package p7 will be delivered to l4. The package p4 must remain at location l6. It cost thirteen unit/s for traveling between locations l5 and l6. Initially, p7 is found at location l3. It takes fourteen unit/s to travel between locations l4 and l1. nineteen unit/s are required to travel between locations l6 and l7. It requires nineteen unit/s to travel between l7 and l6. Object p4 is initially located at l0. Initially, p0 is found at location l0. Package p0 will be delivered to l6. The starting location of object p2 is l6. Initially, p6 is found at location l3. It cost nineteen unit/s for traveling between locations l0 and l4. The object p3 begins at location l4. Traveling between locations l4 and l0 costs nineteen unit/s. Eight allowed steps are available: step(1) through step(8). The package p2 must remain at location l2.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l0). at(p1,l7). at(p2,l6). at(p3,l4). at(p4,l0). at(p5,l1). at(p6,l3). at(p7,l3). fuel(t0,110). fuelcost(13,l5,l6). fuelcost(13,l6,l5). fuelcost(14,l1,l4). fuelcost(14,l4,l1). fuelcost(19,l0,l4). fuelcost(19,l4,l0). fuelcost(19,l6,l7). fuelcost(19,l7,l6). goal(p0,l6). goal(p1,l6). goal(p2,l2). goal(p3,l5). goal(p4,l6). goal(p5,l2). goal(p6,l1). goal(p7,l4).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```thirteen unit/s are required to travel between locations l6 and l5. The package p1 must stay at location l6. Package p5 will be delivered to l2. Initially, p5 is found at location l1. Package p6 will be delivered to l1. The initial fuel available for truck t0 is one hundred and ten. The object p1 is positioned at location l7 initially. Traveling between locations l1 and l4 costs fourteen unit/s. The package p3 must remain at location l5. Package p7 will be delivered to l4. The package p4 must remain at location l6. It cost thirteen unit/s for traveling between locations l5 and l6. Initially, p7 is found at location l3. It takes fourteen unit/s to travel between locations l4 and l1. nineteen unit/s are required to travel between locations l6 and l7. It requires nineteen unit/s to travel between l7 and l6. Object p4 is initially located at l0. Initially, p0 is found at location l0. Package p0 will be delivered to l6. The starting location of object p2 is l6. Initially, p6 is found at location l3. It cost nineteen unit/s for traveling between locations l0 and l4. The object p3 begins at location l4. Traveling between locations l4 and l0 costs nineteen unit/s. Eight allowed steps are available: step(1) through step(8). The package p2 must remain at location l2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3704003181164101122", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The object p4 begins at location l4. The last location for package p7 is l4. Traveling between locations l6 and l4 costs fourteen unit/s. Object p0 is initially located at l6. thirteen unit/s are required to travel between locations l3 and l7. The package p1 must remain at location l3. The cost of traveling from l3 to l1 is sixteen unit/s. The final location for package p3 is l0. It takes fourteen unit/s to travel between locations l4 and l6. The destination for package p2 is l0. The starting location of object p7 is l2. The object p5 begins at location l3. It cost sixteen unit/s for traveling between locations l1 and l3. The package p4 must stay at location l0. Package p0 will be delivered to l3. Eight steps can be followed, from step 1 to step 8. The starting location of object p6 is l6. The object p3 is initially at location l5. The travel cost between l6 and l5 is twelve unit/s. The package p5 must stay at location l2. The object p1 is positioned at location l1 initially. Initially, p2 is found at location l2. The last location for package p6 is l4. It requires thirteen unit/s to travel between l7 and l3. The starting fuel for truck t0 is eighty-five. The cost of traveling from l5 to l6 is twelve unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l6). at(p1,l1). at(p2,l2). at(p3,l5). at(p4,l4). at(p5,l3). at(p6,l6). at(p7,l2). fuel(t0,85). fuelcost(12,l5,l6). fuelcost(12,l6,l5). fuelcost(13,l3,l7). fuelcost(13,l7,l3). fuelcost(14,l4,l6). fuelcost(14,l6,l4). fuelcost(16,l1,l3). fuelcost(16,l3,l1). goal(p0,l3). goal(p1,l3). goal(p2,l0). goal(p3,l0). goal(p4,l0). goal(p5,l2). goal(p6,l4). goal(p7,l4).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The object p4 begins at location l4. The last location for package p7 is l4. Traveling between locations l6 and l4 costs fourteen unit/s. Object p0 is initially located at l6. thirteen unit/s are required to travel between locations l3 and l7. The package p1 must remain at location l3. The cost of traveling from l3 to l1 is sixteen unit/s. The final location for package p3 is l0. It takes fourteen unit/s to travel between locations l4 and l6. The destination for package p2 is l0. The starting location of object p7 is l2. The object p5 begins at location l3. It cost sixteen unit/s for traveling between locations l1 and l3. The package p4 must stay at location l0. Package p0 will be delivered to l3. Eight steps can be followed, from step 1 to step 8. The starting location of object p6 is l6. The object p3 is initially at location l5. The travel cost between l6 and l5 is twelve unit/s. The package p5 must stay at location l2. The object p1 is positioned at location l1 initially. Initially, p2 is found at location l2. The last location for package p6 is l4. It requires thirteen unit/s to travel between l7 and l3. The starting fuel for truck t0 is eighty-five. The cost of traveling from l5 to l6 is twelve unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7444091774617212609", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The object p2 is initially at location l3. The final location for package p2 is l0. Object p3 is initially located at l3. Truck t0 has an initial fuel amount of twenty-eight. The travel cost between l3 and l2 is ten unit/s. Object p0 is initially located at l2. The package p3 must remain at location l1. It cost four unit/s for traveling between locations l0 and l2. The package p1 must stay at location l3. Object p1 is initially located at l1. The starting location of object t0 is l1. It takes twenty-five unit/s to travel between locations l0 and l1. It takes sixteen unit/s to travel between locations l3 and l1. It takes four unit/s to travel between locations l2 and l0. sixteen unit/s are required to travel between locations l1 and l3. The final location for package p0 is l0. Eight steps can be followed, from step 1 to step 8. twenty-five unit/s are required to travel between locations l1 and l0. The travel cost between l2 and l3 is ten unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l2). at(p1,l1). at(p2,l3). at(p3,l3). at(t0,l1). fuel(t0,28). fuelcost(10,l2,l3). fuelcost(10,l3,l2). fuelcost(16,l1,l3). fuelcost(16,l3,l1). fuelcost(25,l0,l1). fuelcost(25,l1,l0). fuelcost(4,l0,l2). fuelcost(4,l2,l0). goal(p0,l0). goal(p1,l3). goal(p2,l0). goal(p3,l1).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The object p2 is initially at location l3. The final location for package p2 is l0. Object p3 is initially located at l3. Truck t0 has an initial fuel amount of twenty-eight. The travel cost between l3 and l2 is ten unit/s. Object p0 is initially located at l2. The package p3 must remain at location l1. It cost four unit/s for traveling between locations l0 and l2. The package p1 must stay at location l3. Object p1 is initially located at l1. The starting location of object t0 is l1. It takes twenty-five unit/s to travel between locations l0 and l1. It takes sixteen unit/s to travel between locations l3 and l1. It takes four unit/s to travel between locations l2 and l0. sixteen unit/s are required to travel between locations l1 and l3. The final location for package p0 is l0. Eight steps can be followed, from step 1 to step 8. twenty-five unit/s are required to travel between locations l1 and l0. The travel cost between l2 and l3 is ten unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1954619423826824677", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Initially, p0 is found at location l6. It requires fifteen unit/s to travel between l6 and l2. The package p2 must stay at location l3. It requires fifteen unit/s to travel between l1 and l4. The starting location of object p1 is l4. Traveling between locations l4 and l1 costs fifteen unit/s. Package p6 will be delivered to l2. The object p5 is positioned at location l3 initially. The final location for package p0 is l5. The final location for package p3 is l2. Traveling between locations l5 and l4 costs one unit/s. The object p2 begins at location l1. Traveling between locations l5 and l0 costs thirteen unit/s. It cost fifteen unit/s for traveling between locations l2 and l6. Object p6 is initially located at l6. Object p4 is initially located at l4. Object p3 is initially located at l6. The travel cost between l4 and l5 is one unit/s. The package p4 must remain at location l5. Truck t0 starts with eighty-eight as fuel quantity. The object t0 begins at location l2. It requires thirteen unit/s to travel between l0 and l5. Eight steps are provided: step 1 to step 8. The last location for package p5 is l0. The package p1 must stay at location l2.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l6). at(p1,l4). at(p2,l1). at(p3,l6). at(p4,l4). at(p5,l3). at(p6,l6). at(t0,l2). fuel(t0,88). fuelcost(1,l4,l5). fuelcost(1,l5,l4). fuelcost(13,l0,l5). fuelcost(13,l5,l0). fuelcost(15,l1,l4). fuelcost(15,l2,l6). fuelcost(15,l4,l1). fuelcost(15,l6,l2). goal(p0,l5). goal(p1,l2). goal(p2,l3). goal(p3,l2). goal(p4,l5). goal(p5,l0). goal(p6,l2).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Initially, p0 is found at location l6. It requires fifteen unit/s to travel between l6 and l2. The package p2 must stay at location l3. It requires fifteen unit/s to travel between l1 and l4. The starting location of object p1 is l4. Traveling between locations l4 and l1 costs fifteen unit/s. Package p6 will be delivered to l2. The object p5 is positioned at location l3 initially. The final location for package p0 is l5. The final location for package p3 is l2. Traveling between locations l5 and l4 costs one unit/s. The object p2 begins at location l1. Traveling between locations l5 and l0 costs thirteen unit/s. It cost fifteen unit/s for traveling between locations l2 and l6. Object p6 is initially located at l6. Object p4 is initially located at l4. Object p3 is initially located at l6. The travel cost between l4 and l5 is one unit/s. The package p4 must remain at location l5. Truck t0 starts with eighty-eight as fuel quantity. The object t0 begins at location l2. It requires thirteen unit/s to travel between l0 and l5. Eight steps are provided: step 1 to step 8. The last location for package p5 is l0. The package p1 must stay at location l2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8956016203202497784", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "fifteen unit/s are required to travel between locations l7 and l4. Initially, p5 is found at location l6. Initially, p1 is found at location l5. The starting location of object p0 is l0. The cost of traveling from l6 to l2 is ten unit/s. The package p4 must remain at location l0. The object p7 is initially at location l3. It cost ten unit/s for traveling between locations l2 and l6. The package p7 must stay at location l2. The destination for package p5 is l4. Object p2 is initially located at l6. The starting location of object p3 is l3. Package p3 will be delivered to l2. The package p1 must stay at location l6. The package p6 must stay at location l1. Initially, p6 is found at location l0. Eight steps are provided: step 1 to step 8. Traveling between locations l2 and l7 costs one unit/s. The package p2 must stay at location l4. The travel cost between l1 and l3 is sixteen unit/s. The final location for package p0 is l3. The travel cost between l4 and l7 is fifteen unit/s. Truck t0 starts with eighty-six as fuel quantity. It cost one unit/s for traveling between locations l7 and l2. Traveling between locations l3 and l1 costs sixteen unit/s. The object p4 begins at location l6.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l0). at(p1,l5). at(p2,l6). at(p3,l3). at(p4,l6). at(p5,l6). at(p6,l0). at(p7,l3). fuel(t0,86). fuelcost(1,l2,l7). fuelcost(1,l7,l2). fuelcost(10,l2,l6). fuelcost(10,l6,l2). fuelcost(15,l4,l7). fuelcost(15,l7,l4). fuelcost(16,l1,l3). fuelcost(16,l3,l1). goal(p0,l3). goal(p1,l6). goal(p2,l4). goal(p3,l2). goal(p4,l0). goal(p5,l4). goal(p6,l1). goal(p7,l2).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```fifteen unit/s are required to travel between locations l7 and l4. Initially, p5 is found at location l6. Initially, p1 is found at location l5. The starting location of object p0 is l0. The cost of traveling from l6 to l2 is ten unit/s. The package p4 must remain at location l0. The object p7 is initially at location l3. It cost ten unit/s for traveling between locations l2 and l6. The package p7 must stay at location l2. The destination for package p5 is l4. Object p2 is initially located at l6. The starting location of object p3 is l3. Package p3 will be delivered to l2. The package p1 must stay at location l6. The package p6 must stay at location l1. Initially, p6 is found at location l0. Eight steps are provided: step 1 to step 8. Traveling between locations l2 and l7 costs one unit/s. The package p2 must stay at location l4. The travel cost between l1 and l3 is sixteen unit/s. The final location for package p0 is l3. The travel cost between l4 and l7 is fifteen unit/s. Truck t0 starts with eighty-six as fuel quantity. It cost one unit/s for traveling between locations l7 and l2. Traveling between locations l3 and l1 costs sixteen unit/s. The object p4 begins at location l6.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3015685746676625206", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The object p1 is positioned at location l0 initially. Traveling between locations l1 and l0 costs twenty-two unit/s. The package p3 must stay at location l4. A total of eight steps are available: step 1 to step 8. The object p5 is positioned at location l4 initially. twenty-one unit/s are required to travel between locations l5 and l1. Object p3 is initially located at l5. The travel cost between l4 and l2 is ten unit/s. It cost twenty-one unit/s for traveling between locations l1 and l5. The object p0 is positioned at location l5 initially. It requires twenty-two unit/s to travel between l0 and l1. The starting fuel for truck t0 is forty-four. The object t0 is initially at location l3. Initially, p4 is found at location l2. The final location for package p1 is l5. The destination for package p5 is l2. The object p2 begins at location l3. The package p4 must stay at location l4. The destination for package p2 is l0. It requires twelve unit/s to travel between l3 and l5. It requires twelve unit/s to travel between l5 and l3. The package p0 must remain at location l4. The cost of traveling from l2 to l4 is ten unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l5). at(p1,l0). at(p2,l3). at(p3,l5). at(p4,l2). at(p5,l4). at(t0,l3). fuel(t0,44). fuelcost(10,l2,l4). fuelcost(10,l4,l2). fuelcost(12,l3,l5). fuelcost(12,l5,l3). fuelcost(21,l1,l5). fuelcost(21,l5,l1). fuelcost(22,l0,l1). fuelcost(22,l1,l0). goal(p0,l4). goal(p1,l5). goal(p2,l0). goal(p3,l4). goal(p4,l4). goal(p5,l2).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The object p1 is positioned at location l0 initially. Traveling between locations l1 and l0 costs twenty-two unit/s. The package p3 must stay at location l4. A total of eight steps are available: step 1 to step 8. The object p5 is positioned at location l4 initially. twenty-one unit/s are required to travel between locations l5 and l1. Object p3 is initially located at l5. The travel cost between l4 and l2 is ten unit/s. It cost twenty-one unit/s for traveling between locations l1 and l5. The object p0 is positioned at location l5 initially. It requires twenty-two unit/s to travel between l0 and l1. The starting fuel for truck t0 is forty-four. The object t0 is initially at location l3. Initially, p4 is found at location l2. The final location for package p1 is l5. The destination for package p5 is l2. The object p2 begins at location l3. The package p4 must stay at location l4. The destination for package p2 is l0. It requires twelve unit/s to travel between l3 and l5. It requires twelve unit/s to travel between l5 and l3. The package p0 must remain at location l4. The cost of traveling from l2 to l4 is ten unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2941606773946181594", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The starting location of object p0 is l3. The object p1 is positioned at location l0 initially. A total of eight steps are available: step 1 to step 8. thirteen unit/s are required to travel between locations l1 and l3. The starting location of object t0 is l3. It takes thirteen unit/s to travel between locations l3 and l0. The last location for package p1 is l3. Truck t0 starts with thirty-two as fuel quantity. The final location for package p2 is l1. The destination for package p0 is l1. It takes thirteen unit/s to travel between locations l0 and l3. The travel cost between l0 and l2 is twelve unit/s. The package p3 must remain at location l2. one unit/s are required to travel between locations l1 and l2. It cost thirteen unit/s for traveling between locations l3 and l1. Traveling between locations l2 and l0 costs twelve unit/s. The object p3 is positioned at location l3 initially. Initially, p2 is found at location l0. one unit/s are required to travel between locations l2 and l1.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l3). at(p1,l0). at(p2,l0). at(p3,l3). at(t0,l3). fuel(t0,32). fuelcost(1,l1,l2). fuelcost(1,l2,l1). fuelcost(12,l0,l2). fuelcost(12,l2,l0). fuelcost(13,l0,l3). fuelcost(13,l1,l3). fuelcost(13,l3,l0). fuelcost(13,l3,l1). goal(p0,l1). goal(p1,l3). goal(p2,l1). goal(p3,l2).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The starting location of object p0 is l3. The object p1 is positioned at location l0 initially. A total of eight steps are available: step 1 to step 8. thirteen unit/s are required to travel between locations l1 and l3. The starting location of object t0 is l3. It takes thirteen unit/s to travel between locations l3 and l0. The last location for package p1 is l3. Truck t0 starts with thirty-two as fuel quantity. The final location for package p2 is l1. The destination for package p0 is l1. It takes thirteen unit/s to travel between locations l0 and l3. The travel cost between l0 and l2 is twelve unit/s. The package p3 must remain at location l2. one unit/s are required to travel between locations l1 and l2. It cost thirteen unit/s for traveling between locations l3 and l1. Traveling between locations l2 and l0 costs twelve unit/s. The object p3 is positioned at location l3 initially. Initially, p2 is found at location l0. one unit/s are required to travel between locations l2 and l1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7335846134775628432", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The destination for package p2 is l2. It takes eighteen unit/s to travel between locations l3 and l0. The travel cost between l1 and l2 is twenty-two unit/s. The destination for package p1 is l2. Truck t0 starts with fifty as fuel quantity. Traveling between locations l0 and l2 costs fifteen unit/s. The cost of traveling from l0 to l3 is eighteen unit/s. Object p0 is initially located at l3. It takes fifteen unit/s to travel between locations l2 and l0. It cost twenty-one unit/s for traveling between locations l3 and l2. The last location for package p0 is l2. The starting location of object p2 is l0. The object p3 is initially at location l1. The object p1 is positioned at location l0 initially. The package p3 must stay at location l0. Eight steps can be followed, from step 1 to step 8. It takes twenty-two unit/s to travel between locations l2 and l1. Traveling between locations l2 and l3 costs twenty-one unit/s. The object t0 is initially at location l2.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l3). at(p1,l0). at(p2,l0). at(p3,l1). at(t0,l2). fuel(t0,50). fuelcost(15,l0,l2). fuelcost(15,l2,l0). fuelcost(18,l0,l3). fuelcost(18,l3,l0). fuelcost(21,l2,l3). fuelcost(21,l3,l2). fuelcost(22,l1,l2). fuelcost(22,l2,l1). goal(p0,l2). goal(p1,l2). goal(p2,l2). goal(p3,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The destination for package p2 is l2. It takes eighteen unit/s to travel between locations l3 and l0. The travel cost between l1 and l2 is twenty-two unit/s. The destination for package p1 is l2. Truck t0 starts with fifty as fuel quantity. Traveling between locations l0 and l2 costs fifteen unit/s. The cost of traveling from l0 to l3 is eighteen unit/s. Object p0 is initially located at l3. It takes fifteen unit/s to travel between locations l2 and l0. It cost twenty-one unit/s for traveling between locations l3 and l2. The last location for package p0 is l2. The starting location of object p2 is l0. The object p3 is initially at location l1. The object p1 is positioned at location l0 initially. The package p3 must stay at location l0. Eight steps can be followed, from step 1 to step 8. It takes twenty-two unit/s to travel between locations l2 and l1. Traveling between locations l2 and l3 costs twenty-one unit/s. The object t0 is initially at location l2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6372849139610315741", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The object p1 begins at location l5. Object p4 is initially located at l2. The travel cost between l1 and l7 is seventeen unit/s. It cost fourteen unit/s for traveling between locations l6 and l8. Package p2 will be delivered to l2. The final location for package p0 is l6. The destination for package p6 is l7. The last location for package p7 is l4. It requires two unit/s to travel between l2 and l7. Object p2 is initially located at l1. The package p1 must remain at location l8. The destination for package p3 is l2. The travel cost between l5 and l6 is two unit/s. Initially, p6 is found at location l6. Truck t0 is provided with sixty-seven fuel initially. It requires seventeen unit/s to travel between l7 and l1. Eight steps are provided: step 1 to step 8. The object p3 is positioned at location l8 initially. It requires fourteen unit/s to travel between l8 and l6. The object p7 begins at location l6. It cost eighteen unit/s for traveling between locations l8 and l3. The cost of traveling from l3 to l8 is eighteen unit/s. Object p0 is initially located at l2. Object p5 is initially located at l4. The last location for package p5 is l0. The destination for package p4 is l8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l2). at(p1,l5). at(p2,l1). at(p3,l8). at(p4,l2). at(p5,l4). at(p6,l6). at(p7,l6). fuel(t0,67). fuelcost(14,l6,l8). fuelcost(14,l8,l6). fuelcost(17,l1,l7). fuelcost(17,l7,l1). fuelcost(18,l3,l8). fuelcost(18,l8,l3). fuelcost(2,l2,l7). fuelcost(2,l5,l6). goal(p0,l6). goal(p1,l8). goal(p2,l2). goal(p3,l2). goal(p4,l8). goal(p5,l0). goal(p6,l7). goal(p7,l4).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The object p1 begins at location l5. Object p4 is initially located at l2. The travel cost between l1 and l7 is seventeen unit/s. It cost fourteen unit/s for traveling between locations l6 and l8. Package p2 will be delivered to l2. The final location for package p0 is l6. The destination for package p6 is l7. The last location for package p7 is l4. It requires two unit/s to travel between l2 and l7. Object p2 is initially located at l1. The package p1 must remain at location l8. The destination for package p3 is l2. The travel cost between l5 and l6 is two unit/s. Initially, p6 is found at location l6. Truck t0 is provided with sixty-seven fuel initially. It requires seventeen unit/s to travel between l7 and l1. Eight steps are provided: step 1 to step 8. The object p3 is positioned at location l8 initially. It requires fourteen unit/s to travel between l8 and l6. The object p7 begins at location l6. It cost eighteen unit/s for traveling between locations l8 and l3. The cost of traveling from l3 to l8 is eighteen unit/s. Object p0 is initially located at l2. Object p5 is initially located at l4. The last location for package p5 is l0. The destination for package p4 is l8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7134171736212450876", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The starting location of object p2 is l3. It requires ten unit/s to travel between l0 and l5. Object p3 is initially located at l5. The package p3 must remain at location l6. The package p7 must stay at location l5. The object p6 is initially at location l3. The last location for package p4 is l1. The destination for package p1 is l1. Package p5 will be delivered to l0. The object p0 is initially at location l6. nineteen unit/s are required to travel between locations l3 and l1. Package p2 will be delivered to l2. The starting location of object p4 is l5. Traveling between locations l5 and l0 costs ten unit/s. The initial amount of fuel for truck t0 is one hundred and twenty-six. The starting location of object p5 is l4. Traveling between locations l1 and l3 costs nineteen unit/s. Traveling between locations l3 and l4 costs seventeen unit/s. The object p7 is initially at location l0. The object p1 is positioned at location l5 initially. The package p0 must stay at location l4. It requires two unit/s to travel between l1 and l5. The cost of traveling from l5 to l1 is two unit/s. Package p6 will be delivered to l0. Eight allowed steps are available: step(1) through step(8). The travel cost between l4 and l3 is seventeen unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l6). at(p1,l5). at(p2,l3). at(p3,l5). at(p4,l5). at(p5,l4). at(p6,l3). at(p7,l0). fuel(t0,126). fuelcost(10,l0,l5). fuelcost(10,l5,l0). fuelcost(17,l3,l4). fuelcost(17,l4,l3). fuelcost(19,l1,l3). fuelcost(19,l3,l1). fuelcost(2,l1,l5). fuelcost(2,l5,l1). goal(p0,l4). goal(p1,l1). goal(p2,l2). goal(p3,l6). goal(p4,l1). goal(p5,l0). goal(p6,l0). goal(p7,l5).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The starting location of object p2 is l3. It requires ten unit/s to travel between l0 and l5. Object p3 is initially located at l5. The package p3 must remain at location l6. The package p7 must stay at location l5. The object p6 is initially at location l3. The last location for package p4 is l1. The destination for package p1 is l1. Package p5 will be delivered to l0. The object p0 is initially at location l6. nineteen unit/s are required to travel between locations l3 and l1. Package p2 will be delivered to l2. The starting location of object p4 is l5. Traveling between locations l5 and l0 costs ten unit/s. The initial amount of fuel for truck t0 is one hundred and twenty-six. The starting location of object p5 is l4. Traveling between locations l1 and l3 costs nineteen unit/s. Traveling between locations l3 and l4 costs seventeen unit/s. The object p7 is initially at location l0. The object p1 is positioned at location l5 initially. The package p0 must stay at location l4. It requires two unit/s to travel between l1 and l5. The cost of traveling from l5 to l1 is two unit/s. Package p6 will be delivered to l0. Eight allowed steps are available: step(1) through step(8). The travel cost between l4 and l3 is seventeen unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6354750656540008565", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The destination for package p5 is l5. The final location for package p4 is l3. The starting location of object p4 is l5. The object p5 is initially at location l1. Traveling between locations l5 and l0 costs ten unit/s. It takes ten unit/s to travel between locations l7 and l4. The final location for package p6 is l2. The travel cost between l2 and l0 is eleven unit/s. The package p3 must remain at location l4. eleven unit/s are required to travel between locations l0 and l2. The cost of traveling from l4 to l7 is ten unit/s. The package p2 must remain at location l5. Eight steps are provided: step 1 to step 8. Traveling between locations l0 and l5 costs ten unit/s. Object p3 is initially located at l6. Initially, p1 is found at location l6. The package p1 must remain at location l0. The fuel amount in truck t0 at the beginning is one hundred and thirty-five. The object p7 begins at location l6. The object p6 begins at location l3. The destination for package p7 is l0. Initially, p0 is found at location l6. The object p2 is positioned at location l2 initially. The travel cost between l5 and l3 is thirteen unit/s. The package p0 must stay at location l3. It requires thirteen unit/s to travel between l3 and l5.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l6). at(p1,l6). at(p2,l2). at(p3,l6). at(p4,l5). at(p5,l1). at(p6,l3). at(p7,l6). fuel(t0,135). fuelcost(10,l0,l5). fuelcost(10,l4,l7). fuelcost(10,l5,l0). fuelcost(10,l7,l4). fuelcost(11,l0,l2). fuelcost(11,l2,l0). fuelcost(13,l3,l5). fuelcost(13,l5,l3). goal(p0,l3). goal(p1,l0). goal(p2,l5). goal(p3,l4). goal(p4,l3). goal(p5,l5). goal(p6,l2). goal(p7,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The destination for package p5 is l5. The final location for package p4 is l3. The starting location of object p4 is l5. The object p5 is initially at location l1. Traveling between locations l5 and l0 costs ten unit/s. It takes ten unit/s to travel between locations l7 and l4. The final location for package p6 is l2. The travel cost between l2 and l0 is eleven unit/s. The package p3 must remain at location l4. eleven unit/s are required to travel between locations l0 and l2. The cost of traveling from l4 to l7 is ten unit/s. The package p2 must remain at location l5. Eight steps are provided: step 1 to step 8. Traveling between locations l0 and l5 costs ten unit/s. Object p3 is initially located at l6. Initially, p1 is found at location l6. The package p1 must remain at location l0. The fuel amount in truck t0 at the beginning is one hundred and thirty-five. The object p7 begins at location l6. The object p6 begins at location l3. The destination for package p7 is l0. Initially, p0 is found at location l6. The object p2 is positioned at location l2 initially. The travel cost between l5 and l3 is thirteen unit/s. The package p0 must stay at location l3. It requires thirteen unit/s to travel between l3 and l5.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2707882546214847163", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "Initially, p2 is found at location l0. The final location for package p5 is l0. The object p3 is positioned at location l2 initially. The starting location of object t0 is l3. Traveling between locations l1 and l0 costs eleven unit/s. The travel cost between l0 and l2 is sixteen unit/s. The package p2 must remain at location l2. The object p1 is initially at location l5. It cost twenty-one unit/s for traveling between locations l4 and l5. The last location for package p0 is l3. Traveling between locations l2 and l0 costs sixteen unit/s. The object p5 is initially at location l1. The package p4 must stay at location l5. The fuel amount in truck t0 at the beginning is eighty-four. The destination for package p3 is l4. It cost twenty unit/s for traveling between locations l2 and l4. It takes twenty-one unit/s to travel between locations l5 and l4. Eight steps are provided: step 1 to step 8. Package p1 will be delivered to l1. It requires twenty unit/s to travel between l4 and l2. Traveling between locations l0 and l1 costs eleven unit/s. The object p0 begins at location l2. The object p4 is initially at location l1.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l2). at(p1,l5). at(p2,l0). at(p3,l2). at(p4,l1). at(p5,l1). at(t0,l3). fuel(t0,84). fuelcost(11,l0,l1). fuelcost(11,l1,l0). fuelcost(16,l0,l2). fuelcost(16,l2,l0). fuelcost(20,l2,l4). fuelcost(20,l4,l2). fuelcost(21,l4,l5). fuelcost(21,l5,l4). goal(p0,l3). goal(p1,l1). goal(p2,l2). goal(p3,l4). goal(p4,l5). goal(p5,l0).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```Initially, p2 is found at location l0. The final location for package p5 is l0. The object p3 is positioned at location l2 initially. The starting location of object t0 is l3. Traveling between locations l1 and l0 costs eleven unit/s. The travel cost between l0 and l2 is sixteen unit/s. The package p2 must remain at location l2. The object p1 is initially at location l5. It cost twenty-one unit/s for traveling between locations l4 and l5. The last location for package p0 is l3. Traveling between locations l2 and l0 costs sixteen unit/s. The object p5 is initially at location l1. The package p4 must stay at location l5. The fuel amount in truck t0 at the beginning is eighty-four. The destination for package p3 is l4. It cost twenty unit/s for traveling between locations l2 and l4. It takes twenty-one unit/s to travel between locations l5 and l4. Eight steps are provided: step 1 to step 8. Package p1 will be delivered to l1. It requires twenty unit/s to travel between l4 and l2. Traveling between locations l0 and l1 costs eleven unit/s. The object p0 begins at location l2. The object p4 is initially at location l1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8700119244968707004", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The package p0 must remain at location l3. eleven unit/s are required to travel between locations l1 and l2. A total of eight steps are available: step 1 to step 8. The starting location of object p4 is l4. Object t0 is initially located at l5. It cost two unit/s for traveling between locations l0 and l1. The travel cost between l2 and l1 is eleven unit/s. The travel cost between l6 and l1 is sixteen unit/s. The destination for package p3 is l2. The object p1 is initially at location l1. The object p5 is initially at location l3. The package p4 must remain at location l3. The cost of traveling from l2 to l4 is twenty-two unit/s. It requires two unit/s to travel between l1 and l0. The object p3 is initially at location l4. The starting location of object p0 is l5. The object p6 is initially at location l4. The object p2 is initially at location l1. The final location for package p5 is l0. Package p1 will be delivered to l4. It requires twenty-two unit/s to travel between l4 and l2. The final location for package p6 is l5. The last location for package p2 is l2. The travel cost between l1 and l6 is sixteen unit/s. The starting fuel for truck t0 is fifty-four.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l5). at(p1,l1). at(p2,l1). at(p3,l4). at(p4,l4). at(p5,l3). at(p6,l4). at(t0,l5). fuel(t0,54). fuelcost(11,l1,l2). fuelcost(11,l2,l1). fuelcost(16,l1,l6). fuelcost(16,l6,l1). fuelcost(2,l0,l1). fuelcost(2,l1,l0). fuelcost(22,l2,l4). fuelcost(22,l4,l2). goal(p0,l3). goal(p1,l4). goal(p2,l2). goal(p3,l2). goal(p4,l3). goal(p5,l0). goal(p6,l5).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The package p0 must remain at location l3. eleven unit/s are required to travel between locations l1 and l2. A total of eight steps are available: step 1 to step 8. The starting location of object p4 is l4. Object t0 is initially located at l5. It cost two unit/s for traveling between locations l0 and l1. The travel cost between l2 and l1 is eleven unit/s. The travel cost between l6 and l1 is sixteen unit/s. The destination for package p3 is l2. The object p1 is initially at location l1. The object p5 is initially at location l3. The package p4 must remain at location l3. The cost of traveling from l2 to l4 is twenty-two unit/s. It requires two unit/s to travel between l1 and l0. The object p3 is initially at location l4. The starting location of object p0 is l5. The object p6 is initially at location l4. The object p2 is initially at location l1. The final location for package p5 is l0. Package p1 will be delivered to l4. It requires twenty-two unit/s to travel between l4 and l2. The final location for package p6 is l5. The last location for package p2 is l2. The travel cost between l1 and l6 is sixteen unit/s. The starting fuel for truck t0 is fifty-four.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3771349243730111342", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The cost of traveling from l0 to l3 is thirteen unit/s. The package p0 must remain at location l2. Package p7 will be delivered to l7. Traveling between locations l2 and l8 costs thirteen unit/s. Package p3 will be delivered to l5. Object p7 is initially located at l3. It requires eleven unit/s to travel between l0 and l7. The object p5 is initially at location l5. The object p4 is positioned at location l3 initially. The starting fuel for truck t0 is ninety-four. The last location for package p1 is l7. Object p3 is initially located at l1. It cost ten unit/s for traveling between locations l7 and l2. The package p4 must remain at location l1. The starting location of object p0 is l0. The object p2 is positioned at location l0 initially. Traveling between locations l3 and l0 costs thirteen unit/s. The package p6 must remain at location l1. Package p5 will be delivered to l7. Object p1 is initially located at l2. It takes thirteen unit/s to travel between locations l8 and l2. Eight steps can be followed, from step 1 to step 8. It requires ten unit/s to travel between l2 and l7. The cost of traveling from l7 to l0 is eleven unit/s. The package p2 must stay at location l2. Object p6 is initially located at l8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l0). at(p1,l2). at(p2,l0). at(p3,l1). at(p4,l3). at(p5,l5). at(p6,l8). at(p7,l3). fuel(t0,94). fuelcost(10,l2,l7). fuelcost(10,l7,l2). fuelcost(11,l0,l7). fuelcost(11,l7,l0). fuelcost(13,l0,l3). fuelcost(13,l2,l8). fuelcost(13,l3,l0). fuelcost(13,l8,l2). goal(p0,l2). goal(p1,l7). goal(p2,l2). goal(p3,l5). goal(p4,l1). goal(p5,l7). goal(p6,l1). goal(p7,l7).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The cost of traveling from l0 to l3 is thirteen unit/s. The package p0 must remain at location l2. Package p7 will be delivered to l7. Traveling between locations l2 and l8 costs thirteen unit/s. Package p3 will be delivered to l5. Object p7 is initially located at l3. It requires eleven unit/s to travel between l0 and l7. The object p5 is initially at location l5. The object p4 is positioned at location l3 initially. The starting fuel for truck t0 is ninety-four. The last location for package p1 is l7. Object p3 is initially located at l1. It cost ten unit/s for traveling between locations l7 and l2. The package p4 must remain at location l1. The starting location of object p0 is l0. The object p2 is positioned at location l0 initially. Traveling between locations l3 and l0 costs thirteen unit/s. The package p6 must remain at location l1. Package p5 will be delivered to l7. Object p1 is initially located at l2. It takes thirteen unit/s to travel between locations l8 and l2. Eight steps can be followed, from step 1 to step 8. It requires ten unit/s to travel between l2 and l7. The cost of traveling from l7 to l0 is eleven unit/s. The package p2 must stay at location l2. Object p6 is initially located at l8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8365485737526423681", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The starting fuel for truck t0 is one hundred and twenty-five. The package p6 must remain at location l1. Initially, p3 is found at location l0. The cost of traveling from l1 to l0 is seventeen unit/s. The last location for package p3 is l6. seventeen unit/s are required to travel between locations l1 and l4. The starting location of object p1 is l6. Package p4 will be delivered to l1. The destination for package p1 is l0. The object p4 is initially at location l0. The object t0 is positioned at location l5 initially. The travel cost between l0 and l2 is seventeen unit/s. The cost of traveling from l2 to l6 is fourteen unit/s. Traveling between locations l1 and l2 costs fifteen unit/s. Initially, p6 is found at location l2. The destination for package p2 is l4. Traveling between locations l0 and l1 costs seventeen unit/s. The cost of traveling from l6 to l2 is fourteen unit/s. The object p2 is positioned at location l2 initially. Eight steps are provided: step 1 to step 8. Traveling between locations l2 and l1 costs fifteen unit/s. The starting location of object p0 is l5. The package p0 must stay at location l3. The destination for package p5 is l2. The object p5 begins at location l4.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l5). at(p1,l6). at(p2,l2). at(p3,l0). at(p4,l0). at(p5,l4). at(p6,l2). at(t0,l5). fuel(t0,125). fuelcost(14,l2,l6). fuelcost(14,l6,l2). fuelcost(15,l1,l2). fuelcost(15,l2,l1). fuelcost(17,l0,l1). fuelcost(17,l0,l2). fuelcost(17,l1,l0). fuelcost(17,l1,l4). goal(p0,l3). goal(p1,l0). goal(p2,l4). goal(p3,l6). goal(p4,l1). goal(p5,l2). goal(p6,l1).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The starting fuel for truck t0 is one hundred and twenty-five. The package p6 must remain at location l1. Initially, p3 is found at location l0. The cost of traveling from l1 to l0 is seventeen unit/s. The last location for package p3 is l6. seventeen unit/s are required to travel between locations l1 and l4. The starting location of object p1 is l6. Package p4 will be delivered to l1. The destination for package p1 is l0. The object p4 is initially at location l0. The object t0 is positioned at location l5 initially. The travel cost between l0 and l2 is seventeen unit/s. The cost of traveling from l2 to l6 is fourteen unit/s. Traveling between locations l1 and l2 costs fifteen unit/s. Initially, p6 is found at location l2. The destination for package p2 is l4. Traveling between locations l0 and l1 costs seventeen unit/s. The cost of traveling from l6 to l2 is fourteen unit/s. The object p2 is positioned at location l2 initially. Eight steps are provided: step 1 to step 8. Traveling between locations l2 and l1 costs fifteen unit/s. The starting location of object p0 is l5. The package p0 must stay at location l3. The destination for package p5 is l2. The object p5 begins at location l4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9137177840809362307", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "It cost eighteen unit/s for traveling between locations l2 and l5. The cost of traveling from l8 to l3 is one unit/s. The package p6 must remain at location l2. The travel cost between l6 and l4 is fourteen unit/s. The object p0 is positioned at location l6 initially. The object p4 begins at location l7. Object p7 is initially located at l6. The object p2 begins at location l8. The destination for package p5 is l4. The last location for package p1 is l3. Package p7 will be delivered to l1. Initially, p3 is found at location l3. The object p6 is initially at location l0. The travel cost between l1 and l6 is eighteen unit/s. Eight allowed steps are available: step(1) through step(8). The object p5 is positioned at location l8 initially. It cost fourteen unit/s for traveling between locations l4 and l6. The starting location of object p1 is l0. Truck t0 has an initial fuel amount of one hundred and twenty-five. fifteen unit/s are required to travel between locations l2 and l4. It takes fifteen unit/s to travel between locations l4 and l2. The package p3 must remain at location l6. The last location for package p2 is l1. The destination for package p0 is l2. The package p4 must remain at location l8. one unit/s are required to travel between locations l3 and l8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l6). at(p1,l0). at(p2,l8). at(p3,l3). at(p4,l7). at(p5,l8). at(p6,l0). at(p7,l6). fuel(t0,125). fuelcost(1,l3,l8). fuelcost(1,l8,l3). fuelcost(14,l4,l6). fuelcost(14,l6,l4). fuelcost(15,l2,l4). fuelcost(15,l4,l2). fuelcost(18,l1,l6). fuelcost(18,l2,l5). goal(p0,l2). goal(p1,l3). goal(p2,l1). goal(p3,l6). goal(p4,l8). goal(p5,l4). goal(p6,l2). goal(p7,l1).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```It cost eighteen unit/s for traveling between locations l2 and l5. The cost of traveling from l8 to l3 is one unit/s. The package p6 must remain at location l2. The travel cost between l6 and l4 is fourteen unit/s. The object p0 is positioned at location l6 initially. The object p4 begins at location l7. Object p7 is initially located at l6. The object p2 begins at location l8. The destination for package p5 is l4. The last location for package p1 is l3. Package p7 will be delivered to l1. Initially, p3 is found at location l3. The object p6 is initially at location l0. The travel cost between l1 and l6 is eighteen unit/s. Eight allowed steps are available: step(1) through step(8). The object p5 is positioned at location l8 initially. It cost fourteen unit/s for traveling between locations l4 and l6. The starting location of object p1 is l0. Truck t0 has an initial fuel amount of one hundred and twenty-five. fifteen unit/s are required to travel between locations l2 and l4. It takes fifteen unit/s to travel between locations l4 and l2. The package p3 must remain at location l6. The last location for package p2 is l1. The destination for package p0 is l2. The package p4 must remain at location l8. one unit/s are required to travel between locations l3 and l8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8778011878673792367", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "It takes eighteen unit/s to travel between locations l2 and l0. The package p2 must stay at location l0. The final location for package p3 is l1. It cost two unit/s for traveling between locations l3 and l0. The object p3 is initially at location l3. The travel cost between l0 and l2 is eighteen unit/s. It requires ten unit/s to travel between l1 and l0. The starting location of object p0 is l2. The cost of traveling from l0 to l3 is two unit/s. Eight steps can be followed, from step 1 to step 8. Object p1 is initially located at l2. thirteen unit/s are required to travel between locations l3 and l1. Traveling between locations l0 and l1 costs ten unit/s. The starting location of object t0 is l1. The package p0 must stay at location l1. The travel cost between l1 and l3 is thirteen unit/s. The initial fuel available for truck t0 is thirty-two. The last location for package p1 is l3. The object p2 is positioned at location l2 initially.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l2). at(p1,l2). at(p2,l2). at(p3,l3). at(t0,l1). fuel(t0,32). fuelcost(10,l0,l1). fuelcost(10,l1,l0). fuelcost(13,l1,l3). fuelcost(13,l3,l1). fuelcost(18,l0,l2). fuelcost(18,l2,l0). fuelcost(2,l0,l3). fuelcost(2,l3,l0). goal(p0,l1). goal(p1,l3). goal(p2,l0). goal(p3,l1).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```It takes eighteen unit/s to travel between locations l2 and l0. The package p2 must stay at location l0. The final location for package p3 is l1. It cost two unit/s for traveling between locations l3 and l0. The object p3 is initially at location l3. The travel cost between l0 and l2 is eighteen unit/s. It requires ten unit/s to travel between l1 and l0. The starting location of object p0 is l2. The cost of traveling from l0 to l3 is two unit/s. Eight steps can be followed, from step 1 to step 8. Object p1 is initially located at l2. thirteen unit/s are required to travel between locations l3 and l1. Traveling between locations l0 and l1 costs ten unit/s. The starting location of object t0 is l1. The package p0 must stay at location l1. The travel cost between l1 and l3 is thirteen unit/s. The initial fuel available for truck t0 is thirty-two. The last location for package p1 is l3. The object p2 is positioned at location l2 initially.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1491474366946504139", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The travel cost between l3 and l5 is seventeen unit/s. The package p5 must stay at location l2. The destination for package p3 is l2. Eight steps can be followed, from step 1 to step 8. The package p4 must remain at location l6. The package p0 must stay at location l1. Initially, p5 is found at location l3. The initial amount of fuel for truck t0 is eighty-two. It requires fourteen unit/s to travel between l0 and l3. Initially, p0 is found at location l3. The cost of traveling from l3 to l0 is fourteen unit/s. Object p3 is initially located at l6. The cost of traveling from l4 to l5 is twelve unit/s. The last location for package p2 is l1. It requires twelve unit/s to travel between l5 and l4. The travel cost between l4 and l6 is one unit/s. Initially, p4 is found at location l0. It requires seventeen unit/s to travel between l5 and l3. The travel cost between l6 and l4 is one unit/s. The final location for package p1 is l5. The object t0 is initially at location l1. Object p2 is initially located at l0. The package p6 must stay at location l3. The object p6 begins at location l0. The object p1 is initially at location l6.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l3). at(p1,l6). at(p2,l0). at(p3,l6). at(p4,l0). at(p5,l3). at(p6,l0). at(t0,l1). fuel(t0,82). fuelcost(1,l4,l6). fuelcost(1,l6,l4). fuelcost(12,l4,l5). fuelcost(12,l5,l4). fuelcost(14,l0,l3). fuelcost(14,l3,l0). fuelcost(17,l3,l5). fuelcost(17,l5,l3). goal(p0,l1). goal(p1,l5). goal(p2,l1). goal(p3,l2). goal(p4,l6). goal(p5,l2). goal(p6,l3).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The travel cost between l3 and l5 is seventeen unit/s. The package p5 must stay at location l2. The destination for package p3 is l2. Eight steps can be followed, from step 1 to step 8. The package p4 must remain at location l6. The package p0 must stay at location l1. Initially, p5 is found at location l3. The initial amount of fuel for truck t0 is eighty-two. It requires fourteen unit/s to travel between l0 and l3. Initially, p0 is found at location l3. The cost of traveling from l3 to l0 is fourteen unit/s. Object p3 is initially located at l6. The cost of traveling from l4 to l5 is twelve unit/s. The last location for package p2 is l1. It requires twelve unit/s to travel between l5 and l4. The travel cost between l4 and l6 is one unit/s. Initially, p4 is found at location l0. It requires seventeen unit/s to travel between l5 and l3. The travel cost between l6 and l4 is one unit/s. The final location for package p1 is l5. The object t0 is initially at location l1. Object p2 is initially located at l0. The package p6 must stay at location l3. The object p6 begins at location l0. The object p1 is initially at location l6.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "102672579109805650", "problem_id": "38", "problem_name": "Nomystery", "description": "An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.", "format": "In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.", "text": "The object p3 is positioned at location l4 initially. thirteen unit/s are required to travel between locations l5 and l4. Traveling between locations l2 and l1 costs ten unit/s. Traveling between locations l0 and l3 costs twenty unit/s. The destination for package p1 is l2. Initially, p2 is found at location l2. The last location for package p3 is l0. The destination for package p5 is l3. The starting location of object p5 is l0. The starting location of object p4 is l5. The package p2 must stay at location l5. Eight steps can be followed, from step 1 to step 8. The final location for package p4 is l1. The travel cost between l0 and l4 is fifteen unit/s. Package p0 will be delivered to l2. The starting location of object t0 is l1. It requires thirteen unit/s to travel between l4 and l5. Truck t0 has an initial fuel amount of seventy-three. The object p1 is initially at location l0. ten unit/s are required to travel between locations l1 and l2. The object p0 begins at location l0. Traveling between locations l4 and l0 costs fifteen unit/s. The travel cost between l3 and l0 is twenty unit/s.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(p0,l0). at(p1,l0). at(p2,l2). at(p3,l4). at(p4,l5). at(p5,l0). at(t0,l1). fuel(t0,73). fuelcost(10,l1,l2). fuelcost(10,l2,l1). fuelcost(13,l4,l5). fuelcost(13,l5,l4). fuelcost(15,l0,l4). fuelcost(15,l4,l0). fuelcost(20,l0,l3). fuelcost(20,l3,l0). goal(p0,l2). goal(p1,l2). goal(p2,l5). goal(p3,l0). goal(p4,l1). goal(p5,l3).", "prompt": "Given the following problem description between triple backtips: \n ```An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.\nIn Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.\nThe authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:\nIn the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.\nFrom the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.```\nGiven the following specification for the predicates format: \n```In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:\n- fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) \n- at(o,l): the object o (either a package or a truck) is initially at location\n- l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) \n- goal(p,l): at the final step, the package p must stay at location\n- l step(s): s is an allowed step, for s a positive integer value\nthe predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.```\nExtract the datalog facts from this text: \n```The object p3 is positioned at location l4 initially. thirteen unit/s are required to travel between locations l5 and l4. Traveling between locations l2 and l1 costs ten unit/s. Traveling between locations l0 and l3 costs twenty unit/s. The destination for package p1 is l2. Initially, p2 is found at location l2. The last location for package p3 is l0. The destination for package p5 is l3. The starting location of object p5 is l0. The starting location of object p4 is l5. The package p2 must stay at location l5. Eight steps can be followed, from step 1 to step 8. The final location for package p4 is l1. The travel cost between l0 and l4 is fifteen unit/s. Package p0 will be delivered to l2. The starting location of object t0 is l1. It requires thirteen unit/s to travel between l4 and l5. Truck t0 has an initial fuel amount of seventy-three. The object p1 is initially at location l0. ten unit/s are required to travel between locations l1 and l2. The object p0 begins at location l0. Traveling between locations l4 and l0 costs fifteen unit/s. The travel cost between l3 and l0 is twenty unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5190112041113090557", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 64.\n- DoorSensor(10) belongs to zone/s 24, 31.\n- DoorSensor(100) belongs to zone/s 10, 9.\n- DoorSensor(11) belongs to zone/s 27, 28.\n- DoorSensor(12) belongs to zone/s 61, 69.\n- DoorSensor(13) belongs to zone/s 61, 62.\n- DoorSensor(14) belongs to zone/s 46, 54.\n- DoorSensor(15) belongs to zone/s 57, 58.\n The maximum number of allowed partner units is two. There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(64,1). zone2sensor(24,10). zone2sensor(31,10). zone2sensor(10,100). zone2sensor(9,100). zone2sensor(27,11). zone2sensor(28,11). zone2sensor(61,12). zone2sensor(69,12). zone2sensor(61,13). zone2sensor(62,13). zone2sensor(46,14). zone2sensor(54,14). zone2sensor(57,15). zone2sensor(58,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 64.\n- DoorSensor(10) belongs to zone/s 24, 31.\n- DoorSensor(100) belongs to zone/s 10, 9.\n- DoorSensor(11) belongs to zone/s 27, 28.\n- DoorSensor(12) belongs to zone/s 61, 69.\n- DoorSensor(13) belongs to zone/s 61, 62.\n- DoorSensor(14) belongs to zone/s 46, 54.\n- DoorSensor(15) belongs to zone/s 57, 58.\n The maximum number of allowed partner units is two. There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8650211566607439388", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1.\n- DoorSensor(10) belongs to zone/s 62, 69.\n- DoorSensor(100) belongs to zone/s 33, 41.\n- DoorSensor(11) belongs to zone/s 54, 61.\n- DoorSensor(12) belongs to zone/s 45, 52.\n- DoorSensor(13) belongs to zone/s 23, 30.\n- DoorSensor(14) belongs to zone/s 19, 20.\n- DoorSensor(15) belongs to zone/s 27, 35.\n The maximum number of allowed partner units is two.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(1,1). zone2sensor(62,10). zone2sensor(69,10). zone2sensor(33,100). zone2sensor(41,100). zone2sensor(54,11). zone2sensor(61,11). zone2sensor(45,12). zone2sensor(52,12). zone2sensor(23,13). zone2sensor(30,13). zone2sensor(19,14). zone2sensor(20,14). zone2sensor(27,15). zone2sensor(35,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1.\n- DoorSensor(10) belongs to zone/s 62, 69.\n- DoorSensor(100) belongs to zone/s 33, 41.\n- DoorSensor(11) belongs to zone/s 54, 61.\n- DoorSensor(12) belongs to zone/s 45, 52.\n- DoorSensor(13) belongs to zone/s 23, 30.\n- DoorSensor(14) belongs to zone/s 19, 20.\n- DoorSensor(15) belongs to zone/s 27, 35.\n The maximum number of allowed partner units is two.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8218642910395958344", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 22.\n- DoorSensor(10) belongs to zone/s 38, 39.\n- DoorSensor(100) belongs to zone/s 35, 43.\n- DoorSensor(11) belongs to zone/s 23, 24.\n- DoorSensor(12) belongs to zone/s 49, 50.\n- DoorSensor(13) belongs to zone/s 12, 13.\n- DoorSensor(14) belongs to zone/s 29, 37.\n- DoorSensor(15) belongs to zone/s 39, 47.\n The maximum allowed number of partner units is four. There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(22,1). zone2sensor(38,10). zone2sensor(39,10). zone2sensor(35,100). zone2sensor(43,100). zone2sensor(23,11). zone2sensor(24,11). zone2sensor(49,12). zone2sensor(50,12). zone2sensor(12,13). zone2sensor(13,13). zone2sensor(29,14). zone2sensor(37,14). zone2sensor(39,15). zone2sensor(47,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 22.\n- DoorSensor(10) belongs to zone/s 38, 39.\n- DoorSensor(100) belongs to zone/s 35, 43.\n- DoorSensor(11) belongs to zone/s 23, 24.\n- DoorSensor(12) belongs to zone/s 49, 50.\n- DoorSensor(13) belongs to zone/s 12, 13.\n- DoorSensor(14) belongs to zone/s 29, 37.\n- DoorSensor(15) belongs to zone/s 39, 47.\n The maximum allowed number of partner units is four. There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8461053737619830766", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 72.\n- DoorSensor(10) belongs to zone/s 60, 61.\n- DoorSensor(100) belongs to zone/s 17, 24.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 10, 11.\n- DoorSensor(13) belongs to zone/s 1, 8.\n- DoorSensor(14) belongs to zone/s 52, 53.\n- DoorSensor(15) belongs to zone/s 1, 2.\n There are eight available unit/s. The upper limit for partner units is four.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(72,1). zone2sensor(60,10). zone2sensor(61,10). zone2sensor(17,100). zone2sensor(24,100). zone2sensor(44,11). zone2sensor(45,11). zone2sensor(10,12). zone2sensor(11,12). zone2sensor(1,13). zone2sensor(8,13). zone2sensor(52,14). zone2sensor(53,14). zone2sensor(1,15). zone2sensor(2,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 72.\n- DoorSensor(10) belongs to zone/s 60, 61.\n- DoorSensor(100) belongs to zone/s 17, 24.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 10, 11.\n- DoorSensor(13) belongs to zone/s 1, 8.\n- DoorSensor(14) belongs to zone/s 52, 53.\n- DoorSensor(15) belongs to zone/s 1, 2.\n There are eight available unit/s. The upper limit for partner units is four.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1655906953869818543", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. The maximum number of partner units that can be allowed is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 72.\n- DoorSensor(10) belongs to zone/s 2, 3.\n- DoorSensor(100) belongs to zone/s 40, 41.\n- DoorSensor(11) belongs to zone/s 52, 60.\n- DoorSensor(12) belongs to zone/s 7, 8.\n- DoorSensor(13) belongs to zone/s 31, 39.\n- DoorSensor(14) belongs to zone/s 28, 29.\n- DoorSensor(15) belongs to zone/s 49, 50.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(72,1). zone2sensor(2,10). zone2sensor(3,10). zone2sensor(40,100). zone2sensor(41,100). zone2sensor(52,11). zone2sensor(60,11). zone2sensor(7,12). zone2sensor(8,12). zone2sensor(31,13). zone2sensor(39,13). zone2sensor(28,14). zone2sensor(29,14). zone2sensor(49,15). zone2sensor(50,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. The maximum number of partner units that can be allowed is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 72.\n- DoorSensor(10) belongs to zone/s 2, 3.\n- DoorSensor(100) belongs to zone/s 40, 41.\n- DoorSensor(11) belongs to zone/s 52, 60.\n- DoorSensor(12) belongs to zone/s 7, 8.\n- DoorSensor(13) belongs to zone/s 31, 39.\n- DoorSensor(14) belongs to zone/s 28, 29.\n- DoorSensor(15) belongs to zone/s 49, 50.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2092606017618851406", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 39.\n- DoorSensor(10) belongs to zone/s 12, 20.\n- DoorSensor(100) belongs to zone/s 60, 61.\n- DoorSensor(11) belongs to zone/s 14, 6.\n- DoorSensor(12) belongs to zone/s 73, 74.\n- DoorSensor(13) belongs to zone/s 65, 66.\n- DoorSensor(14) belongs to zone/s 5, 6.\n- DoorSensor(15) belongs to zone/s 15, 23.\n There are eight available unit/s. The maximum allowed number of partner units is four.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(39,1). zone2sensor(12,10). zone2sensor(20,10). zone2sensor(60,100). zone2sensor(61,100). zone2sensor(14,11). zone2sensor(6,11). zone2sensor(73,12). zone2sensor(74,12). zone2sensor(65,13). zone2sensor(66,13). zone2sensor(5,14). zone2sensor(6,14). zone2sensor(15,15). zone2sensor(23,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 39.\n- DoorSensor(10) belongs to zone/s 12, 20.\n- DoorSensor(100) belongs to zone/s 60, 61.\n- DoorSensor(11) belongs to zone/s 14, 6.\n- DoorSensor(12) belongs to zone/s 73, 74.\n- DoorSensor(13) belongs to zone/s 65, 66.\n- DoorSensor(14) belongs to zone/s 5, 6.\n- DoorSensor(15) belongs to zone/s 15, 23.\n There are eight available unit/s. The maximum allowed number of partner units is four.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3515080975319306709", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. The maximum number of partner units that can be allowed is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1, 31, 32.\n- DoorSensor(10) belongs to zone/s 10, 13.\n- DoorSensor(11) belongs to zone/s 16, 17.\n- DoorSensor(12) belongs to zone/s 13, 16.\n- DoorSensor(13) belongs to zone/s 19, 20.\n- DoorSensor(14) belongs to zone/s 16, 19.\n- DoorSensor(15) belongs to zone/s 22, 23.\n- DoorSensor(16) belongs to zone/s 19, 22.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(1,1). zone2sensor(31,1). zone2sensor(32,1). zone2sensor(10,10). zone2sensor(13,10). zone2sensor(16,11). zone2sensor(17,11). zone2sensor(13,12). zone2sensor(16,12). zone2sensor(19,13). zone2sensor(20,13). zone2sensor(16,14). zone2sensor(19,14). zone2sensor(22,15). zone2sensor(23,15). zone2sensor(19,16). zone2sensor(22,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. The maximum number of partner units that can be allowed is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1, 31, 32.\n- DoorSensor(10) belongs to zone/s 10, 13.\n- DoorSensor(11) belongs to zone/s 16, 17.\n- DoorSensor(12) belongs to zone/s 13, 16.\n- DoorSensor(13) belongs to zone/s 19, 20.\n- DoorSensor(14) belongs to zone/s 16, 19.\n- DoorSensor(15) belongs to zone/s 22, 23.\n- DoorSensor(16) belongs to zone/s 19, 22.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3939722914177153263", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 56.\n- DoorSensor(10) belongs to zone/s 7, 8.\n- DoorSensor(11) belongs to zone/s 11, 3.\n- DoorSensor(12) belongs to zone/s 22, 28.\n- DoorSensor(13) belongs to zone/s 43, 44.\n- DoorSensor(14) belongs to zone/s 36, 37.\n- DoorSensor(15) belongs to zone/s 15, 20.\n- DoorSensor(16) belongs to zone/s 12, 4.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(56,1). zone2sensor(7,10). zone2sensor(8,10). zone2sensor(11,11). zone2sensor(3,11). zone2sensor(22,12). zone2sensor(28,12). zone2sensor(43,13). zone2sensor(44,13). zone2sensor(36,14). zone2sensor(37,14). zone2sensor(15,15). zone2sensor(20,15). zone2sensor(12,16). zone2sensor(4,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 56.\n- DoorSensor(10) belongs to zone/s 7, 8.\n- DoorSensor(11) belongs to zone/s 11, 3.\n- DoorSensor(12) belongs to zone/s 22, 28.\n- DoorSensor(13) belongs to zone/s 43, 44.\n- DoorSensor(14) belongs to zone/s 36, 37.\n- DoorSensor(15) belongs to zone/s 15, 20.\n- DoorSensor(16) belongs to zone/s 12, 4.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5645988614419189415", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 22.\n- DoorSensor(10) belongs to zone/s 38, 39.\n- DoorSensor(100) belongs to zone/s 35, 43.\n- DoorSensor(11) belongs to zone/s 23, 24.\n- DoorSensor(12) belongs to zone/s 49, 50.\n- DoorSensor(13) belongs to zone/s 12, 13.\n- DoorSensor(14) belongs to zone/s 29, 37.\n- DoorSensor(15) belongs to zone/s 39, 47.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(22,1). zone2sensor(38,10). zone2sensor(39,10). zone2sensor(35,100). zone2sensor(43,100). zone2sensor(23,11). zone2sensor(24,11). zone2sensor(49,12). zone2sensor(50,12). zone2sensor(12,13). zone2sensor(13,13). zone2sensor(29,14). zone2sensor(37,14). zone2sensor(39,15). zone2sensor(47,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 22.\n- DoorSensor(10) belongs to zone/s 38, 39.\n- DoorSensor(100) belongs to zone/s 35, 43.\n- DoorSensor(11) belongs to zone/s 23, 24.\n- DoorSensor(12) belongs to zone/s 49, 50.\n- DoorSensor(13) belongs to zone/s 12, 13.\n- DoorSensor(14) belongs to zone/s 29, 37.\n- DoorSensor(15) belongs to zone/s 39, 47.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7194800047776103804", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 77.\n- DoorSensor(10) belongs to zone/s 11, 4.\n- DoorSensor(100) belongs to zone/s 45, 53.\n- DoorSensor(11) belongs to zone/s 56, 57.\n- DoorSensor(12) belongs to zone/s 18, 26.\n- DoorSensor(13) belongs to zone/s 15, 7.\n- DoorSensor(14) belongs to zone/s 70, 78.\n- DoorSensor(15) belongs to zone/s 35, 43.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(77,1). zone2sensor(11,10). zone2sensor(4,10). zone2sensor(45,100). zone2sensor(53,100). zone2sensor(56,11). zone2sensor(57,11). zone2sensor(18,12). zone2sensor(26,12). zone2sensor(15,13). zone2sensor(7,13). zone2sensor(70,14). zone2sensor(78,14). zone2sensor(35,15). zone2sensor(43,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 77.\n- DoorSensor(10) belongs to zone/s 11, 4.\n- DoorSensor(100) belongs to zone/s 45, 53.\n- DoorSensor(11) belongs to zone/s 56, 57.\n- DoorSensor(12) belongs to zone/s 18, 26.\n- DoorSensor(13) belongs to zone/s 15, 7.\n- DoorSensor(14) belongs to zone/s 70, 78.\n- DoorSensor(15) belongs to zone/s 35, 43.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2241195531494690753", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. The maximum allowed number of partner units is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 4.\n- DoorSensor(10) belongs to zone/s 15, 16.\n- DoorSensor(100) belongs to zone/s 10, 18.\n- DoorSensor(11) belongs to zone/s 13, 5.\n- DoorSensor(12) belongs to zone/s 44, 45.\n- DoorSensor(13) belongs to zone/s 55, 56.\n- DoorSensor(14) belongs to zone/s 16, 8.\n- DoorSensor(15) belongs to zone/s 43, 51.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(4,1). zone2sensor(15,10). zone2sensor(16,10). zone2sensor(10,100). zone2sensor(18,100). zone2sensor(13,11). zone2sensor(5,11). zone2sensor(44,12). zone2sensor(45,12). zone2sensor(55,13). zone2sensor(56,13). zone2sensor(16,14). zone2sensor(8,14). zone2sensor(43,15). zone2sensor(51,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. The maximum allowed number of partner units is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 4.\n- DoorSensor(10) belongs to zone/s 15, 16.\n- DoorSensor(100) belongs to zone/s 10, 18.\n- DoorSensor(11) belongs to zone/s 13, 5.\n- DoorSensor(12) belongs to zone/s 44, 45.\n- DoorSensor(13) belongs to zone/s 55, 56.\n- DoorSensor(14) belongs to zone/s 16, 8.\n- DoorSensor(15) belongs to zone/s 43, 51.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4773183855266791607", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 57.\n- DoorSensor(10) belongs to zone/s 44, 52.\n- DoorSensor(100) belongs to zone/s 46, 54.\n- DoorSensor(11) belongs to zone/s 61, 62.\n- DoorSensor(12) belongs to zone/s 12, 13.\n- DoorSensor(13) belongs to zone/s 1, 9.\n- DoorSensor(14) belongs to zone/s 49, 57.\n- DoorSensor(15) belongs to zone/s 23, 31.\n There are eight available unit/s. The maximum number of allowed partner units is four.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(57,1). zone2sensor(44,10). zone2sensor(52,10). zone2sensor(46,100). zone2sensor(54,100). zone2sensor(61,11). zone2sensor(62,11). zone2sensor(12,12). zone2sensor(13,12). zone2sensor(1,13). zone2sensor(9,13). zone2sensor(49,14). zone2sensor(57,14). zone2sensor(23,15). zone2sensor(31,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 57.\n- DoorSensor(10) belongs to zone/s 44, 52.\n- DoorSensor(100) belongs to zone/s 46, 54.\n- DoorSensor(11) belongs to zone/s 61, 62.\n- DoorSensor(12) belongs to zone/s 12, 13.\n- DoorSensor(13) belongs to zone/s 1, 9.\n- DoorSensor(14) belongs to zone/s 49, 57.\n- DoorSensor(15) belongs to zone/s 23, 31.\n There are eight available unit/s. The maximum number of allowed partner units is four.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6211090279050159403", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum allowed number of partner units is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1.\n- DoorSensor(10) belongs to zone/s 45, 46.\n- DoorSensor(100) belongs to zone/s 49, 57.\n- DoorSensor(11) belongs to zone/s 20, 21.\n- DoorSensor(12) belongs to zone/s 40, 48.\n- DoorSensor(13) belongs to zone/s 50, 58.\n- DoorSensor(14) belongs to zone/s 70, 78.\n- DoorSensor(15) belongs to zone/s 78, 79.\n There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(1,1). zone2sensor(45,10). zone2sensor(46,10). zone2sensor(49,100). zone2sensor(57,100). zone2sensor(20,11). zone2sensor(21,11). zone2sensor(40,12). zone2sensor(48,12). zone2sensor(50,13). zone2sensor(58,13). zone2sensor(70,14). zone2sensor(78,14). zone2sensor(78,15). zone2sensor(79,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum allowed number of partner units is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1.\n- DoorSensor(10) belongs to zone/s 45, 46.\n- DoorSensor(100) belongs to zone/s 49, 57.\n- DoorSensor(11) belongs to zone/s 20, 21.\n- DoorSensor(12) belongs to zone/s 40, 48.\n- DoorSensor(13) belongs to zone/s 50, 58.\n- DoorSensor(14) belongs to zone/s 70, 78.\n- DoorSensor(15) belongs to zone/s 78, 79.\n There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6356406325427998233", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 42.\n- DoorSensor(10) belongs to zone/s 40, 41.\n- DoorSensor(11) belongs to zone/s 5, 9.\n- DoorSensor(12) belongs to zone/s 42, 50.\n- DoorSensor(13) belongs to zone/s 61, 62.\n- DoorSensor(14) belongs to zone/s 30, 35.\n- DoorSensor(15) belongs to zone/s 20, 27.\n- DoorSensor(16) belongs to zone/s 27, 28.\n The maximum allowed number of partner units is two. There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(42,1). zone2sensor(40,10). zone2sensor(41,10). zone2sensor(5,11). zone2sensor(9,11). zone2sensor(42,12). zone2sensor(50,12). zone2sensor(61,13). zone2sensor(62,13). zone2sensor(30,14). zone2sensor(35,14). zone2sensor(20,15). zone2sensor(27,15). zone2sensor(27,16). zone2sensor(28,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 42.\n- DoorSensor(10) belongs to zone/s 40, 41.\n- DoorSensor(11) belongs to zone/s 5, 9.\n- DoorSensor(12) belongs to zone/s 42, 50.\n- DoorSensor(13) belongs to zone/s 61, 62.\n- DoorSensor(14) belongs to zone/s 30, 35.\n- DoorSensor(15) belongs to zone/s 20, 27.\n- DoorSensor(16) belongs to zone/s 27, 28.\n The maximum allowed number of partner units is two. There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8420357023302660826", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 72.\n- DoorSensor(10) belongs to zone/s 60, 61.\n- DoorSensor(100) belongs to zone/s 17, 24.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 10, 11.\n- DoorSensor(13) belongs to zone/s 1, 8.\n- DoorSensor(14) belongs to zone/s 52, 53.\n- DoorSensor(15) belongs to zone/s 1, 2.\n The maximum number of partner units that can be allowed is two. There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(72,1). zone2sensor(60,10). zone2sensor(61,10). zone2sensor(17,100). zone2sensor(24,100). zone2sensor(44,11). zone2sensor(45,11). zone2sensor(10,12). zone2sensor(11,12). zone2sensor(1,13). zone2sensor(8,13). zone2sensor(52,14). zone2sensor(53,14). zone2sensor(1,15). zone2sensor(2,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 72.\n- DoorSensor(10) belongs to zone/s 60, 61.\n- DoorSensor(100) belongs to zone/s 17, 24.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 10, 11.\n- DoorSensor(13) belongs to zone/s 1, 8.\n- DoorSensor(14) belongs to zone/s 52, 53.\n- DoorSensor(15) belongs to zone/s 1, 2.\n The maximum number of partner units that can be allowed is two. There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4733007968317395856", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 59.\n- DoorSensor(10) belongs to zone/s 17, 23.\n- DoorSensor(11) belongs to zone/s 33, 41.\n- DoorSensor(12) belongs to zone/s 45, 52.\n- DoorSensor(13) belongs to zone/s 11, 12.\n- DoorSensor(14) belongs to zone/s 38, 39.\n- DoorSensor(15) belongs to zone/s 24, 30.\n- DoorSensor(16) belongs to zone/s 50, 55.\n There are eight available unit/s. The maximum allowed number of partner units is two.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(59,1). zone2sensor(17,10). zone2sensor(23,10). zone2sensor(33,11). zone2sensor(41,11). zone2sensor(45,12). zone2sensor(52,12). zone2sensor(11,13). zone2sensor(12,13). zone2sensor(38,14). zone2sensor(39,14). zone2sensor(24,15). zone2sensor(30,15). zone2sensor(50,16). zone2sensor(55,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 59.\n- DoorSensor(10) belongs to zone/s 17, 23.\n- DoorSensor(11) belongs to zone/s 33, 41.\n- DoorSensor(12) belongs to zone/s 45, 52.\n- DoorSensor(13) belongs to zone/s 11, 12.\n- DoorSensor(14) belongs to zone/s 38, 39.\n- DoorSensor(15) belongs to zone/s 24, 30.\n- DoorSensor(16) belongs to zone/s 50, 55.\n There are eight available unit/s. The maximum allowed number of partner units is two.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "382094413528127077", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum allowed number of partner units is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 64.\n- DoorSensor(10) belongs to zone/s 23, 30.\n- DoorSensor(100) belongs to zone/s 44, 52.\n- DoorSensor(11) belongs to zone/s 59, 67.\n- DoorSensor(12) belongs to zone/s 22, 23.\n- DoorSensor(13) belongs to zone/s 26, 27.\n- DoorSensor(14) belongs to zone/s 45, 46.\n- DoorSensor(15) belongs to zone/s 53, 54.\n There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(64,1). zone2sensor(23,10). zone2sensor(30,10). zone2sensor(44,100). zone2sensor(52,100). zone2sensor(59,11). zone2sensor(67,11). zone2sensor(22,12). zone2sensor(23,12). zone2sensor(26,13). zone2sensor(27,13). zone2sensor(45,14). zone2sensor(46,14). zone2sensor(53,15). zone2sensor(54,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum allowed number of partner units is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 64.\n- DoorSensor(10) belongs to zone/s 23, 30.\n- DoorSensor(100) belongs to zone/s 44, 52.\n- DoorSensor(11) belongs to zone/s 59, 67.\n- DoorSensor(12) belongs to zone/s 22, 23.\n- DoorSensor(13) belongs to zone/s 26, 27.\n- DoorSensor(14) belongs to zone/s 45, 46.\n- DoorSensor(15) belongs to zone/s 53, 54.\n There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4581367174196172180", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. The maximum number of allowed partner units is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 8.\n- DoorSensor(10) belongs to zone/s 14, 6.\n- DoorSensor(100) belongs to zone/s 39, 47.\n- DoorSensor(11) belongs to zone/s 76, 77.\n- DoorSensor(12) belongs to zone/s 53, 61.\n- DoorSensor(13) belongs to zone/s 35, 43.\n- DoorSensor(14) belongs to zone/s 51, 59.\n- DoorSensor(15) belongs to zone/s 25, 26.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(8,1). zone2sensor(14,10). zone2sensor(6,10). zone2sensor(39,100). zone2sensor(47,100). zone2sensor(76,11). zone2sensor(77,11). zone2sensor(53,12). zone2sensor(61,12). zone2sensor(35,13). zone2sensor(43,13). zone2sensor(51,14). zone2sensor(59,14). zone2sensor(25,15). zone2sensor(26,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. The maximum number of allowed partner units is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 8.\n- DoorSensor(10) belongs to zone/s 14, 6.\n- DoorSensor(100) belongs to zone/s 39, 47.\n- DoorSensor(11) belongs to zone/s 76, 77.\n- DoorSensor(12) belongs to zone/s 53, 61.\n- DoorSensor(13) belongs to zone/s 35, 43.\n- DoorSensor(14) belongs to zone/s 51, 59.\n- DoorSensor(15) belongs to zone/s 25, 26.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6605305642132008777", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 34.\n- DoorSensor(10) belongs to zone/s 30, 31.\n- DoorSensor(11) belongs to zone/s 49, 56.\n- DoorSensor(12) belongs to zone/s 25, 31.\n- DoorSensor(13) belongs to zone/s 16, 17.\n- DoorSensor(14) belongs to zone/s 6, 7.\n- DoorSensor(15) belongs to zone/s 32, 38.\n- DoorSensor(16) belongs to zone/s 10, 11.\n The upper limit for partner units is two.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(34,1). zone2sensor(30,10). zone2sensor(31,10). zone2sensor(49,11). zone2sensor(56,11). zone2sensor(25,12). zone2sensor(31,12). zone2sensor(16,13). zone2sensor(17,13). zone2sensor(6,14). zone2sensor(7,14). zone2sensor(32,15). zone2sensor(38,15). zone2sensor(10,16). zone2sensor(11,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 34.\n- DoorSensor(10) belongs to zone/s 30, 31.\n- DoorSensor(11) belongs to zone/s 49, 56.\n- DoorSensor(12) belongs to zone/s 25, 31.\n- DoorSensor(13) belongs to zone/s 16, 17.\n- DoorSensor(14) belongs to zone/s 6, 7.\n- DoorSensor(15) belongs to zone/s 32, 38.\n- DoorSensor(16) belongs to zone/s 10, 11.\n The upper limit for partner units is two.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8391777542741180106", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 70.\n- DoorSensor(10) belongs to zone/s 51, 59.\n- DoorSensor(100) belongs to zone/s 34, 42.\n- DoorSensor(11) belongs to zone/s 68, 69.\n- DoorSensor(12) belongs to zone/s 56, 64.\n- DoorSensor(13) belongs to zone/s 10, 9.\n- DoorSensor(14) belongs to zone/s 22, 23.\n- DoorSensor(15) belongs to zone/s 71, 72.\n The upper limit for partner units is two. There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(70,1). zone2sensor(51,10). zone2sensor(59,10). zone2sensor(34,100). zone2sensor(42,100). zone2sensor(68,11). zone2sensor(69,11). zone2sensor(56,12). zone2sensor(64,12). zone2sensor(10,13). zone2sensor(9,13). zone2sensor(22,14). zone2sensor(23,14). zone2sensor(71,15). zone2sensor(72,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 70.\n- DoorSensor(10) belongs to zone/s 51, 59.\n- DoorSensor(100) belongs to zone/s 34, 42.\n- DoorSensor(11) belongs to zone/s 68, 69.\n- DoorSensor(12) belongs to zone/s 56, 64.\n- DoorSensor(13) belongs to zone/s 10, 9.\n- DoorSensor(14) belongs to zone/s 22, 23.\n- DoorSensor(15) belongs to zone/s 71, 72.\n The upper limit for partner units is two. There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5465072166551387119", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 16.\n- DoorSensor(10) belongs to zone/s 20, 21.\n- DoorSensor(100) belongs to zone/s 13, 21.\n- DoorSensor(11) belongs to zone/s 13, 14.\n- DoorSensor(12) belongs to zone/s 10, 11.\n- DoorSensor(13) belongs to zone/s 5, 6.\n- DoorSensor(14) belongs to zone/s 4, 5.\n- DoorSensor(15) belongs to zone/s 53, 61.\n The upper limit for partner units is four.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(16,1). zone2sensor(20,10). zone2sensor(21,10). zone2sensor(13,100). zone2sensor(21,100). zone2sensor(13,11). zone2sensor(14,11). zone2sensor(10,12). zone2sensor(11,12). zone2sensor(5,13). zone2sensor(6,13). zone2sensor(4,14). zone2sensor(5,14). zone2sensor(53,15). zone2sensor(61,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 16.\n- DoorSensor(10) belongs to zone/s 20, 21.\n- DoorSensor(100) belongs to zone/s 13, 21.\n- DoorSensor(11) belongs to zone/s 13, 14.\n- DoorSensor(12) belongs to zone/s 10, 11.\n- DoorSensor(13) belongs to zone/s 5, 6.\n- DoorSensor(14) belongs to zone/s 4, 5.\n- DoorSensor(15) belongs to zone/s 53, 61.\n The upper limit for partner units is four.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5234096181653395517", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 39.\n- DoorSensor(10) belongs to zone/s 65, 73.\n- DoorSensor(100) belongs to zone/s 75, 76.\n- DoorSensor(11) belongs to zone/s 18, 26.\n- DoorSensor(12) belongs to zone/s 37, 45.\n- DoorSensor(13) belongs to zone/s 6, 7.\n- DoorSensor(14) belongs to zone/s 12, 4.\n- DoorSensor(15) belongs to zone/s 31, 39.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(39,1). zone2sensor(65,10). zone2sensor(73,10). zone2sensor(75,100). zone2sensor(76,100). zone2sensor(18,11). zone2sensor(26,11). zone2sensor(37,12). zone2sensor(45,12). zone2sensor(6,13). zone2sensor(7,13). zone2sensor(12,14). zone2sensor(4,14). zone2sensor(31,15). zone2sensor(39,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum allowed number of partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 39.\n- DoorSensor(10) belongs to zone/s 65, 73.\n- DoorSensor(100) belongs to zone/s 75, 76.\n- DoorSensor(11) belongs to zone/s 18, 26.\n- DoorSensor(12) belongs to zone/s 37, 45.\n- DoorSensor(13) belongs to zone/s 6, 7.\n- DoorSensor(14) belongs to zone/s 12, 4.\n- DoorSensor(15) belongs to zone/s 31, 39.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6136681845373879405", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum number of allowed partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 76.\n- DoorSensor(10) belongs to zone/s 68, 76.\n- DoorSensor(100) belongs to zone/s 60, 68.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 45, 53.\n- DoorSensor(13) belongs to zone/s 18, 26.\n- DoorSensor(14) belongs to zone/s 25, 26.\n- DoorSensor(15) belongs to zone/s 46, 54.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(76,1). zone2sensor(68,10). zone2sensor(76,10). zone2sensor(60,100). zone2sensor(68,100). zone2sensor(44,11). zone2sensor(45,11). zone2sensor(45,12). zone2sensor(53,12). zone2sensor(18,13). zone2sensor(26,13). zone2sensor(25,14). zone2sensor(26,14). zone2sensor(46,15). zone2sensor(54,15). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum number of allowed partner units is two. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 76.\n- DoorSensor(10) belongs to zone/s 68, 76.\n- DoorSensor(100) belongs to zone/s 60, 68.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 45, 53.\n- DoorSensor(13) belongs to zone/s 18, 26.\n- DoorSensor(14) belongs to zone/s 25, 26.\n- DoorSensor(15) belongs to zone/s 46, 54.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6979097830776699970", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1, 2, 39, 40.\n- DoorSensor(10) belongs to zone/s 13, 32.\n- DoorSensor(11) belongs to zone/s 14, 15, 52, 53.\n- DoorSensor(12) belongs to zone/s 14, 33.\n- DoorSensor(13) belongs to zone/s 15, 16, 53, 54.\n- DoorSensor(14) belongs to zone/s 15, 34.\n- DoorSensor(15) belongs to zone/s 16, 17, 54, 55.\n- DoorSensor(16) belongs to zone/s 16, 35.\n There are eight available unit/s. The upper limit for partner units is two.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(1,1). zone2sensor(2,1). zone2sensor(39,1). zone2sensor(40,1). zone2sensor(13,10). zone2sensor(32,10). zone2sensor(14,11). zone2sensor(15,11). zone2sensor(52,11). zone2sensor(53,11). zone2sensor(14,12). zone2sensor(33,12). zone2sensor(15,13). zone2sensor(16,13). zone2sensor(53,13). zone2sensor(54,13). zone2sensor(15,14). zone2sensor(34,14). zone2sensor(16,15). zone2sensor(17,15). zone2sensor(54,15). zone2sensor(55,15). zone2sensor(16,16). zone2sensor(35,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1, 2, 39, 40.\n- DoorSensor(10) belongs to zone/s 13, 32.\n- DoorSensor(11) belongs to zone/s 14, 15, 52, 53.\n- DoorSensor(12) belongs to zone/s 14, 33.\n- DoorSensor(13) belongs to zone/s 15, 16, 53, 54.\n- DoorSensor(14) belongs to zone/s 15, 34.\n- DoorSensor(15) belongs to zone/s 16, 17, 54, 55.\n- DoorSensor(16) belongs to zone/s 16, 35.\n There are eight available unit/s. The upper limit for partner units is two.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1223977620858612629", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1, 2.\n- DoorSensor(10) belongs to zone/s 13, 28.\n- DoorSensor(11) belongs to zone/s 14, 15.\n- DoorSensor(12) belongs to zone/s 14, 29.\n- DoorSensor(13) belongs to zone/s 15, 30.\n- DoorSensor(14) belongs to zone/s 3, 4.\n- DoorSensor(15) belongs to zone/s 18, 3.\n- DoorSensor(16) belongs to zone/s 4, 5.\n The maximum allowed number of partner units is two.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(1,1). zone2sensor(2,1). zone2sensor(13,10). zone2sensor(28,10). zone2sensor(14,11). zone2sensor(15,11). zone2sensor(14,12). zone2sensor(29,12). zone2sensor(15,13). zone2sensor(30,13). zone2sensor(3,14). zone2sensor(4,14). zone2sensor(18,15). zone2sensor(3,15). zone2sensor(4,16). zone2sensor(5,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 1, 2.\n- DoorSensor(10) belongs to zone/s 13, 28.\n- DoorSensor(11) belongs to zone/s 14, 15.\n- DoorSensor(12) belongs to zone/s 14, 29.\n- DoorSensor(13) belongs to zone/s 15, 30.\n- DoorSensor(14) belongs to zone/s 3, 4.\n- DoorSensor(15) belongs to zone/s 18, 3.\n- DoorSensor(16) belongs to zone/s 4, 5.\n The maximum allowed number of partner units is two.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9118258629128342662", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum number of allowed partner units is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 32.\n- DoorSensor(10) belongs to zone/s 11, 19.\n- DoorSensor(11) belongs to zone/s 36, 40.\n- DoorSensor(12) belongs to zone/s 19, 25.\n- DoorSensor(13) belongs to zone/s 8, 9.\n- DoorSensor(14) belongs to zone/s 27, 28.\n- DoorSensor(15) belongs to zone/s 53, 60.\n- DoorSensor(16) belongs to zone/s 14, 7.\n There are eight available unit/s.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(32,1). zone2sensor(11,10). zone2sensor(19,10). zone2sensor(36,11). zone2sensor(40,11). zone2sensor(19,12). zone2sensor(25,12). zone2sensor(8,13). zone2sensor(9,13). zone2sensor(27,14). zone2sensor(28,14). zone2sensor(53,15). zone2sensor(60,15). zone2sensor(14,16). zone2sensor(7,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum number of allowed partner units is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 32.\n- DoorSensor(10) belongs to zone/s 11, 19.\n- DoorSensor(11) belongs to zone/s 36, 40.\n- DoorSensor(12) belongs to zone/s 19, 25.\n- DoorSensor(13) belongs to zone/s 8, 9.\n- DoorSensor(14) belongs to zone/s 27, 28.\n- DoorSensor(15) belongs to zone/s 53, 60.\n- DoorSensor(16) belongs to zone/s 14, 7.\n There are eight available unit/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6797947880540909562", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The maximum number of allowed partner units is four. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 64.\n- DoorSensor(10) belongs to zone/s 23, 30.\n- DoorSensor(100) belongs to zone/s 44, 52.\n- DoorSensor(11) belongs to zone/s 59, 67.\n- DoorSensor(12) belongs to zone/s 22, 23.\n- DoorSensor(13) belongs to zone/s 26, 27.\n- DoorSensor(14) belongs to zone/s 45, 46.\n- DoorSensor(15) belongs to zone/s 53, 54.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(64,1). zone2sensor(23,10). zone2sensor(30,10). zone2sensor(44,100). zone2sensor(52,100). zone2sensor(59,11). zone2sensor(67,11). zone2sensor(22,12). zone2sensor(23,12). zone2sensor(26,13). zone2sensor(27,13). zone2sensor(45,14). zone2sensor(46,14). zone2sensor(53,15). zone2sensor(54,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The maximum number of allowed partner units is four. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 64.\n- DoorSensor(10) belongs to zone/s 23, 30.\n- DoorSensor(100) belongs to zone/s 44, 52.\n- DoorSensor(11) belongs to zone/s 59, 67.\n- DoorSensor(12) belongs to zone/s 22, 23.\n- DoorSensor(13) belongs to zone/s 26, 27.\n- DoorSensor(14) belongs to zone/s 45, 46.\n- DoorSensor(15) belongs to zone/s 53, 54.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4113600284383796043", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 33.\n- DoorSensor(10) belongs to zone/s 44, 45.\n- DoorSensor(100) belongs to zone/s 13, 21.\n- DoorSensor(11) belongs to zone/s 54, 55.\n- DoorSensor(12) belongs to zone/s 75, 76.\n- DoorSensor(13) belongs to zone/s 15, 23.\n- DoorSensor(14) belongs to zone/s 46, 47.\n- DoorSensor(15) belongs to zone/s 49, 50.\n There are eight available unit/s. The upper limit for partner units is four.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(33,1). zone2sensor(44,10). zone2sensor(45,10). zone2sensor(13,100). zone2sensor(21,100). zone2sensor(54,11). zone2sensor(55,11). zone2sensor(75,12). zone2sensor(76,12). zone2sensor(15,13). zone2sensor(23,13). zone2sensor(46,14). zone2sensor(47,14). zone2sensor(49,15). zone2sensor(50,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 33.\n- DoorSensor(10) belongs to zone/s 44, 45.\n- DoorSensor(100) belongs to zone/s 13, 21.\n- DoorSensor(11) belongs to zone/s 54, 55.\n- DoorSensor(12) belongs to zone/s 75, 76.\n- DoorSensor(13) belongs to zone/s 15, 23.\n- DoorSensor(14) belongs to zone/s 46, 47.\n- DoorSensor(15) belongs to zone/s 49, 50.\n There are eight available unit/s. The upper limit for partner units is four.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4422507664626039748", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 25.\n- DoorSensor(10) belongs to zone/s 63, 71.\n- DoorSensor(100) belongs to zone/s 47, 48.\n- DoorSensor(11) belongs to zone/s 41, 42.\n- DoorSensor(12) belongs to zone/s 68, 76.\n- DoorSensor(13) belongs to zone/s 76, 77.\n- DoorSensor(14) belongs to zone/s 20, 28.\n- DoorSensor(15) belongs to zone/s 75, 76.\n There are eight available unit/s. The maximum allowed number of partner units is three.", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(25,1). zone2sensor(63,10). zone2sensor(71,10). zone2sensor(47,100). zone2sensor(48,100). zone2sensor(41,11). zone2sensor(42,11). zone2sensor(68,12). zone2sensor(76,12). zone2sensor(76,13). zone2sensor(77,13). zone2sensor(20,14). zone2sensor(28,14). zone2sensor(75,15). zone2sensor(76,15). maxPU(3).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 25.\n- DoorSensor(10) belongs to zone/s 63, 71.\n- DoorSensor(100) belongs to zone/s 47, 48.\n- DoorSensor(11) belongs to zone/s 41, 42.\n- DoorSensor(12) belongs to zone/s 68, 76.\n- DoorSensor(13) belongs to zone/s 76, 77.\n- DoorSensor(14) belongs to zone/s 20, 28.\n- DoorSensor(15) belongs to zone/s 75, 76.\n There are eight available unit/s. The maximum allowed number of partner units is three.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3607708597758449138", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "The upper limit for partner units is four. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 76.\n- DoorSensor(10) belongs to zone/s 68, 76.\n- DoorSensor(100) belongs to zone/s 60, 68.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 45, 53.\n- DoorSensor(13) belongs to zone/s 18, 26.\n- DoorSensor(14) belongs to zone/s 25, 26.\n- DoorSensor(15) belongs to zone/s 46, 54.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(76,1). zone2sensor(68,10). zone2sensor(76,10). zone2sensor(60,100). zone2sensor(68,100). zone2sensor(44,11). zone2sensor(45,11). zone2sensor(45,12). zone2sensor(53,12). zone2sensor(18,13). zone2sensor(26,13). zone2sensor(25,14). zone2sensor(26,14). zone2sensor(46,15). zone2sensor(54,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```The upper limit for partner units is four. There are eight available unit/s. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 76.\n- DoorSensor(10) belongs to zone/s 68, 76.\n- DoorSensor(100) belongs to zone/s 60, 68.\n- DoorSensor(11) belongs to zone/s 44, 45.\n- DoorSensor(12) belongs to zone/s 45, 53.\n- DoorSensor(13) belongs to zone/s 18, 26.\n- DoorSensor(14) belongs to zone/s 25, 26.\n- DoorSensor(15) belongs to zone/s 46, 54.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4270702817488678067", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. The maximum allowed number of partner units is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 56.\n- DoorSensor(10) belongs to zone/s 45, 46.\n- DoorSensor(100) belongs to zone/s 26, 34.\n- DoorSensor(11) belongs to zone/s 10, 11.\n- DoorSensor(12) belongs to zone/s 13, 21.\n- DoorSensor(13) belongs to zone/s 37, 38.\n- DoorSensor(14) belongs to zone/s 3, 4.\n- DoorSensor(15) belongs to zone/s 7, 8.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(56,1). zone2sensor(45,10). zone2sensor(46,10). zone2sensor(26,100). zone2sensor(34,100). zone2sensor(10,11). zone2sensor(11,11). zone2sensor(13,12). zone2sensor(21,12). zone2sensor(37,13). zone2sensor(38,13). zone2sensor(3,14). zone2sensor(4,14). zone2sensor(7,15). zone2sensor(8,15). maxPU(4).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. The maximum allowed number of partner units is four. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 56.\n- DoorSensor(10) belongs to zone/s 45, 46.\n- DoorSensor(100) belongs to zone/s 26, 34.\n- DoorSensor(11) belongs to zone/s 10, 11.\n- DoorSensor(12) belongs to zone/s 13, 21.\n- DoorSensor(13) belongs to zone/s 37, 38.\n- DoorSensor(14) belongs to zone/s 3, 4.\n- DoorSensor(15) belongs to zone/s 7, 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6999017073021584610", "problem_id": "26", "problem_name": "Partner Units", "description": "A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.", "format": "The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).", "text": "There are eight available unit/s. The maximum number of partner units that can be allowed is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 5.\n- DoorSensor(10) belongs to zone/s 51, 56.\n- DoorSensor(11) belongs to zone/s 5, 6.\n- DoorSensor(12) belongs to zone/s 31, 32.\n- DoorSensor(13) belongs to zone/s 16, 8.\n- DoorSensor(14) belongs to zone/s 48, 53.\n- DoorSensor(15) belongs to zone/s 44, 49.\n- DoorSensor(16) belongs to zone/s 51, 52.\n", "output": "comUnit(1). comUnit(2). comUnit(3). comUnit(4). comUnit(5). comUnit(6). comUnit(7). comUnit(8). zone2sensor(5,1). zone2sensor(51,10). zone2sensor(56,10). zone2sensor(5,11). zone2sensor(6,11). zone2sensor(31,12). zone2sensor(32,12). zone2sensor(16,13). zone2sensor(8,13). zone2sensor(48,14). zone2sensor(53,14). zone2sensor(44,15). zone2sensor(49,15). zone2sensor(51,16). zone2sensor(52,16). maxPU(2).", "prompt": "Given the following problem description between triple backtips: \n ```A given people counting system includes three types of components, namely door sensor, zone, and communication unit. The problem requirements are:\n1. Each zone as well as each door sensor must be connected to exactly one unit;\n2. Each unit can control at most two door sensors and at most two zones;\n3. If a unit controls a door sensor that contributes to a zone controlled by another unit, then the two units must be connected directly, i.e. one unit becomes a partner unit of the other and vice versa;\n4. Each unit can have at most maxPU (>2) partner units.\n\nThe solution of the Partner Units problem is defined as follows: Given a consistent configuration of door sensors and zones (encoded in the binary predicate zone2sensor/2), a set of available units (comUnit/1), and a maximum number of allowed partnerunits (maxPU/1), find a valid assignment of units that satisfies all requirements.```\nGiven the following specification for the predicates format: \n```The predicates comUnit/1 and maxPU/1 define available units and the number of allowed partner units respectively. The fact that a door sensor belongs to a zone is given by means of zone2sensor/2 predicate, e.g. zone2sensor(1,1) means that doorSensor(1) belongs to zone(1).```\nExtract the datalog facts from this text: \n```There are eight available unit/s. The maximum number of partner units that can be allowed is two. A door sensor belongs to a zone as follows:\n- DoorSensor(1) belongs to zone/s 5.\n- DoorSensor(10) belongs to zone/s 51, 56.\n- DoorSensor(11) belongs to zone/s 5, 6.\n- DoorSensor(12) belongs to zone/s 31, 32.\n- DoorSensor(13) belongs to zone/s 16, 8.\n- DoorSensor(14) belongs to zone/s 48, 53.\n- DoorSensor(15) belongs to zone/s 44, 49.\n- DoorSensor(16) belongs to zone/s 51, 52.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1903949722672876701", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position one hundred and two, the value is 22. The value at position one hundred and one in the given text is 32. The value located at position one hundred and three in the text is 13. At the pattern position fourteen, the value is 42. The position number ten in the pattern has the value 6. The value at position one in the given pattern is 33. The value at position ten in the given text is 34. Position fifteen in the pattern holds the value 24. The pattern is a permutation of numbers of length forty-two. The value at position number twelve in the pattern is 38. The position number one hundred in the text has the value 136. At the text position one hundred and five, the value is 130. The value at position sixteen in the given pattern is 14. In the pattern, position eleven holds the value 39. The value at position one hundred and four in the given text is 65. The position number one in the text has the value 106. At the pattern position thirteen, the value is 23.", "output": "p(1,33). p(10,6). p(11,39). p(12,38). p(13,23). p(14,42). p(15,24). p(16,14). patternlength(42). t(1,106). t(10,34). t(100,136). t(101,32). t(102,22). t(103,13). t(104,65). t(105,130).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position one hundred and two, the value is 22. The value at position one hundred and one in the given text is 32. The value located at position one hundred and three in the text is 13. At the pattern position fourteen, the value is 42. The position number ten in the pattern has the value 6. The value at position one in the given pattern is 33. The value at position ten in the given text is 34. Position fifteen in the pattern holds the value 24. The pattern is a permutation of numbers of length forty-two. The value at position number twelve in the pattern is 38. The position number one hundred in the text has the value 136. At the text position one hundred and five, the value is 130. The value at position sixteen in the given pattern is 14. In the pattern, position eleven holds the value 39. The value at position one hundred and four in the given text is 65. The position number one in the text has the value 106. At the pattern position thirteen, the value is 23.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1327451609467233074", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position one hundred and four, the value is 25. In the pattern, position one holds the value 6. The value at position ten in the given text is 39. The pattern is a permutation of numbers of length twenty-four. The value at position one in the given text is 68. At the text position one hundred and one, the value is 77. At the text position one hundred, the value is 66. At the text position one hundred and five, the value is 14. At the pattern position sixteen, the value is 24. The value at position eleven in the given pattern is 4. The value at position number twelve in the pattern is 9. At the pattern position thirteen, the value is 16. At the pattern position fourteen, the value is 12. The value at position number ten in the pattern is 21. Position one hundred and two in the text holds the value 118. The value at position number one hundred and three in the text is 36. The value at position number fifteen in the pattern is 8.", "output": "p(1,6). p(10,21). p(11,4). p(12,9). p(13,16). p(14,12). p(15,8). p(16,24). patternlength(24). t(1,68). t(10,39). t(100,66). t(101,77). t(102,118). t(103,36). t(104,25). t(105,14).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position one hundred and four, the value is 25. In the pattern, position one holds the value 6. The value at position ten in the given text is 39. The pattern is a permutation of numbers of length twenty-four. The value at position one in the given text is 68. At the text position one hundred and one, the value is 77. At the text position one hundred, the value is 66. At the text position one hundred and five, the value is 14. At the pattern position sixteen, the value is 24. The value at position eleven in the given pattern is 4. The value at position number twelve in the pattern is 9. At the pattern position thirteen, the value is 16. At the pattern position fourteen, the value is 12. The value at position number ten in the pattern is 21. Position one hundred and two in the text holds the value 118. The value at position number one hundred and three in the text is 36. The value at position number fifteen in the pattern is 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3744537464710401560", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number one in the text has the value 45. The value at position number fifteen in the text is 9. The value at position number thirteen in the text is 56. The value 10 is located at position fifteen in the pattern. The pattern is a permutation of numbers of length twenty-one. The position number ten in the pattern has the value 15. The position number eleven in the pattern has the value 11. The value at position fourteen in the given pattern is 1. The value at position eleven in the given text is 24. The value 2 is located at position one in the pattern. The value 8 is located at position twelve in the pattern. The value located at position thirteen in the pattern is 14. At the text position ten, the value is 28. The value located at position sixteen in the text is 21. Position twelve in the text holds the value 14. In the pattern, position sixteen holds the value 19. The position number fourteen in the text has the value 5.", "output": "p(1,2). p(10,15). p(11,11). p(12,8). p(13,14). p(14,1). p(15,10). p(16,19). patternlength(21). t(1,45). t(10,28). t(11,24). t(12,14). t(13,56). t(14,5). t(15,9). t(16,21).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number one in the text has the value 45. The value at position number fifteen in the text is 9. The value at position number thirteen in the text is 56. The value 10 is located at position fifteen in the pattern. The pattern is a permutation of numbers of length twenty-one. The position number ten in the pattern has the value 15. The position number eleven in the pattern has the value 11. The value at position fourteen in the given pattern is 1. The value at position eleven in the given text is 24. The value 2 is located at position one in the pattern. The value 8 is located at position twelve in the pattern. The value located at position thirteen in the pattern is 14. At the text position ten, the value is 28. The value located at position sixteen in the text is 21. Position twelve in the text holds the value 14. In the pattern, position sixteen holds the value 19. The position number fourteen in the text has the value 5.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2026724253691907753", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number ten in the text has the value 43. The position number sixteen in the pattern has the value 15. The length of the pattern is forty-eight. At the text position one hundred, the value is 113. The value at position twelve in the given pattern is 22. At the pattern position thirteen, the value is 20. Position one in the text holds the value 92. The value at position number one hundred and three in the text is 73. Position one in the pattern holds the value 27. The value at position eleven in the given pattern is 47. At the text position one hundred and five, the value is 93. The value located at position fifteen in the pattern is 45. The value 13 is located at position fourteen in the pattern. Position one hundred and two in the text holds the value 62. The value at position ten in the given pattern is 1. At the text position one hundred and one, the value is 61. At the text position one hundred and four, the value is 69.", "output": "p(1,27). p(10,1). p(11,47). p(12,22). p(13,20). p(14,13). p(15,45). p(16,15). patternlength(48). t(1,92). t(10,43). t(100,113). t(101,61). t(102,62). t(103,73). t(104,69). t(105,93).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number ten in the text has the value 43. The position number sixteen in the pattern has the value 15. The length of the pattern is forty-eight. At the text position one hundred, the value is 113. The value at position twelve in the given pattern is 22. At the pattern position thirteen, the value is 20. Position one in the text holds the value 92. The value at position number one hundred and three in the text is 73. Position one in the pattern holds the value 27. The value at position eleven in the given pattern is 47. At the text position one hundred and five, the value is 93. The value located at position fifteen in the pattern is 45. The value 13 is located at position fourteen in the pattern. Position one hundred and two in the text holds the value 62. The value at position ten in the given pattern is 1. At the text position one hundred and one, the value is 61. At the text position one hundred and four, the value is 69.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3480440914158622896", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position fourteen in the given text is 2. The value located at position seven in the pattern is 3. Position two in the pattern holds the value 6. Position fifteen in the text holds the value 5. The value at position number eleven in the text is 48. The value 5 is located at position four in the pattern. The value at position number three in the pattern is 2. At the text position thirteen, the value is 23. At the text position one, the value is 3. At the pattern position five, the value is 7. The value located at position twelve in the text is 55. The value at position one in the given pattern is 1. The value at position ten in the given text is 18. The value 4 is located at position six in the pattern. The pattern is a permutation of numbers of length seven. At the text position sixteen, the value is 38.", "output": "p(1,1). p(2,6). p(3,2). p(4,5). p(5,7). p(6,4). p(7,3). patternlength(7). t(1,3). t(10,18). t(11,48). t(12,55). t(13,23). t(14,2). t(15,5). t(16,38).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position fourteen in the given text is 2. The value located at position seven in the pattern is 3. Position two in the pattern holds the value 6. Position fifteen in the text holds the value 5. The value at position number eleven in the text is 48. The value 5 is located at position four in the pattern. The value at position number three in the pattern is 2. At the text position thirteen, the value is 23. At the text position one, the value is 3. At the pattern position five, the value is 7. The value located at position twelve in the text is 55. The value at position one in the given pattern is 1. The value at position ten in the given text is 18. The value 4 is located at position six in the pattern. The pattern is a permutation of numbers of length seven. At the text position sixteen, the value is 38.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1914159457250153526", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "Position one hundred and three in the pattern holds the value 91. The pattern is a permutation of numbers of length one hundred and five. The value located at position one hundred and five in the text is 287. The value located at position one hundred and two in the pattern is 40. The value located at position one hundred and three in the text is 7. At the text position one hundred and one, the value is 132. Position one hundred in the pattern holds the value 75. The value at position ten in the given pattern is 78. Position one in the text holds the value 326. The value 50 is located at position one hundred and four in the pattern. The value at position one hundred and two in the given text is 246. The position number one hundred and one in the pattern has the value 104. The value at position one hundred and four in the given text is 22. The value located at position ten in the text is 54. Position one hundred in the text holds the value 264. The value at position one in the given pattern is 8. Position one hundred and five in the pattern holds the value 52.", "output": "p(1,8). p(10,78). p(100,75). p(101,104). p(102,40). p(103,91). p(104,50). p(105,52). patternlength(105). t(1,326). t(10,54). t(100,264). t(101,132). t(102,246). t(103,7). t(104,22). t(105,287).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```Position one hundred and three in the pattern holds the value 91. The pattern is a permutation of numbers of length one hundred and five. The value located at position one hundred and five in the text is 287. The value located at position one hundred and two in the pattern is 40. The value located at position one hundred and three in the text is 7. At the text position one hundred and one, the value is 132. Position one hundred in the pattern holds the value 75. The value at position ten in the given pattern is 78. Position one in the text holds the value 326. The value 50 is located at position one hundred and four in the pattern. The value at position one hundred and two in the given text is 246. The position number one hundred and one in the pattern has the value 104. The value at position one hundred and four in the given text is 22. The value located at position ten in the text is 54. Position one hundred in the text holds the value 264. The value at position one in the given pattern is 8. Position one hundred and five in the pattern holds the value 52.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "350110938328672696", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position ten in the given text is 72. The position number thirteen in the pattern has the value 20. In the pattern, position twelve holds the value 9. The value located at position one hundred and two in the text is 104. The value at position number eleven in the pattern is 1. The value located at position one hundred and four in the text is 102. Position one hundred in the text holds the value 2. The length of the pattern is twenty-eight. At the pattern position ten, the value is 6. The value at position number one in the text is 37. At the text position one hundred and five, the value is 40. In the pattern, position fourteen holds the value 2. The value located at position fifteen in the pattern is 18. The value at position sixteen in the given pattern is 14. At the pattern position one, the value is 28. Position one hundred and one in the text holds the value 134. The position number one hundred and three in the text has the value 130.", "output": "p(1,28). p(10,6). p(11,1). p(12,9). p(13,20). p(14,2). p(15,18). p(16,14). patternlength(28). t(1,37). t(10,72). t(100,2). t(101,134). t(102,104). t(103,130). t(104,102). t(105,40).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position ten in the given text is 72. The position number thirteen in the pattern has the value 20. In the pattern, position twelve holds the value 9. The value located at position one hundred and two in the text is 104. The value at position number eleven in the pattern is 1. The value located at position one hundred and four in the text is 102. Position one hundred in the text holds the value 2. The length of the pattern is twenty-eight. At the pattern position ten, the value is 6. The value at position number one in the text is 37. At the text position one hundred and five, the value is 40. In the pattern, position fourteen holds the value 2. The value located at position fifteen in the pattern is 18. The value at position sixteen in the given pattern is 14. At the pattern position one, the value is 28. Position one hundred and one in the text holds the value 134. The position number one hundred and three in the text has the value 130.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9108927159240965700", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position number one hundred and one in the text is 13. The value at position number one hundred in the text is 40. The position number three in the pattern has the value 6. At the pattern position ten, the value is 3. In the pattern, position two holds the value 12. The pattern is a permutation of numbers of length twelve. Position one hundred and four in the text holds the value 16. At the pattern position five, the value is 11. The value at position one hundred and three in the given text is 87. The value at position number one in the pattern is 10. At the text position one, the value is 23. At the text position ten, the value is 8. At the text position one hundred and two, the value is 58. The value located at position four in the pattern is 2. The position number twelve in the pattern has the value 8. The value at position number one hundred and five in the text is 107. The value 7 is located at position eleven in the pattern.", "output": "p(1,10). p(10,3). p(11,7). p(12,8). p(2,12). p(3,6). p(4,2). p(5,11). patternlength(12). t(1,23). t(10,8). t(100,40). t(101,13). t(102,58). t(103,87). t(104,16). t(105,107).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position number one hundred and one in the text is 13. The value at position number one hundred in the text is 40. The position number three in the pattern has the value 6. At the pattern position ten, the value is 3. In the pattern, position two holds the value 12. The pattern is a permutation of numbers of length twelve. Position one hundred and four in the text holds the value 16. At the pattern position five, the value is 11. The value at position one hundred and three in the given text is 87. The value at position number one in the pattern is 10. At the text position one, the value is 23. At the text position ten, the value is 8. At the text position one hundred and two, the value is 58. The value located at position four in the pattern is 2. The position number twelve in the pattern has the value 8. The value at position number one hundred and five in the text is 107. The value 7 is located at position eleven in the pattern.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1860257842124586412", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position thirteen, the value is 23. The value at position number twelve in the pattern is 8. The value 15 is located at position fourteen in the pattern. The value at position one in the given text is 15. The value 12 is located at position thirteen in the pattern. The length of the pattern is fifteen. The position number ten in the pattern has the value 3. The value at position number fifteen in the text is 4. The value located at position eleven in the pattern is 11. The value at position two in the given pattern is 13. Position twelve in the text holds the value 36. The position number sixteen in the text has the value 7. In the pattern, position fifteen holds the value 9. The value located at position ten in the text is 50. The value at position eleven in the given text is 9. At the text position fourteen, the value is 1. At the pattern position one, the value is 7.", "output": "p(1,7). p(10,3). p(11,11). p(12,8). p(13,12). p(14,15). p(15,9). p(2,13). patternlength(15). t(1,15). t(10,50). t(11,9). t(12,36). t(13,23). t(14,1). t(15,4). t(16,7).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position thirteen, the value is 23. The value at position number twelve in the pattern is 8. The value 15 is located at position fourteen in the pattern. The value at position one in the given text is 15. The value 12 is located at position thirteen in the pattern. The length of the pattern is fifteen. The position number ten in the pattern has the value 3. The value at position number fifteen in the text is 4. The value located at position eleven in the pattern is 11. The value at position two in the given pattern is 13. Position twelve in the text holds the value 36. The position number sixteen in the text has the value 7. In the pattern, position fifteen holds the value 9. The value located at position ten in the text is 50. The value at position eleven in the given text is 9. At the text position fourteen, the value is 1. At the pattern position one, the value is 7.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2897776570883187233", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position thirteen, the value is 27. The position number fifteen in the text has the value 30. Position one in the pattern holds the value 13. The length of the pattern is twenty-five. Position one in the text holds the value 9. At the text position ten, the value is 42. The value located at position twelve in the pattern is 12. The position number eleven in the pattern has the value 10. Position fourteen in the pattern holds the value 15. Position eleven in the text holds the value 38. The value 4 is located at position fifteen in the pattern. Position twelve in the text holds the value 29. The value at position number fourteen in the text is 25. The value at position number ten in the pattern is 6. Position sixteen in the pattern holds the value 19. The value located at position thirteen in the pattern is 16. The value located at position sixteen in the text is 34.", "output": "p(1,13). p(10,6). p(11,10). p(12,12). p(13,16). p(14,15). p(15,4). p(16,19). patternlength(25). t(1,9). t(10,42). t(11,38). t(12,29). t(13,27). t(14,25). t(15,30). t(16,34).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position thirteen, the value is 27. The position number fifteen in the text has the value 30. Position one in the pattern holds the value 13. The length of the pattern is twenty-five. Position one in the text holds the value 9. At the text position ten, the value is 42. The value located at position twelve in the pattern is 12. The position number eleven in the pattern has the value 10. Position fourteen in the pattern holds the value 15. Position eleven in the text holds the value 38. The value 4 is located at position fifteen in the pattern. Position twelve in the text holds the value 29. The value at position number fourteen in the text is 25. The value at position number ten in the pattern is 6. Position sixteen in the pattern holds the value 19. The value located at position thirteen in the pattern is 16. The value located at position sixteen in the text is 34.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3798676794868796407", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value located at position one in the text is 12. The position number fourteen in the pattern has the value 7. The value at position one hundred and one in the given text is 128. At the pattern position twelve, the value is 53. The value at position thirteen in the given pattern is 51. The value at position one in the given pattern is 16. Position one hundred and four in the text holds the value 140. The value located at position one hundred and two in the text is 22. At the pattern position fifteen, the value is 4. The value at position number one hundred and five in the text is 129. Position one hundred and three in the text holds the value 46. In the pattern, position sixteen holds the value 35. The position number ten in the pattern has the value 66. The value located at position one hundred in the text is 118. The value located at position ten in the text is 117. The value at position number eleven in the pattern is 27. The length of the pattern is seventy.", "output": "p(1,16). p(10,66). p(11,27). p(12,53). p(13,51). p(14,7). p(15,4). p(16,35). patternlength(70). t(1,12). t(10,117). t(100,118). t(101,128). t(102,22). t(103,46). t(104,140). t(105,129).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value located at position one in the text is 12. The position number fourteen in the pattern has the value 7. The value at position one hundred and one in the given text is 128. At the pattern position twelve, the value is 53. The value at position thirteen in the given pattern is 51. The value at position one in the given pattern is 16. Position one hundred and four in the text holds the value 140. The value located at position one hundred and two in the text is 22. At the pattern position fifteen, the value is 4. The value at position number one hundred and five in the text is 129. Position one hundred and three in the text holds the value 46. In the pattern, position sixteen holds the value 35. The position number ten in the pattern has the value 66. The value located at position one hundred in the text is 118. The value located at position ten in the text is 117. The value at position number eleven in the pattern is 27. The length of the pattern is seventy.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4727983392038268445", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the pattern position one, the value is 1. Position one hundred and three in the text holds the value 27. The position number sixteen in the pattern has the value 3. At the text position ten, the value is 58. At the pattern position eleven, the value is 22. The value located at position one hundred and five in the text is 22. The value at position number one in the text is 100. The value at position one hundred in the given text is 7. At the pattern position fifteen, the value is 24. The length of the pattern is thirty-six. At the pattern position thirteen, the value is 15. In the pattern, position twelve holds the value 30. At the text position one hundred and one, the value is 52. Position fourteen in the pattern holds the value 14. The position number ten in the pattern has the value 25. The value at position one hundred and four in the given text is 117. The position number one hundred and two in the text has the value 88.", "output": "p(1,1). p(10,25). p(11,22). p(12,30). p(13,15). p(14,14). p(15,24). p(16,3). patternlength(36). t(1,100). t(10,58). t(100,7). t(101,52). t(102,88). t(103,27). t(104,117). t(105,22).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the pattern position one, the value is 1. Position one hundred and three in the text holds the value 27. The position number sixteen in the pattern has the value 3. At the text position ten, the value is 58. At the pattern position eleven, the value is 22. The value located at position one hundred and five in the text is 22. The value at position number one in the text is 100. The value at position one hundred in the given text is 7. At the pattern position fifteen, the value is 24. The length of the pattern is thirty-six. At the pattern position thirteen, the value is 15. In the pattern, position twelve holds the value 30. At the text position one hundred and one, the value is 52. Position fourteen in the pattern holds the value 14. The position number ten in the pattern has the value 25. The value at position one hundred and four in the given text is 117. The position number one hundred and two in the text has the value 88.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2094664584531197992", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position one hundred, the value is 148. The position number ten in the text has the value 202. The value at position number thirteen in the pattern is 26. The value at position number twelve in the pattern is 19. Position sixteen in the pattern holds the value 48. The value located at position eleven in the pattern is 41. The value at position number one in the pattern is 4. The position number one hundred and four in the text has the value 127. Position one hundred and three in the text holds the value 62. At the text position one hundred and one, the value is 168. The value located at position one hundred and two in the text is 10. The value at position number fifteen in the pattern is 57. The value located at position one in the text is 146. The position number fourteen in the pattern has the value 40. Position one hundred and five in the text holds the value 1. Position ten in the pattern holds the value 34. The length of the pattern is seventy-five.", "output": "p(1,4). p(10,34). p(11,41). p(12,19). p(13,26). p(14,40). p(15,57). p(16,48). patternlength(75). t(1,146). t(10,202). t(100,148). t(101,168). t(102,10). t(103,62). t(104,127). t(105,1).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position one hundred, the value is 148. The position number ten in the text has the value 202. The value at position number thirteen in the pattern is 26. The value at position number twelve in the pattern is 19. Position sixteen in the pattern holds the value 48. The value located at position eleven in the pattern is 41. The value at position number one in the pattern is 4. The position number one hundred and four in the text has the value 127. Position one hundred and three in the text holds the value 62. At the text position one hundred and one, the value is 168. The value located at position one hundred and two in the text is 10. The value at position number fifteen in the pattern is 57. The value located at position one in the text is 146. The position number fourteen in the pattern has the value 40. Position one hundred and five in the text holds the value 1. Position ten in the pattern holds the value 34. The length of the pattern is seventy-five.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8855663190617686230", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position fourteen in the given pattern is 10. At the text position one hundred and three, the value is 227. Position one hundred in the text holds the value 156. The value located at position one in the text is 158. The value at position ten in the given text is 243. In the pattern, position one holds the value 23. At the text position one hundred and one, the value is 6. Position one hundred and two in the text holds the value 200. The pattern is a permutation of numbers of length fifty. Position one hundred and five in the text holds the value 55. The value 29 is located at position sixteen in the pattern. The value at position one hundred and four in the given text is 78. In the pattern, position twelve holds the value 46. Position fifteen in the pattern holds the value 38. The position number ten in the pattern has the value 8. The value at position number eleven in the pattern is 2. The value at position number thirteen in the pattern is 47.", "output": "p(1,23). p(10,8). p(11,2). p(12,46). p(13,47). p(14,10). p(15,38). p(16,29). patternlength(50). t(1,158). t(10,243). t(100,156). t(101,6). t(102,200). t(103,227). t(104,78). t(105,55).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position fourteen in the given pattern is 10. At the text position one hundred and three, the value is 227. Position one hundred in the text holds the value 156. The value located at position one in the text is 158. The value at position ten in the given text is 243. In the pattern, position one holds the value 23. At the text position one hundred and one, the value is 6. Position one hundred and two in the text holds the value 200. The pattern is a permutation of numbers of length fifty. Position one hundred and five in the text holds the value 55. The value 29 is located at position sixteen in the pattern. The value at position one hundred and four in the given text is 78. In the pattern, position twelve holds the value 46. Position fifteen in the pattern holds the value 38. The position number ten in the pattern has the value 8. The value at position number eleven in the pattern is 2. The value at position number thirteen in the pattern is 47.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2489526282814537571", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the pattern position sixteen, the value is 22. The value located at position thirteen in the pattern is 17. The position number one in the text has the value 8. The value at position number eleven in the pattern is 7. The pattern is a permutation of numbers of length forty-five. The value at position fifteen in the given pattern is 36. The value located at position sixteen in the text is 43. In the pattern, position twelve holds the value 12. Position ten in the text holds the value 50. The position number ten in the pattern has the value 15. At the text position fourteen, the value is 89. At the pattern position one, the value is 2. At the text position eleven, the value is 4. The value at position twelve in the given text is 9. Position fifteen in the text holds the value 17. The value located at position fourteen in the pattern is 44. The value located at position thirteen in the text is 11.", "output": "p(1,2). p(10,15). p(11,7). p(12,12). p(13,17). p(14,44). p(15,36). p(16,22). patternlength(45). t(1,8). t(10,50). t(11,4). t(12,9). t(13,11). t(14,89). t(15,17). t(16,43).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the pattern position sixteen, the value is 22. The value located at position thirteen in the pattern is 17. The position number one in the text has the value 8. The value at position number eleven in the pattern is 7. The pattern is a permutation of numbers of length forty-five. The value at position fifteen in the given pattern is 36. The value located at position sixteen in the text is 43. In the pattern, position twelve holds the value 12. Position ten in the text holds the value 50. The position number ten in the pattern has the value 15. At the text position fourteen, the value is 89. At the pattern position one, the value is 2. At the text position eleven, the value is 4. The value at position twelve in the given text is 9. Position fifteen in the text holds the value 17. The value located at position fourteen in the pattern is 44. The value located at position thirteen in the text is 11.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4632050264827758531", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value located at position ten in the pattern is 3. The value located at position one hundred in the text is 45. Position one hundred and three in the text holds the value 33. The value at position number thirteen in the pattern is 2. The value 10 is located at position fourteen in the pattern. The value 14 is located at position one in the pattern. The value at position number one hundred and one in the text is 39. The value located at position eleven in the pattern is 13. In the pattern, position twelve holds the value 8. At the text position ten, the value is 126. Position one in the text holds the value 23. The value at position two in the given pattern is 4. The value located at position one hundred and two in the text is 114. The pattern is a permutation of numbers of length fourteen. The value located at position one hundred and five in the text is 81. The value at position number one hundred and four in the text is 95. Position three in the pattern holds the value 6.", "output": "p(1,14). p(10,3). p(11,13). p(12,8). p(13,2). p(14,10). p(2,4). p(3,6). patternlength(14). t(1,23). t(10,126). t(100,45). t(101,39). t(102,114). t(103,33). t(104,95). t(105,81).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value located at position ten in the pattern is 3. The value located at position one hundred in the text is 45. Position one hundred and three in the text holds the value 33. The value at position number thirteen in the pattern is 2. The value 10 is located at position fourteen in the pattern. The value 14 is located at position one in the pattern. The value at position number one hundred and one in the text is 39. The value located at position eleven in the pattern is 13. In the pattern, position twelve holds the value 8. At the text position ten, the value is 126. Position one in the text holds the value 23. The value at position two in the given pattern is 4. The value located at position one hundred and two in the text is 114. The pattern is a permutation of numbers of length fourteen. The value located at position one hundred and five in the text is 81. The value at position number one hundred and four in the text is 95. Position three in the pattern holds the value 6.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4550672234212921817", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position number sixteen in the pattern is 5. At the text position one hundred and five, the value is 25. Position one hundred in the text holds the value 112. At the text position one hundred and three, the value is 76. The length of the pattern is fifty. Position twelve in the pattern holds the value 23. The value at position ten in the given text is 9. The value at position number thirteen in the pattern is 24. The value 9 is located at position eleven in the pattern. The value at position number one hundred and one in the text is 96. At the pattern position fifteen, the value is 18. The value at position number fourteen in the pattern is 25. The value located at position one in the pattern is 6. At the text position one, the value is 106. Position ten in the pattern holds the value 29. At the text position one hundred and four, the value is 235. The position number one hundred and two in the text has the value 147.", "output": "p(1,6). p(10,29). p(11,9). p(12,23). p(13,24). p(14,25). p(15,18). p(16,5). patternlength(50). t(1,106). t(10,9). t(100,112). t(101,96). t(102,147). t(103,76). t(104,235). t(105,25).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position number sixteen in the pattern is 5. At the text position one hundred and five, the value is 25. Position one hundred in the text holds the value 112. At the text position one hundred and three, the value is 76. The length of the pattern is fifty. Position twelve in the pattern holds the value 23. The value at position ten in the given text is 9. The value at position number thirteen in the pattern is 24. The value 9 is located at position eleven in the pattern. The value at position number one hundred and one in the text is 96. At the pattern position fifteen, the value is 18. The value at position number fourteen in the pattern is 25. The value located at position one in the pattern is 6. At the text position one, the value is 106. Position ten in the pattern holds the value 29. At the text position one hundred and four, the value is 235. The position number one hundred and two in the text has the value 147.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8360588635530051099", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position ten, the value is 9. Position ten in the pattern holds the value 10. The pattern is a permutation of numbers of length ten. In the pattern, position four holds the value 6. Position eleven in the text holds the value 25. At the pattern position three, the value is 2. Position thirteen in the text holds the value 15. Position six in the pattern holds the value 7. The value located at position five in the pattern is 8. The value located at position one in the text is 48. The position number seven in the pattern has the value 1. At the text position fifteen, the value is 20. Position fourteen in the text holds the value 31. The value at position one in the given pattern is 5. The position number sixteen in the text has the value 32. The value at position twelve in the given text is 18. The value located at position two in the pattern is 3.", "output": "p(1,5). p(10,10). p(2,3). p(3,2). p(4,6). p(5,8). p(6,7). p(7,1). patternlength(10). t(1,48). t(10,9). t(11,25). t(12,18). t(13,15). t(14,31). t(15,20). t(16,32).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position ten, the value is 9. Position ten in the pattern holds the value 10. The pattern is a permutation of numbers of length ten. In the pattern, position four holds the value 6. Position eleven in the text holds the value 25. At the pattern position three, the value is 2. Position thirteen in the text holds the value 15. Position six in the pattern holds the value 7. The value located at position five in the pattern is 8. The value located at position one in the text is 48. The position number seven in the pattern has the value 1. At the text position fifteen, the value is 20. Position fourteen in the text holds the value 31. The value at position one in the given pattern is 5. The position number sixteen in the text has the value 32. The value at position twelve in the given text is 18. The value located at position two in the pattern is 3.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3193776266600977988", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "Position twelve in the pattern holds the value 19. In the pattern, position fifteen holds the value 5. The value at position eleven in the given pattern is 7. The value 20 is located at position sixteen in the pattern. Position one hundred in the text holds the value 95. The value at position one hundred and two in the given text is 7. The value at position one in the given text is 20. Position one hundred and one in the text holds the value 72. At the text position one hundred and three, the value is 105. The value 8 is located at position thirteen in the pattern. The length of the pattern is twenty-four. Position fourteen in the pattern holds the value 23. The value at position number ten in the text is 27. The value at position one hundred and four in the given text is 107. The value 14 is located at position ten in the pattern. The value 10 is located at position one in the pattern. At the text position one hundred and five, the value is 89.", "output": "p(1,10). p(10,14). p(11,7). p(12,19). p(13,8). p(14,23). p(15,5). p(16,20). patternlength(24). t(1,20). t(10,27). t(100,95). t(101,72). t(102,7). t(103,105). t(104,107). t(105,89).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```Position twelve in the pattern holds the value 19. In the pattern, position fifteen holds the value 5. The value at position eleven in the given pattern is 7. The value 20 is located at position sixteen in the pattern. Position one hundred in the text holds the value 95. The value at position one hundred and two in the given text is 7. The value at position one in the given text is 20. Position one hundred and one in the text holds the value 72. At the text position one hundred and three, the value is 105. The value 8 is located at position thirteen in the pattern. The length of the pattern is twenty-four. Position fourteen in the pattern holds the value 23. The value at position number ten in the text is 27. The value at position one hundred and four in the given text is 107. The value 14 is located at position ten in the pattern. The value 10 is located at position one in the pattern. At the text position one hundred and five, the value is 89.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1477260724423895834", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "Position one in the text holds the value 110. The value located at position sixteen in the pattern is 8. At the text position one hundred and one, the value is 129. The value at position fifteen in the given pattern is 25. The value at position number twelve in the pattern is 12. The value at position number thirteen in the pattern is 32. The position number one in the pattern has the value 13. The value located at position one hundred in the text is 61. At the text position one hundred and five, the value is 115. The position number fourteen in the pattern has the value 23. The value at position number ten in the text is 41. At the text position one hundred and four, the value is 23. The value 39 is located at position eleven in the pattern. The position number one hundred and three in the text has the value 137. At the text position one hundred and two, the value is 58. The value at position ten in the given pattern is 2. The length of the pattern is forty-two.", "output": "p(1,13). p(10,2). p(11,39). p(12,12). p(13,32). p(14,23). p(15,25). p(16,8). patternlength(42). t(1,110). t(10,41). t(100,61). t(101,129). t(102,58). t(103,137). t(104,23). t(105,115).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```Position one in the text holds the value 110. The value located at position sixteen in the pattern is 8. At the text position one hundred and one, the value is 129. The value at position fifteen in the given pattern is 25. The value at position number twelve in the pattern is 12. The value at position number thirteen in the pattern is 32. The position number one in the pattern has the value 13. The value located at position one hundred in the text is 61. At the text position one hundred and five, the value is 115. The position number fourteen in the pattern has the value 23. The value at position number ten in the text is 41. At the text position one hundred and four, the value is 23. The value 39 is located at position eleven in the pattern. The position number one hundred and three in the text has the value 137. At the text position one hundred and two, the value is 58. The value at position ten in the given pattern is 2. The length of the pattern is forty-two.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5523983859907753903", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number fifteen in the pattern has the value 74. The value at position number one in the text is 46. The pattern is a permutation of numbers of length one hundred. In the pattern, position one holds the value 50. The value located at position eleven in the pattern is 44. The position number thirteen in the pattern has the value 10. The value at position number fourteen in the pattern is 49. The value at position one hundred in the given pattern is 65. The position number one hundred and two in the text has the value 160. The value at position ten in the given text is 38. The value located at position one hundred in the text is 61. The position number twelve in the pattern has the value 97. At the text position one hundred and one, the value is 179. The value at position one hundred and four in the given text is 35. The value at position ten in the given pattern is 88. The value at position number one hundred and five in the text is 183. The position number one hundred and three in the text has the value 176.", "output": "p(1,50). p(10,88). p(100,65). p(11,44). p(12,97). p(13,10). p(14,49). p(15,74). patternlength(100). t(1,46). t(10,38). t(100,61). t(101,179). t(102,160). t(103,176). t(104,35). t(105,183).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number fifteen in the pattern has the value 74. The value at position number one in the text is 46. The pattern is a permutation of numbers of length one hundred. In the pattern, position one holds the value 50. The value located at position eleven in the pattern is 44. The position number thirteen in the pattern has the value 10. The value at position number fourteen in the pattern is 49. The value at position one hundred in the given pattern is 65. The position number one hundred and two in the text has the value 160. The value at position ten in the given text is 38. The value located at position one hundred in the text is 61. The position number twelve in the pattern has the value 97. At the text position one hundred and one, the value is 179. The value at position one hundred and four in the given text is 35. The value at position ten in the given pattern is 88. The value at position number one hundred and five in the text is 183. The position number one hundred and three in the text has the value 176.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3437429858959205091", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number ten in the text has the value 19. The value at position seven in the given pattern is 7. The value 5 is located at position two in the pattern. In the pattern, position six holds the value 2. Position sixteen in the text holds the value 11. At the pattern position three, the value is 1. Position thirteen in the text holds the value 10. The value at position number fifteen in the text is 6. The value located at position eleven in the text is 5. The value at position five in the given pattern is 3. The value located at position one in the pattern is 8. The position number fourteen in the text has the value 3. The position number twelve in the text has the value 8. The position number eight in the pattern has the value 6. The value at position number four in the pattern is 4. The pattern is a permutation of numbers of length eight. The value at position one in the given text is 16.", "output": "p(1,8). p(2,5). p(3,1). p(4,4). p(5,3). p(6,2). p(7,7). p(8,6). patternlength(8). t(1,16). t(10,19). t(11,5). t(12,8). t(13,10). t(14,3). t(15,6). t(16,11).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number ten in the text has the value 19. The value at position seven in the given pattern is 7. The value 5 is located at position two in the pattern. In the pattern, position six holds the value 2. Position sixteen in the text holds the value 11. At the pattern position three, the value is 1. Position thirteen in the text holds the value 10. The value at position number fifteen in the text is 6. The value located at position eleven in the text is 5. The value at position five in the given pattern is 3. The value located at position one in the pattern is 8. The position number fourteen in the text has the value 3. The position number twelve in the text has the value 8. The position number eight in the pattern has the value 6. The value at position number four in the pattern is 4. The pattern is a permutation of numbers of length eight. The value at position one in the given text is 16.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "704039452828515425", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number one hundred and four in the text has the value 108. Position one hundred and one in the text holds the value 56. The value at position number ten in the text is 28. At the text position one hundred and five, the value is 57. The value located at position one hundred and two in the text is 21. The position number sixteen in the pattern has the value 10. The length of the pattern is twenty-eight. The position number one hundred and three in the text has the value 140. In the pattern, position eleven holds the value 11. The value 12 is located at position twelve in the pattern. The value at position fifteen in the given pattern is 5. The position number one hundred in the text has the value 5. The value at position number thirteen in the pattern is 14. The value 28 is located at position fourteen in the pattern. The value 6 is located at position one in the pattern. Position ten in the pattern holds the value 9. At the text position one, the value is 39.", "output": "p(1,6). p(10,9). p(11,11). p(12,12). p(13,14). p(14,28). p(15,5). p(16,10). patternlength(28). t(1,39). t(10,28). t(100,5). t(101,56). t(102,21). t(103,140). t(104,108). t(105,57).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number one hundred and four in the text has the value 108. Position one hundred and one in the text holds the value 56. The value at position number ten in the text is 28. At the text position one hundred and five, the value is 57. The value located at position one hundred and two in the text is 21. The position number sixteen in the pattern has the value 10. The length of the pattern is twenty-eight. The position number one hundred and three in the text has the value 140. In the pattern, position eleven holds the value 11. The value 12 is located at position twelve in the pattern. The value at position fifteen in the given pattern is 5. The position number one hundred in the text has the value 5. The value at position number thirteen in the pattern is 14. The value 28 is located at position fourteen in the pattern. The value 6 is located at position one in the pattern. Position ten in the pattern holds the value 9. At the text position one, the value is 39.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4406141506476677451", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number one in the text has the value 29. The value located at position fifteen in the text is 85. The position number sixteen in the text has the value 70. The value at position ten in the given text is 78. The value at position number eleven in the pattern is 8. At the pattern position ten, the value is 4. Position thirteen in the text holds the value 21. The value at position eleven in the given text is 57. The value located at position twelve in the text is 90. Position fourteen in the pattern holds the value 17. Position one in the pattern holds the value 7. The pattern is a permutation of numbers of length eighteen. In the pattern, position twelve holds the value 1. The value at position number fourteen in the text is 16. The position number thirteen in the pattern has the value 11. The value 3 is located at position fifteen in the pattern. In the pattern, position sixteen holds the value 9.", "output": "p(1,7). p(10,4). p(11,8). p(12,1). p(13,11). p(14,17). p(15,3). p(16,9). patternlength(18). t(1,29). t(10,78). t(11,57). t(12,90). t(13,21). t(14,16). t(15,85). t(16,70).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number one in the text has the value 29. The value located at position fifteen in the text is 85. The position number sixteen in the text has the value 70. The value at position ten in the given text is 78. The value at position number eleven in the pattern is 8. At the pattern position ten, the value is 4. Position thirteen in the text holds the value 21. The value at position eleven in the given text is 57. The value located at position twelve in the text is 90. Position fourteen in the pattern holds the value 17. Position one in the pattern holds the value 7. The pattern is a permutation of numbers of length eighteen. In the pattern, position twelve holds the value 1. The value at position number fourteen in the text is 16. The position number thirteen in the pattern has the value 11. The value 3 is located at position fifteen in the pattern. In the pattern, position sixteen holds the value 9.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1893835595734455867", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The position number one hundred in the text has the value 226. Position one hundred and three in the text holds the value 189. Position one hundred and five in the text holds the value 175. The position number one in the text has the value 158. The value at position number one hundred and four in the pattern is 42. Position one hundred and two in the pattern holds the value 53. At the pattern position one hundred and one, the value is 75. The value 25 is located at position one hundred in the pattern. The value located at position one hundred and three in the pattern is 114. At the text position one hundred and four, the value is 109. At the pattern position one hundred and five, the value is 124. The length of the pattern is one hundred and twenty-five. The value at position ten in the given pattern is 109. The position number ten in the text has the value 102. The position number one hundred and one in the text has the value 55. In the pattern, position one holds the value 15. At the text position one hundred and two, the value is 201.", "output": "p(1,15). p(10,109). p(100,25). p(101,75). p(102,53). p(103,114). p(104,42). p(105,124). patternlength(125). t(1,158). t(10,102). t(100,226). t(101,55). t(102,201). t(103,189). t(104,109). t(105,175).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The position number one hundred in the text has the value 226. Position one hundred and three in the text holds the value 189. Position one hundred and five in the text holds the value 175. The position number one in the text has the value 158. The value at position number one hundred and four in the pattern is 42. Position one hundred and two in the pattern holds the value 53. At the pattern position one hundred and one, the value is 75. The value 25 is located at position one hundred in the pattern. The value located at position one hundred and three in the pattern is 114. At the text position one hundred and four, the value is 109. At the pattern position one hundred and five, the value is 124. The length of the pattern is one hundred and twenty-five. The value at position ten in the given pattern is 109. The position number ten in the text has the value 102. The position number one hundred and one in the text has the value 55. In the pattern, position one holds the value 15. At the text position one hundred and two, the value is 201.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7427332400657028525", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value located at position fourteen in the pattern is 7. The value at position number fifteen in the pattern is 3. Position one hundred and five in the text holds the value 64. The value located at position one hundred and one in the text is 67. The value at position one in the given pattern is 34. The position number sixteen in the pattern has the value 28. Position eleven in the pattern holds the value 23. The value located at position twelve in the pattern is 25. The position number one hundred and four in the text has the value 17. The value at position number one hundred and three in the text is 56. The value located at position one hundred in the text is 80. The pattern is a permutation of numbers of length fifty. The value at position one in the given text is 116. The value located at position one hundred and two in the text is 81. The value at position thirteen in the given pattern is 8. Position ten in the text holds the value 126. The value located at position ten in the pattern is 21.", "output": "p(1,34). p(10,21). p(11,23). p(12,25). p(13,8). p(14,7). p(15,3). p(16,28). patternlength(50). t(1,116). t(10,126). t(100,80). t(101,67). t(102,81). t(103,56). t(104,17). t(105,64).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value located at position fourteen in the pattern is 7. The value at position number fifteen in the pattern is 3. Position one hundred and five in the text holds the value 64. The value located at position one hundred and one in the text is 67. The value at position one in the given pattern is 34. The position number sixteen in the pattern has the value 28. Position eleven in the pattern holds the value 23. The value located at position twelve in the pattern is 25. The position number one hundred and four in the text has the value 17. The value at position number one hundred and three in the text is 56. The value located at position one hundred in the text is 80. The pattern is a permutation of numbers of length fifty. The value at position one in the given text is 116. The value located at position one hundred and two in the text is 81. The value at position thirteen in the given pattern is 8. Position ten in the text holds the value 126. The value located at position ten in the pattern is 21.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3917925023285560586", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position one hundred and five in the given text is 59. Position one hundred and two in the pattern holds the value 121. The value at position one hundred and three in the given text is 271. Position one in the pattern holds the value 18. The position number one hundred and five in the pattern has the value 50. At the pattern position one hundred and three, the value is 146. The value 141 is located at position ten in the pattern. Position one hundred and four in the pattern holds the value 5. Position one hundred and one in the text holds the value 113. The position number one in the text has the value 262. The value at position number one hundred and one in the pattern is 171. Position one hundred and two in the text holds the value 248. The pattern is a permutation of numbers of length one hundred and seventy-five. The value at position one hundred in the given pattern is 143. At the text position one hundred, the value is 186. The value at position one hundred and four in the given text is 295. At the text position ten, the value is 284.", "output": "p(1,18). p(10,141). p(100,143). p(101,171). p(102,121). p(103,146). p(104,5). p(105,50). patternlength(175). t(1,262). t(10,284). t(100,186). t(101,113). t(102,248). t(103,271). t(104,295). t(105,59).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position one hundred and five in the given text is 59. Position one hundred and two in the pattern holds the value 121. The value at position one hundred and three in the given text is 271. Position one in the pattern holds the value 18. The position number one hundred and five in the pattern has the value 50. At the pattern position one hundred and three, the value is 146. The value 141 is located at position ten in the pattern. Position one hundred and four in the pattern holds the value 5. Position one hundred and one in the text holds the value 113. The position number one in the text has the value 262. The value at position number one hundred and one in the pattern is 171. Position one hundred and two in the text holds the value 248. The pattern is a permutation of numbers of length one hundred and seventy-five. The value at position one hundred in the given pattern is 143. At the text position one hundred, the value is 186. The value at position one hundred and four in the given text is 295. At the text position ten, the value is 284.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3152536631421767873", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position number fifteen in the pattern is 9. Position eleven in the pattern holds the value 35. Position one in the pattern holds the value 10. The value located at position one hundred and five in the text is 132. The value located at position sixteen in the pattern is 47. The position number ten in the pattern has the value 1. The pattern is a permutation of numbers of length fifty. The value at position ten in the given text is 72. The position number one hundred and four in the text has the value 178. The value at position thirteen in the given pattern is 14. The value at position number twelve in the pattern is 22. The position number one hundred and two in the text has the value 58. The value located at position one hundred and one in the text is 52. The value at position one hundred in the given text is 32. At the pattern position fourteen, the value is 34. Position one hundred and three in the text holds the value 84. At the text position one, the value is 219.", "output": "p(1,10). p(10,1). p(11,35). p(12,22). p(13,14). p(14,34). p(15,9). p(16,47). patternlength(50). t(1,219). t(10,72). t(100,32). t(101,52). t(102,58). t(103,84). t(104,178). t(105,132).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position number fifteen in the pattern is 9. Position eleven in the pattern holds the value 35. Position one in the pattern holds the value 10. The value located at position one hundred and five in the text is 132. The value located at position sixteen in the pattern is 47. The position number ten in the pattern has the value 1. The pattern is a permutation of numbers of length fifty. The value at position ten in the given text is 72. The position number one hundred and four in the text has the value 178. The value at position thirteen in the given pattern is 14. The value at position number twelve in the pattern is 22. The position number one hundred and two in the text has the value 58. The value located at position one hundred and one in the text is 52. The value at position one hundred in the given text is 32. At the pattern position fourteen, the value is 34. Position one hundred and three in the text holds the value 84. At the text position one, the value is 219.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1998985253479611197", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "Position fifteen in the pattern holds the value 27. Position ten in the text holds the value 140. At the pattern position eleven, the value is 50. The value at position number one hundred and three in the text is 37. The value at position one hundred and two in the given text is 46. Position thirteen in the pattern holds the value 22. In the pattern, position sixteen holds the value 25. The position number one hundred and five in the text has the value 22. The value located at position one hundred and one in the text is 69. The length of the pattern is fifty-six. The position number ten in the pattern has the value 54. The value at position one in the given text is 3. Position twelve in the pattern holds the value 18. The value at position number one hundred and four in the text is 34. At the pattern position one, the value is 41. Position one hundred in the text holds the value 32. The value at position fourteen in the given pattern is 13.", "output": "p(1,41). p(10,54). p(11,50). p(12,18). p(13,22). p(14,13). p(15,27). p(16,25). patternlength(56). t(1,3). t(10,140). t(100,32). t(101,69). t(102,46). t(103,37). t(104,34). t(105,22).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```Position fifteen in the pattern holds the value 27. Position ten in the text holds the value 140. At the pattern position eleven, the value is 50. The value at position number one hundred and three in the text is 37. The value at position one hundred and two in the given text is 46. Position thirteen in the pattern holds the value 22. In the pattern, position sixteen holds the value 25. The position number one hundred and five in the text has the value 22. The value located at position one hundred and one in the text is 69. The length of the pattern is fifty-six. The position number ten in the pattern has the value 54. The value at position one in the given text is 3. Position twelve in the pattern holds the value 18. The value at position number one hundred and four in the text is 34. At the pattern position one, the value is 41. Position one hundred in the text holds the value 32. The value at position fourteen in the given pattern is 13.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6926662522465115027", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "Position one in the text holds the value 74. The value located at position one hundred and four in the text is 35. The value 26 is located at position one hundred and four in the pattern. The pattern is a permutation of numbers of length one hundred and forty. Position one hundred and five in the text holds the value 124. The position number one hundred in the pattern has the value 47. The position number one hundred and two in the pattern has the value 38. The value located at position one hundred and two in the text is 260. Position one in the pattern holds the value 70. The value at position number one hundred and one in the pattern is 85. The value located at position one hundred and three in the text is 267. The value at position one hundred and five in the given pattern is 17. The value located at position one hundred in the text is 159. The value at position number one hundred and three in the pattern is 106. The value at position one hundred and one in the given text is 146. The value 29 is located at position ten in the pattern. The position number ten in the text has the value 174.", "output": "p(1,70). p(10,29). p(100,47). p(101,85). p(102,38). p(103,106). p(104,26). p(105,17). patternlength(140). t(1,74). t(10,174). t(100,159). t(101,146). t(102,260). t(103,267). t(104,35). t(105,124).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```Position one in the text holds the value 74. The value located at position one hundred and four in the text is 35. The value 26 is located at position one hundred and four in the pattern. The pattern is a permutation of numbers of length one hundred and forty. Position one hundred and five in the text holds the value 124. The position number one hundred in the pattern has the value 47. The position number one hundred and two in the pattern has the value 38. The value located at position one hundred and two in the text is 260. Position one in the pattern holds the value 70. The value at position number one hundred and one in the pattern is 85. The value located at position one hundred and three in the text is 267. The value at position one hundred and five in the given pattern is 17. The value located at position one hundred in the text is 159. The value at position number one hundred and three in the pattern is 106. The value at position one hundred and one in the given text is 146. The value 29 is located at position ten in the pattern. The position number ten in the text has the value 174.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3812536176680037741", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "The value at position one hundred and four in the given text is 118. The position number eleven in the pattern has the value 22. The value at position number one hundred and five in the text is 122. The value at position number one in the text is 60. The position number twelve in the pattern has the value 1. The value at position one hundred and one in the given text is 81. At the text position one hundred, the value is 185. The pattern is a permutation of numbers of length forty. Position fourteen in the pattern holds the value 10. The value at position number one hundred and three in the text is 161. The value at position thirteen in the given pattern is 18. The value at position one hundred and two in the given text is 61. In the pattern, position ten holds the value 12. Position fifteen in the pattern holds the value 2. In the pattern, position one holds the value 15. At the pattern position sixteen, the value is 33. Position ten in the text holds the value 110.", "output": "p(1,15). p(10,12). p(11,22). p(12,1). p(13,18). p(14,10). p(15,2). p(16,33). patternlength(40). t(1,60). t(10,110). t(100,185). t(101,81). t(102,61). t(103,161). t(104,118). t(105,122).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```The value at position one hundred and four in the given text is 118. The position number eleven in the pattern has the value 22. The value at position number one hundred and five in the text is 122. The value at position number one in the text is 60. The position number twelve in the pattern has the value 1. The value at position one hundred and one in the given text is 81. At the text position one hundred, the value is 185. The pattern is a permutation of numbers of length forty. Position fourteen in the pattern holds the value 10. The value at position number one hundred and three in the text is 161. The value at position thirteen in the given pattern is 18. The value at position one hundred and two in the given text is 61. In the pattern, position ten holds the value 12. Position fifteen in the pattern holds the value 2. In the pattern, position one holds the value 15. At the pattern position sixteen, the value is 33. Position ten in the text holds the value 110.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6738368384952438691", "problem_id": "35", "problem_name": "Permutation Pattern Matching", "description": "Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)", "format": "The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.", "text": "At the text position one hundred and four, the value is 73. Position one hundred and three in the pattern holds the value 120. The value located at position one hundred and one in the text is 164. The value located at position one hundred and three in the text is 198. The position number one hundred in the text has the value 2. The value 33 is located at position one hundred in the pattern. The value at position one hundred and two in the given pattern is 39. Position one hundred and two in the text holds the value 104. Position one in the pattern holds the value 89. At the pattern position one hundred and five, the value is 54. The value at position one hundred and four in the given pattern is 61. The value at position number one in the text is 11. The value at position one hundred and five in the given text is 242. The length of the pattern is one hundred and twenty-five. The value at position number ten in the pattern is 98. The value at position ten in the given text is 84. The value at position number one hundred and one in the pattern is 92.", "output": "p(1,89). p(10,98). p(100,33). p(101,92). p(102,39). p(103,120). p(104,61). p(105,54). patternlength(125). t(1,11). t(10,84). t(100,2). t(101,164). t(102,104). t(103,198). t(104,73). t(105,242).", "prompt": "Given the following problem description between triple backtips: \n ```Permutation Pattern Matching (PPM) is an NP-complete pattern matching problem. Given a permutation T (the text) and a permutation P (the pattern) the question is whether there exists a matching of P into T. A matching is a subsequence of T that has the same relative order as P. For example the permutation T = 53142 (written in one-line representation) contains the pattern 231, since the subsequence 342 of T is order-isomorphic to 231 (i.e. the smallest element is in the third position, the second smallest in the first position and the largest in the second position).\nNote that:\n1. Both text and pattern consist only of numbers.\n2. A text of length m is a permutation on  {1,...,m} , i.e., every element appears exactly once.\n3. A pattern of length n is a permutation on  {1,...,n} . Hence 241 is not a pattern. But note that 241 might be matching! (For example: 241 is a matching from the pattern 231 into the text 32451.)```\nGiven the following specification for the predicates format: \n```The permutations T and P are encoded as binary predicates, e.g. T=132 is encoded as t(1,1). t(2,3). t(3,2). Additionally, patternlength/1 describes the length of the pattern P.```\nExtract the datalog facts from this text: \n```At the text position one hundred and four, the value is 73. Position one hundred and three in the pattern holds the value 120. The value located at position one hundred and one in the text is 164. The value located at position one hundred and three in the text is 198. The position number one hundred in the text has the value 2. The value 33 is located at position one hundred in the pattern. The value at position one hundred and two in the given pattern is 39. Position one hundred and two in the text holds the value 104. Position one in the pattern holds the value 89. At the pattern position one hundred and five, the value is 54. The value at position one hundred and four in the given pattern is 61. The value at position number one in the text is 11. The value at position one hundred and five in the given text is 242. The length of the pattern is one hundred and twenty-five. The value at position number ten in the pattern is 98. The value at position ten in the given text is 84. The value at position number one hundred and one in the pattern is 92.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1371395369103803666", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The board is a square of 8x8. The objective is for the robot blue to reach (2, 4). The red robot starts at coordinates (1, 1). There is a barrier between position (10,8) and position (9,8) heading west. The location (1,16) is the starting position for the robot blue. The number of moves in the plan is must be seventeen. A barrier stands between positions (10,9) and (9,9), heading west. A barrier exists between position (11,12) and position (12,12) in the direction of east. Position (10,1) and position (11,1) are divided by a barrier heading east. A green robot starts at position (16, 1). Position (10,14) and position (10,15) are divided by a barrier heading south. A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. The robot yellow is positioned at (16, 16) at the beginning. A barrier exists between position (10,15) and position (11,15) in the direction of east. A barrier stands between positions (1,6) and (1,7), heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,2,4).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The board is a square of 8x8. The objective is for the robot blue to reach (2, 4). The red robot starts at coordinates (1, 1). There is a barrier between position (10,8) and position (9,8) heading west. The location (1,16) is the starting position for the robot blue. The number of moves in the plan is must be seventeen. A barrier stands between positions (10,9) and (9,9), heading west. A barrier exists between position (11,12) and position (12,12) in the direction of east. Position (10,1) and position (11,1) are divided by a barrier heading east. A green robot starts at position (16, 1). Position (10,14) and position (10,15) are divided by a barrier heading south. A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. The robot yellow is positioned at (16, 16) at the beginning. A barrier exists between position (10,15) and position (11,15) in the direction of east. A barrier stands between positions (1,6) and (1,7), heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8400797146344002245", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier exists between position (1,6) and position (1,7) in the direction of south. The objective is for the robot green to reach (6, 5). The location (1,16) is the starting position for the robot blue. The green robot starts at coordinates (16, 1). A yellow robot starts at position (16, 16). Position (10,1) and position (11,1) are divided by a barrier heading east. A red robot is initially at position (1, 1). The board is a square of 8x8. A barrier exists between position (10,9) and position (9,9) in the direction of west. A barrier stands between positions (11,12) and (12,12), heading east. There is a barrier between position (10,15) and position (11,15) heading east. Position (10,14) and position (10,15) are divided by a barrier heading south. There must be fourteen moves in the plan. Position (10,8) and position (9,8) are divided by a barrier heading west. A barrier stands between positions (1,12) and (1,13), heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(14). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,6,5).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier exists between position (1,6) and position (1,7) in the direction of south. The objective is for the robot green to reach (6, 5). The location (1,16) is the starting position for the robot blue. The green robot starts at coordinates (16, 1). A yellow robot starts at position (16, 16). Position (10,1) and position (11,1) are divided by a barrier heading east. A red robot is initially at position (1, 1). The board is a square of 8x8. A barrier exists between position (10,9) and position (9,9) in the direction of west. A barrier stands between positions (11,12) and (12,12), heading east. There is a barrier between position (10,15) and position (11,15) heading east. Position (10,14) and position (10,15) are divided by a barrier heading south. There must be fourteen moves in the plan. Position (10,8) and position (9,8) are divided by a barrier heading west. A barrier stands between positions (1,12) and (1,13), heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1861746667614746028", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The location (1,16) is the starting position for the robot blue. The yellow robot should be guided to position (10, 12). A barrier stands between positions (10,15) and (11,15), heading east. There is a barrier between position (10,8) and position (9,8) heading west. The location (16,16) is the starting position for the robot yellow. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east. The total number of moves in the plan should be seventeen. A green robot starts at position (16, 1). A barrier exists between position (10,9) and position (9,9) in the direction of west. Position (11,12) and position (12,12) are divided by a barrier heading east. Position (10,14) and position (10,15) are divided by a barrier heading south. The red robot starts at coordinates (1, 1). The board is a square of 8x8. A barrier stands between positions (1,12) and (1,13), heading south. There is a barrier between position (1,6) and position (1,7) heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,10,12).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The location (1,16) is the starting position for the robot blue. The yellow robot should be guided to position (10, 12). A barrier stands between positions (10,15) and (11,15), heading east. There is a barrier between position (10,8) and position (9,8) heading west. The location (16,16) is the starting position for the robot yellow. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east. The total number of moves in the plan should be seventeen. A green robot starts at position (16, 1). A barrier exists between position (10,9) and position (9,9) in the direction of west. Position (11,12) and position (12,12) are divided by a barrier heading east. Position (10,14) and position (10,15) are divided by a barrier heading south. The red robot starts at coordinates (1, 1). The board is a square of 8x8. A barrier stands between positions (1,12) and (1,13), heading south. There is a barrier between position (1,6) and position (1,7) heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7516875454270137381", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "Position (1,12) and position (1,13) are divided by a barrier heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. A barrier blocks the way between position (10,9) and position (9,9) in the direction of west. A barrier exists between position (10,15) and position (11,15) in the direction of east. A green robot is initially at position (16, 1). The location (1,1) is the starting position for the robot red. A barrier stands between positions (10,1) and (11,1), heading east. Robot blue's goal is to reach position (4, 14). A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The board is a square of 8x8. A blue robot starts at position (1, 16). A barrier exists between position (10,8) and position (9,8) in the direction of west. The location (16,16) is the starting position for the robot yellow. There must be sixteen moves in the plan. A barrier exists between position (1,6) and position (1,7) in the direction of south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(16). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,4,14).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```Position (1,12) and position (1,13) are divided by a barrier heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. A barrier blocks the way between position (10,9) and position (9,9) in the direction of west. A barrier exists between position (10,15) and position (11,15) in the direction of east. A green robot is initially at position (16, 1). The location (1,1) is the starting position for the robot red. A barrier stands between positions (10,1) and (11,1), heading east. Robot blue's goal is to reach position (4, 14). A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The board is a square of 8x8. A blue robot starts at position (1, 16). A barrier exists between position (10,8) and position (9,8) in the direction of west. The location (16,16) is the starting position for the robot yellow. There must be sixteen moves in the plan. A barrier exists between position (1,6) and position (1,7) in the direction of south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8345341066330687942", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier exists between position (10,1) and position (11,1) in the direction of east. Position (10,9) and position (9,9) are divided by a barrier heading west. The location (1,1) is the starting position for the robot red. A barrier exists between position (1,12) and position (1,13) in the direction of south. A yellow robot is initially at position (16, 16). The number of moves in the plan is must be seventeen. A barrier exists between position (10,8) and position (9,8) in the direction of west. A barrier exists between position (1,6) and position (1,7) in the direction of south. A barrier exists between position (10,14) and position (10,15) in the direction of south. The location (16,1) is the starting position for the robot green. A blue robot starts at position (1, 16). The board is a square of 8x8. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier exists between position (10,15) and position (11,15) in the direction of east. The objective is for the robot red to reach (9, 15).", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,9,15).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier exists between position (10,1) and position (11,1) in the direction of east. Position (10,9) and position (9,9) are divided by a barrier heading west. The location (1,1) is the starting position for the robot red. A barrier exists between position (1,12) and position (1,13) in the direction of south. A yellow robot is initially at position (16, 16). The number of moves in the plan is must be seventeen. A barrier exists between position (10,8) and position (9,8) in the direction of west. A barrier exists between position (1,6) and position (1,7) in the direction of south. A barrier exists between position (10,14) and position (10,15) in the direction of south. The location (16,1) is the starting position for the robot green. A blue robot starts at position (1, 16). The board is a square of 8x8. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier exists between position (10,15) and position (11,15) in the direction of east. The objective is for the robot red to reach (9, 15).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6177361592896914113", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The robot yellow is positioned at (16, 16) at the beginning. There is a barrier between position (10,8) and position (9,8) heading west. The red robot starts at coordinates (1, 1). A green robot starts at position (16, 1). A barrier stands between positions (10,14) and (10,15), heading south. Position (1,12) and position (1,13) are divided by a barrier heading south. A plan consisting of seventeen moves is required. The position (3,13) is the goal that must be reached by the robot yellow. The board is a square of 8x8. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier exists between position (10,1) and position (11,1) in the direction of east. Position (10,15) and position (11,15) are divided by a barrier heading east. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. A barrier stands between positions (10,9) and (9,9), heading west. A blue robot starts at position (1, 16).", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,3,13).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The robot yellow is positioned at (16, 16) at the beginning. There is a barrier between position (10,8) and position (9,8) heading west. The red robot starts at coordinates (1, 1). A green robot starts at position (16, 1). A barrier stands between positions (10,14) and (10,15), heading south. Position (1,12) and position (1,13) are divided by a barrier heading south. A plan consisting of seventeen moves is required. The position (3,13) is the goal that must be reached by the robot yellow. The board is a square of 8x8. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier exists between position (10,1) and position (11,1) in the direction of east. Position (10,15) and position (11,15) are divided by a barrier heading east. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. A barrier stands between positions (10,9) and (9,9), heading west. A blue robot starts at position (1, 16).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4623863072720128107", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A blue robot is initially at position (1, 16). There must be fifteen moves in the plan. The robot red is positioned at (1, 1) at the beginning. There is a barrier between position (1,6) and position (1,7) heading south. A green robot starts at position (16, 1). Position (10,9) and position (9,9) are divided by a barrier heading west. Position (1,12) and position (1,13) are divided by a barrier heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. The location (16,16) is the starting position for the robot yellow. Position (10,1) and position (11,1) are divided by a barrier heading east. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The goal is for the green robot to move to position (4, 14). The board is a square of 8x8.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(15). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,4,14).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A blue robot is initially at position (1, 16). There must be fifteen moves in the plan. The robot red is positioned at (1, 1) at the beginning. There is a barrier between position (1,6) and position (1,7) heading south. A green robot starts at position (16, 1). Position (10,9) and position (9,9) are divided by a barrier heading west. Position (1,12) and position (1,13) are divided by a barrier heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. The location (16,16) is the starting position for the robot yellow. Position (10,1) and position (11,1) are divided by a barrier heading east. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The goal is for the green robot to move to position (4, 14). The board is a square of 8x8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4248100631745387436", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "There is a barrier between position (10,1) and position (11,1) heading east. A barrier stands between positions (10,14) and (10,15), heading south. The location (16,16) is the starting position for the robot yellow. The board is a square of 8x8. There must be fifteen moves in the plan. A red robot starts at position (1, 1). There is a barrier between position (11,12) and position (12,12) heading east. The green robot starts at coordinates (16, 1). A barrier stands between positions (10,15) and (11,15), heading east. The blue robot starts at coordinates (1, 16). A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. A barrier exists between position (10,9) and position (9,9) in the direction of west. The red robot should be guided to position (9, 3). Position (10,8) and position (9,8) are divided by a barrier heading west. Position (1,6) and position (1,7) are divided by a barrier heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(15). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,9,3).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```There is a barrier between position (10,1) and position (11,1) heading east. A barrier stands between positions (10,14) and (10,15), heading south. The location (16,16) is the starting position for the robot yellow. The board is a square of 8x8. There must be fifteen moves in the plan. A red robot starts at position (1, 1). There is a barrier between position (11,12) and position (12,12) heading east. The green robot starts at coordinates (16, 1). A barrier stands between positions (10,15) and (11,15), heading east. The blue robot starts at coordinates (1, 16). A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. A barrier exists between position (10,9) and position (9,9) in the direction of west. The red robot should be guided to position (9, 3). Position (10,8) and position (9,8) are divided by a barrier heading west. Position (1,6) and position (1,7) are divided by a barrier heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3780720833665079421", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier stands between positions (10,15) and (11,15), heading east. There is a barrier between position (10,8) and position (9,8) heading west. There is a barrier between position (1,6) and position (1,7) heading south. The robot red is positioned at (1, 1) at the beginning. Position (10,14) and position (10,15) are divided by a barrier heading south. A yellow robot is initially at position (16, 16). The board is a square of 8x8. A barrier exists between position (10,9) and position (9,9) in the direction of west. A barrier stands between positions (11,12) and (12,12), heading east. The goal is for the green robot to move to position (14, 10). The robot green is positioned at (16, 1) at the beginning. There must be seventeen moves in the plan. A barrier stands between positions (10,1) and (11,1), heading east. There is a barrier between position (1,12) and position (1,13) heading south. A blue robot is initially at position (1, 16).", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,14,10).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier stands between positions (10,15) and (11,15), heading east. There is a barrier between position (10,8) and position (9,8) heading west. There is a barrier between position (1,6) and position (1,7) heading south. The robot red is positioned at (1, 1) at the beginning. Position (10,14) and position (10,15) are divided by a barrier heading south. A yellow robot is initially at position (16, 16). The board is a square of 8x8. A barrier exists between position (10,9) and position (9,9) in the direction of west. A barrier stands between positions (11,12) and (12,12), heading east. The goal is for the green robot to move to position (14, 10). The robot green is positioned at (16, 1) at the beginning. There must be seventeen moves in the plan. A barrier stands between positions (10,1) and (11,1), heading east. There is a barrier between position (1,12) and position (1,13) heading south. A blue robot is initially at position (1, 16).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3134105057202274246", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "There is a barrier between position (1,12) and position (1,13) heading south. There is a barrier between position (10,8) and position (9,8) heading west. A barrier stands between positions (1,6) and (1,7), heading south. The board is a square of 8x8. The location (1,1) is the starting position for the robot red. Position (10,15) and position (11,15) are divided by a barrier heading east. A green robot starts at position (16, 1). The number of moves in the plan is must be twenty-two. The location (16,16) is the starting position for the robot yellow. A blue robot is initially at position (1, 16). Position (10,9) and position (9,9) are divided by a barrier heading west. Robot red's goal is to reach position (12, 10). A barrier stands between positions (10,14) and (10,15), heading south. A barrier stands between positions (11,12) and (12,12), heading east. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(22). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,12,10).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```There is a barrier between position (1,12) and position (1,13) heading south. There is a barrier between position (10,8) and position (9,8) heading west. A barrier stands between positions (1,6) and (1,7), heading south. The board is a square of 8x8. The location (1,1) is the starting position for the robot red. Position (10,15) and position (11,15) are divided by a barrier heading east. A green robot starts at position (16, 1). The number of moves in the plan is must be twenty-two. The location (16,16) is the starting position for the robot yellow. A blue robot is initially at position (1, 16). Position (10,9) and position (9,9) are divided by a barrier heading west. Robot red's goal is to reach position (12, 10). A barrier stands between positions (10,14) and (10,15), heading south. A barrier stands between positions (11,12) and (12,12), heading east. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "889420283489260984", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The blue robot starts at coordinates (1, 16). There is a barrier between position (10,1) and position (11,1) heading east. The yellow robot starts at coordinates (16, 16). Position (10,14) and position (10,15) are divided by a barrier heading south. The plan must contain eighteen moves. The location (16,1) is the starting position for the robot green. A barrier stands between positions (1,6) and (1,7), heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. The board is a square of 8x8. The goal is for the yellow robot to move to position (11, 11). A barrier exists between position (10,8) and position (9,8) in the direction of west. A red robot is initially at position (1, 1). There is a barrier between position (10,15) and position (11,15) heading east. There is a barrier between position (10,9) and position (9,9) heading west. There is a barrier between position (1,12) and position (1,13) heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(18). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,11,11).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The blue robot starts at coordinates (1, 16). There is a barrier between position (10,1) and position (11,1) heading east. The yellow robot starts at coordinates (16, 16). Position (10,14) and position (10,15) are divided by a barrier heading south. The plan must contain eighteen moves. The location (16,1) is the starting position for the robot green. A barrier stands between positions (1,6) and (1,7), heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. The board is a square of 8x8. The goal is for the yellow robot to move to position (11, 11). A barrier exists between position (10,8) and position (9,8) in the direction of west. A red robot is initially at position (1, 1). There is a barrier between position (10,15) and position (11,15) heading east. There is a barrier between position (10,9) and position (9,9) heading west. There is a barrier between position (1,12) and position (1,13) heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1290883674651660754", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier blocks the way between position (11,12) and position (12,12) in the direction of east. A barrier exists between position (10,8) and position (9,8) in the direction of west. There is a barrier between position (10,15) and position (11,15) heading east. The board is a square of 8x8. Position (10,9) and position (9,9) are divided by a barrier heading west. A red robot starts at position (1, 1). The aim is for the robot yellow to reach the coordinates (10, 11). A green robot is initially at position (16, 1). A barrier exists between position (10,1) and position (11,1) in the direction of east. The yellow robot starts at coordinates (16, 16). There is a barrier between position (1,6) and position (1,7) heading south. Position (10,14) and position (10,15) are divided by a barrier heading south. A blue robot is initially at position (1, 16). A plan consisting of nineteen moves is required. Position (1,12) and position (1,13) are divided by a barrier heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(19). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,10,11).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier blocks the way between position (11,12) and position (12,12) in the direction of east. A barrier exists between position (10,8) and position (9,8) in the direction of west. There is a barrier between position (10,15) and position (11,15) heading east. The board is a square of 8x8. Position (10,9) and position (9,9) are divided by a barrier heading west. A red robot starts at position (1, 1). The aim is for the robot yellow to reach the coordinates (10, 11). A green robot is initially at position (16, 1). A barrier exists between position (10,1) and position (11,1) in the direction of east. The yellow robot starts at coordinates (16, 16). There is a barrier between position (1,6) and position (1,7) heading south. Position (10,14) and position (10,15) are divided by a barrier heading south. A blue robot is initially at position (1, 16). A plan consisting of nineteen moves is required. Position (1,12) and position (1,13) are divided by a barrier heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "916492694102174309", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The board is a square of 8x8. Position (10,9) and position (9,9) are divided by a barrier heading west. The location (16,16) is the starting position for the robot yellow. Position (10,8) and position (9,8) are divided by a barrier heading west. A green robot starts at position (16, 1). The position (14,8) is the goal that must be reached by the robot red. A barrier stands between positions (10,1) and (11,1), heading east. A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. There is a barrier between position (10,14) and position (10,15) heading south. The robot blue is positioned at (1, 16) at the beginning. Position (11,12) and position (12,12) are divided by a barrier heading east. Position (1,6) and position (1,7) are divided by a barrier heading south. The red robot starts at coordinates (1, 1). The plan must contain eighteen moves. A barrier exists between position (10,15) and position (11,15) in the direction of east.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(18). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,14,8).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The board is a square of 8x8. Position (10,9) and position (9,9) are divided by a barrier heading west. The location (16,16) is the starting position for the robot yellow. Position (10,8) and position (9,8) are divided by a barrier heading west. A green robot starts at position (16, 1). The position (14,8) is the goal that must be reached by the robot red. A barrier stands between positions (10,1) and (11,1), heading east. A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. There is a barrier between position (10,14) and position (10,15) heading south. The robot blue is positioned at (1, 16) at the beginning. Position (11,12) and position (12,12) are divided by a barrier heading east. Position (1,6) and position (1,7) are divided by a barrier heading south. The red robot starts at coordinates (1, 1). The plan must contain eighteen moves. A barrier exists between position (10,15) and position (11,15) in the direction of east.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4514125518673718845", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The green robot starts at coordinates (16, 1). A blue robot starts at position (1, 16). Position (10,1) and position (11,1) are divided by a barrier heading east. The red robot starts at coordinates (1, 1). Position (11,12) and position (12,12) are divided by a barrier heading east. Position (10,14) and position (10,15) are divided by a barrier heading south. There is a barrier between position (1,6) and position (1,7) heading south. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. The green robot should be guided to position (3, 13). The board is a square of 8x8. There must be seventeen moves in the plan. A barrier exists between position (1,12) and position (1,13) in the direction of south. Position (10,9) and position (9,9) are divided by a barrier heading west. A yellow robot is initially at position (16, 16). A barrier stands between positions (10,8) and (9,8), heading west.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,3,13).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The green robot starts at coordinates (16, 1). A blue robot starts at position (1, 16). Position (10,1) and position (11,1) are divided by a barrier heading east. The red robot starts at coordinates (1, 1). Position (11,12) and position (12,12) are divided by a barrier heading east. Position (10,14) and position (10,15) are divided by a barrier heading south. There is a barrier between position (1,6) and position (1,7) heading south. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. The green robot should be guided to position (3, 13). The board is a square of 8x8. There must be seventeen moves in the plan. A barrier exists between position (1,12) and position (1,13) in the direction of south. Position (10,9) and position (9,9) are divided by a barrier heading west. A yellow robot is initially at position (16, 16). A barrier stands between positions (10,8) and (9,8), heading west.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5354423425492515543", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. The green robot should be guided to position (9, 15). The location (16,1) is the starting position for the robot green. A barrier exists between position (1,12) and position (1,13) in the direction of south. The board is a square of 8x8. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. The yellow robot starts at coordinates (16, 16). A plan consisting of twenty-one moves is required. A barrier stands between positions (10,9) and (9,9), heading west. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east. The red robot starts at coordinates (1, 1). There is a barrier between position (11,12) and position (12,12) heading east. A blue robot starts at position (1, 16). A barrier exists between position (10,14) and position (10,15) in the direction of south. Position (10,8) and position (9,8) are divided by a barrier heading west.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(21). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,9,15).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. The green robot should be guided to position (9, 15). The location (16,1) is the starting position for the robot green. A barrier exists between position (1,12) and position (1,13) in the direction of south. The board is a square of 8x8. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. The yellow robot starts at coordinates (16, 16). A plan consisting of twenty-one moves is required. A barrier stands between positions (10,9) and (9,9), heading west. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east. The red robot starts at coordinates (1, 1). There is a barrier between position (11,12) and position (12,12) heading east. A blue robot starts at position (1, 16). A barrier exists between position (10,14) and position (10,15) in the direction of south. Position (10,8) and position (9,8) are divided by a barrier heading west.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9123204729233077145", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier exists between position (10,14) and position (10,15) in the direction of south. A blue robot is initially at position (1, 16). A barrier blocks the way between position (10,9) and position (9,9) in the direction of west. The aim is for the robot red to reach the coordinates (11, 4). A barrier blocks the way between position (11,12) and position (12,12) in the direction of east. Position (10,1) and position (11,1) are divided by a barrier heading east. The location (16,16) is the starting position for the robot yellow. Position (10,15) and position (11,15) are divided by a barrier heading east. The board is a square of 8x8. Position (1,6) and position (1,7) are divided by a barrier heading south. The number of moves in the plan is must be eighteen. A green robot is initially at position (16, 1). A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. The robot red is positioned at (1, 1) at the beginning. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(18). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,11,4).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier exists between position (10,14) and position (10,15) in the direction of south. A blue robot is initially at position (1, 16). A barrier blocks the way between position (10,9) and position (9,9) in the direction of west. The aim is for the robot red to reach the coordinates (11, 4). A barrier blocks the way between position (11,12) and position (12,12) in the direction of east. Position (10,1) and position (11,1) are divided by a barrier heading east. The location (16,16) is the starting position for the robot yellow. Position (10,15) and position (11,15) are divided by a barrier heading east. The board is a square of 8x8. Position (1,6) and position (1,7) are divided by a barrier heading south. The number of moves in the plan is must be eighteen. A green robot is initially at position (16, 1). A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. The robot red is positioned at (1, 1) at the beginning. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6570585593413275225", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The goal is for the robot red to reach position (3,5). A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. There must be thirteen moves in the plan. A barrier stands between positions (10,9) and (9,9), heading west. A barrier exists between position (1,12) and position (1,13) in the direction of south. A red robot starts at position (1, 1). The location (1,16) is the starting position for the robot blue. There is a barrier between position (10,14) and position (10,15) heading south. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east. There is a barrier between position (10,15) and position (11,15) heading east. The yellow robot starts at coordinates (16, 16). A barrier stands between positions (11,12) and (12,12), heading east. There is a barrier between position (10,8) and position (9,8) heading west. The location (16,1) is the starting position for the robot green. The board is a square of 8x8.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(13). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,3,5).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The goal is for the robot red to reach position (3,5). A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. There must be thirteen moves in the plan. A barrier stands between positions (10,9) and (9,9), heading west. A barrier exists between position (1,12) and position (1,13) in the direction of south. A red robot starts at position (1, 1). The location (1,16) is the starting position for the robot blue. There is a barrier between position (10,14) and position (10,15) heading south. A barrier blocks the way between position (10,1) and position (11,1) in the direction of east. There is a barrier between position (10,15) and position (11,15) heading east. The yellow robot starts at coordinates (16, 16). A barrier stands between positions (11,12) and (12,12), heading east. There is a barrier between position (10,8) and position (9,8) heading west. The location (16,1) is the starting position for the robot green. The board is a square of 8x8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6217352828132044965", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A blue robot starts at position (1, 16). The robot yellow is positioned at (16, 16) at the beginning. The goal is for the robot red to reach position (6,4). A barrier stands between positions (10,15) and (11,15), heading east. The board is a square of 8x8. The plan must contain eighteen moves. The green robot starts at coordinates (16, 1). There is a barrier between position (10,8) and position (9,8) heading west. A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. There is a barrier between position (10,9) and position (9,9) heading west. The robot red is positioned at (1, 1) at the beginning. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier exists between position (10,1) and position (11,1) in the direction of east. A barrier stands between positions (1,12) and (1,13), heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(18). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,6,4).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A blue robot starts at position (1, 16). The robot yellow is positioned at (16, 16) at the beginning. The goal is for the robot red to reach position (6,4). A barrier stands between positions (10,15) and (11,15), heading east. The board is a square of 8x8. The plan must contain eighteen moves. The green robot starts at coordinates (16, 1). There is a barrier between position (10,8) and position (9,8) heading west. A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. There is a barrier between position (10,9) and position (9,9) heading west. The robot red is positioned at (1, 1) at the beginning. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier exists between position (10,1) and position (11,1) in the direction of east. A barrier stands between positions (1,12) and (1,13), heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5578211195592984636", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "Position (10,1) and position (11,1) are divided by a barrier heading east. Position (11,12) and position (12,12) are divided by a barrier heading east. There is a barrier between position (10,8) and position (9,8) heading west. Position (10,14) and position (10,15) are divided by a barrier heading south. A red robot starts at position (1, 1). The board is a square of 8x8. A yellow robot starts at position (16, 16). Position (10,15) and position (11,15) are divided by a barrier heading east. A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. The green robot starts at coordinates (16, 1). The goal is for the red robot to move to position (12, 13). A barrier exists between position (1,6) and position (1,7) in the direction of south. The robot blue is positioned at (1, 16) at the beginning. There is a barrier between position (10,9) and position (9,9) heading west. There must be fifteen moves in the plan.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(15). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,12,13).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```Position (10,1) and position (11,1) are divided by a barrier heading east. Position (11,12) and position (12,12) are divided by a barrier heading east. There is a barrier between position (10,8) and position (9,8) heading west. Position (10,14) and position (10,15) are divided by a barrier heading south. A red robot starts at position (1, 1). The board is a square of 8x8. A yellow robot starts at position (16, 16). Position (10,15) and position (11,15) are divided by a barrier heading east. A barrier blocks the way between position (1,12) and position (1,13) in the direction of south. The green robot starts at coordinates (16, 1). The goal is for the red robot to move to position (12, 13). A barrier exists between position (1,6) and position (1,7) in the direction of south. The robot blue is positioned at (1, 16) at the beginning. There is a barrier between position (10,9) and position (9,9) heading west. There must be fifteen moves in the plan.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7886525530010409302", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The yellow robot starts at coordinates (16, 16). There is a barrier between position (1,12) and position (1,13) heading south. A barrier exists between position (10,15) and position (11,15) in the direction of east. Position (11,12) and position (12,12) are divided by a barrier heading east. There is a barrier between position (10,14) and position (10,15) heading south. Robot green's goal is to reach position (5, 12). A green robot is initially at position (16, 1). A barrier stands between positions (10,9) and (9,9), heading west. A barrier stands between positions (10,1) and (11,1), heading east. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. The number of moves in the plan is must be fifteen. The red robot starts at coordinates (1, 1). A barrier stands between positions (10,8) and (9,8), heading west. A blue robot is initially at position (1, 16). The board is a square of 8x8.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(15). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,5,12).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The yellow robot starts at coordinates (16, 16). There is a barrier between position (1,12) and position (1,13) heading south. A barrier exists between position (10,15) and position (11,15) in the direction of east. Position (11,12) and position (12,12) are divided by a barrier heading east. There is a barrier between position (10,14) and position (10,15) heading south. Robot green's goal is to reach position (5, 12). A green robot is initially at position (16, 1). A barrier stands between positions (10,9) and (9,9), heading west. A barrier stands between positions (10,1) and (11,1), heading east. A barrier blocks the way between position (1,6) and position (1,7) in the direction of south. The number of moves in the plan is must be fifteen. The red robot starts at coordinates (1, 1). A barrier stands between positions (10,8) and (9,8), heading west. A blue robot is initially at position (1, 16). The board is a square of 8x8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7879297426434359042", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "There must be twelve moves in the plan. The board is a square of 8x8. A yellow robot is initially at position (16, 16). The red robot starts at coordinates (1, 1). There is a barrier between position (10,1) and position (11,1) heading east. The location (1,16) is the starting position for the robot blue. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A barrier stands between positions (1,6) and (1,7), heading south. Position (10,8) and position (9,8) are divided by a barrier heading west. A barrier exists between position (10,14) and position (10,15) in the direction of south. The robot green is positioned at (16, 1) at the beginning. The objective is for the robot yellow to reach (13, 4). A barrier stands between positions (10,9) and (9,9), heading west. A barrier stands between positions (11,12) and (12,12), heading east. Position (1,12) and position (1,13) are divided by a barrier heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(12). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,13,4).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```There must be twelve moves in the plan. The board is a square of 8x8. A yellow robot is initially at position (16, 16). The red robot starts at coordinates (1, 1). There is a barrier between position (10,1) and position (11,1) heading east. The location (1,16) is the starting position for the robot blue. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A barrier stands between positions (1,6) and (1,7), heading south. Position (10,8) and position (9,8) are divided by a barrier heading west. A barrier exists between position (10,14) and position (10,15) in the direction of south. The robot green is positioned at (16, 1) at the beginning. The objective is for the robot yellow to reach (13, 4). A barrier stands between positions (10,9) and (9,9), heading west. A barrier stands between positions (11,12) and (12,12), heading east. Position (1,12) and position (1,13) are divided by a barrier heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2882985859148677102", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A yellow robot starts at position (16, 16). A barrier stands between positions (1,12) and (1,13), heading south. A barrier stands between positions (10,1) and (11,1), heading east. The number of moves in the plan is must be fifteen. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. A barrier stands between positions (1,6) and (1,7), heading south. The green robot should be guided to position (7, 12). The blue robot starts at coordinates (1, 16). The board is a square of 8x8. Position (10,14) and position (10,15) are divided by a barrier heading south. A green robot starts at position (16, 1). The robot red is positioned at (1, 1) at the beginning. There is a barrier between position (11,12) and position (12,12) heading east. A barrier blocks the way between position (10,9) and position (9,9) in the direction of west.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(15). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(green,7,12).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A yellow robot starts at position (16, 16). A barrier stands between positions (1,12) and (1,13), heading south. A barrier stands between positions (10,1) and (11,1), heading east. The number of moves in the plan is must be fifteen. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. A barrier stands between positions (1,6) and (1,7), heading south. The green robot should be guided to position (7, 12). The blue robot starts at coordinates (1, 16). The board is a square of 8x8. Position (10,14) and position (10,15) are divided by a barrier heading south. A green robot starts at position (16, 1). The robot red is positioned at (1, 1) at the beginning. There is a barrier between position (11,12) and position (12,12) heading east. A barrier blocks the way between position (10,9) and position (9,9) in the direction of west.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3413651010546970096", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "There is a barrier between position (11,12) and position (12,12) heading east. Position (10,15) and position (11,15) are divided by a barrier heading east. There is a barrier between position (10,8) and position (9,8) heading west. The plan must contain thirteen moves. A barrier exists between position (10,1) and position (11,1) in the direction of east. A barrier stands between positions (1,6) and (1,7), heading south. There is a barrier between position (10,9) and position (9,9) heading west. The objective is for the robot blue to reach (9, 5). The board is a square of 8x8. The robot blue is positioned at (1, 16) at the beginning. There is a barrier between position (10,14) and position (10,15) heading south. The green robot starts at coordinates (16, 1). Position (1,12) and position (1,13) are divided by a barrier heading south. The yellow robot starts at coordinates (16, 16). The robot red is positioned at (1, 1) at the beginning.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(13). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,9,5).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```There is a barrier between position (11,12) and position (12,12) heading east. Position (10,15) and position (11,15) are divided by a barrier heading east. There is a barrier between position (10,8) and position (9,8) heading west. The plan must contain thirteen moves. A barrier exists between position (10,1) and position (11,1) in the direction of east. A barrier stands between positions (1,6) and (1,7), heading south. There is a barrier between position (10,9) and position (9,9) heading west. The objective is for the robot blue to reach (9, 5). The board is a square of 8x8. The robot blue is positioned at (1, 16) at the beginning. There is a barrier between position (10,14) and position (10,15) heading south. The green robot starts at coordinates (16, 1). Position (1,12) and position (1,13) are divided by a barrier heading south. The yellow robot starts at coordinates (16, 16). The robot red is positioned at (1, 1) at the beginning.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7758684801408234949", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The board is a square of 8x8. A barrier exists between position (10,1) and position (11,1) in the direction of east. A barrier exists between position (11,12) and position (12,12) in the direction of east. A barrier stands between positions (10,8) and (9,8), heading west. A yellow robot starts at position (16, 16). A barrier stands between positions (1,6) and (1,7), heading south. The location (1,16) is the starting position for the robot blue. The robot red is positioned at (1, 1) at the beginning. A plan consisting of thirteen moves is required. A barrier exists between position (10,9) and position (9,9) in the direction of west. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. The green robot starts at coordinates (16, 1). A barrier exists between position (1,12) and position (1,13) in the direction of south. A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The aim is for the robot yellow to reach the coordinates (10, 15).", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(13). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,10,15).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The board is a square of 8x8. A barrier exists between position (10,1) and position (11,1) in the direction of east. A barrier exists between position (11,12) and position (12,12) in the direction of east. A barrier stands between positions (10,8) and (9,8), heading west. A yellow robot starts at position (16, 16). A barrier stands between positions (1,6) and (1,7), heading south. The location (1,16) is the starting position for the robot blue. The robot red is positioned at (1, 1) at the beginning. A plan consisting of thirteen moves is required. A barrier exists between position (10,9) and position (9,9) in the direction of west. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. The green robot starts at coordinates (16, 1). A barrier exists between position (1,12) and position (1,13) in the direction of south. A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The aim is for the robot yellow to reach the coordinates (10, 15).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6962554825784053384", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The robot green is positioned at (16, 1) at the beginning. A barrier exists between position (10,1) and position (11,1) in the direction of east. The robot yellow is positioned at (16, 16) at the beginning. A barrier stands between positions (10,14) and (10,15), heading south. A barrier exists between position (1,12) and position (1,13) in the direction of south. There is a barrier between position (11,12) and position (12,12) heading east. A barrier exists between position (1,6) and position (1,7) in the direction of south. A barrier blocks the way between position (10,9) and position (9,9) in the direction of west. The objective is for the robot yellow to reach (4, 9). A blue robot starts at position (1, 16). The red robot starts at coordinates (1, 1). There is a barrier between position (10,8) and position (9,8) heading west. The plan must contain thirteen moves. The board is a square of 8x8. A barrier stands between positions (10,15) and (11,15), heading east.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(13). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,4,9).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The robot green is positioned at (16, 1) at the beginning. A barrier exists between position (10,1) and position (11,1) in the direction of east. The robot yellow is positioned at (16, 16) at the beginning. A barrier stands between positions (10,14) and (10,15), heading south. A barrier exists between position (1,12) and position (1,13) in the direction of south. There is a barrier between position (11,12) and position (12,12) heading east. A barrier exists between position (1,6) and position (1,7) in the direction of south. A barrier blocks the way between position (10,9) and position (9,9) in the direction of west. The objective is for the robot yellow to reach (4, 9). A blue robot starts at position (1, 16). The red robot starts at coordinates (1, 1). There is a barrier between position (10,8) and position (9,8) heading west. The plan must contain thirteen moves. The board is a square of 8x8. A barrier stands between positions (10,15) and (11,15), heading east.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8442905431945194166", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The location (16,1) is the starting position for the robot green. Position (10,1) and position (11,1) are divided by a barrier heading east. The location (1,1) is the starting position for the robot red. There is a barrier between position (10,9) and position (9,9) heading west. There is a barrier between position (10,8) and position (9,8) heading west. The robot yellow is positioned at (16, 16) at the beginning. The board is a square of 8x8. A blue robot is initially at position (1, 16). A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The aim is for the robot blue to reach the coordinates (3, 10). A barrier stands between positions (1,12) and (1,13), heading south. A plan consisting of sixteen moves is required. A barrier exists between position (10,15) and position (11,15) in the direction of east. There is a barrier between position (11,12) and position (12,12) heading east. There is a barrier between position (1,6) and position (1,7) heading south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(16). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,3,10).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The location (16,1) is the starting position for the robot green. Position (10,1) and position (11,1) are divided by a barrier heading east. The location (1,1) is the starting position for the robot red. There is a barrier between position (10,9) and position (9,9) heading west. There is a barrier between position (10,8) and position (9,8) heading west. The robot yellow is positioned at (16, 16) at the beginning. The board is a square of 8x8. A blue robot is initially at position (1, 16). A barrier blocks the way between position (10,14) and position (10,15) in the direction of south. The aim is for the robot blue to reach the coordinates (3, 10). A barrier stands between positions (1,12) and (1,13), heading south. A plan consisting of sixteen moves is required. A barrier exists between position (10,15) and position (11,15) in the direction of east. There is a barrier between position (11,12) and position (12,12) heading east. There is a barrier between position (1,6) and position (1,7) heading south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "634676764032318987", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The number of moves in the plan is must be sixteen. There is a barrier between position (1,6) and position (1,7) heading south. The green robot starts at coordinates (16, 1). A barrier stands between positions (10,14) and (10,15), heading south. The board is a square of 8x8. The position (14,5) is the goal that must be reached by the robot blue. Position (1,12) and position (1,13) are divided by a barrier heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. There is a barrier between position (10,9) and position (9,9) heading west. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. The location (1,16) is the starting position for the robot blue. The yellow robot starts at coordinates (16, 16). The location (1,1) is the starting position for the robot red. There is a barrier between position (10,15) and position (11,15) heading east. A barrier exists between position (10,1) and position (11,1) in the direction of east.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(16). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,14,5).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The number of moves in the plan is must be sixteen. There is a barrier between position (1,6) and position (1,7) heading south. The green robot starts at coordinates (16, 1). A barrier stands between positions (10,14) and (10,15), heading south. The board is a square of 8x8. The position (14,5) is the goal that must be reached by the robot blue. Position (1,12) and position (1,13) are divided by a barrier heading south. A barrier exists between position (11,12) and position (12,12) in the direction of east. There is a barrier between position (10,9) and position (9,9) heading west. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. The location (1,16) is the starting position for the robot blue. The yellow robot starts at coordinates (16, 16). The location (1,1) is the starting position for the robot red. There is a barrier between position (10,15) and position (11,15) heading east. A barrier exists between position (10,1) and position (11,1) in the direction of east.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2807220314640736030", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The position (14,8) is the goal that must be reached by the robot blue. A plan consisting of seventeen moves is required. A barrier stands between positions (10,9) and (9,9), heading west. There is a barrier between position (11,12) and position (12,12) heading east. There is a barrier between position (10,8) and position (9,8) heading west. Position (1,12) and position (1,13) are divided by a barrier heading south. A blue robot starts at position (1, 16). The location (1,1) is the starting position for the robot red. A barrier stands between positions (10,14) and (10,15), heading south. A barrier exists between position (10,15) and position (11,15) in the direction of east. The board is a square of 8x8. There is a barrier between position (10,1) and position (11,1) heading east. The location (16,16) is the starting position for the robot yellow. A barrier stands between positions (1,6) and (1,7), heading south. The location (16,1) is the starting position for the robot green.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,14,8).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The position (14,8) is the goal that must be reached by the robot blue. A plan consisting of seventeen moves is required. A barrier stands between positions (10,9) and (9,9), heading west. There is a barrier between position (11,12) and position (12,12) heading east. There is a barrier between position (10,8) and position (9,8) heading west. Position (1,12) and position (1,13) are divided by a barrier heading south. A blue robot starts at position (1, 16). The location (1,1) is the starting position for the robot red. A barrier stands between positions (10,14) and (10,15), heading south. A barrier exists between position (10,15) and position (11,15) in the direction of east. The board is a square of 8x8. There is a barrier between position (10,1) and position (11,1) heading east. The location (16,16) is the starting position for the robot yellow. A barrier stands between positions (1,6) and (1,7), heading south. The location (16,1) is the starting position for the robot green.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2659309778718880643", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "There is a barrier between position (10,9) and position (9,9) heading west. A barrier stands between positions (10,1) and (11,1), heading east. A yellow robot is initially at position (16, 16). A barrier blocks the way between position (11,12) and position (12,12) in the direction of east. The board is a square of 8x8. There must be twenty-one moves in the plan. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A barrier stands between positions (1,12) and (1,13), heading south. The objective is for the robot yellow to reach (5, 14). A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. A barrier exists between position (1,6) and position (1,7) in the direction of south. A green robot is initially at position (16, 1). Position (10,14) and position (10,15) are divided by a barrier heading south. The robot blue is positioned at (1, 16) at the beginning. The robot red is positioned at (1, 1) at the beginning.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(21). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,5,14).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```There is a barrier between position (10,9) and position (9,9) heading west. A barrier stands between positions (10,1) and (11,1), heading east. A yellow robot is initially at position (16, 16). A barrier blocks the way between position (11,12) and position (12,12) in the direction of east. The board is a square of 8x8. There must be twenty-one moves in the plan. A barrier blocks the way between position (10,15) and position (11,15) in the direction of east. A barrier stands between positions (1,12) and (1,13), heading south. The objective is for the robot yellow to reach (5, 14). A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. A barrier exists between position (1,6) and position (1,7) in the direction of south. A green robot is initially at position (16, 1). Position (10,14) and position (10,15) are divided by a barrier heading south. The robot blue is positioned at (1, 16) at the beginning. The robot red is positioned at (1, 1) at the beginning.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7713060957688233752", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "A barrier exists between position (10,15) and position (11,15) in the direction of east. The yellow robot starts at coordinates (16, 16). A barrier exists between position (10,8) and position (9,8) in the direction of west. The robot green is positioned at (16, 1) at the beginning. A barrier exists between position (10,9) and position (9,9) in the direction of west. The board is a square of 8x8. Position (10,1) and position (11,1) are divided by a barrier heading east. The location (1,16) is the starting position for the robot blue. There must be seventeen moves in the plan. The robot red is positioned at (1, 1) at the beginning. The goal is for the yellow robot to move to position (6, 3). There is a barrier between position (10,14) and position (10,15) heading south. There is a barrier between position (11,12) and position (12,12) heading east. There is a barrier between position (1,12) and position (1,13) heading south. A barrier exists between position (1,6) and position (1,7) in the direction of south.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(17). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(yellow,6,3).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```A barrier exists between position (10,15) and position (11,15) in the direction of east. The yellow robot starts at coordinates (16, 16). A barrier exists between position (10,8) and position (9,8) in the direction of west. The robot green is positioned at (16, 1) at the beginning. A barrier exists between position (10,9) and position (9,9) in the direction of west. The board is a square of 8x8. Position (10,1) and position (11,1) are divided by a barrier heading east. The location (1,16) is the starting position for the robot blue. There must be seventeen moves in the plan. The robot red is positioned at (1, 1) at the beginning. The goal is for the yellow robot to move to position (6, 3). There is a barrier between position (10,14) and position (10,15) heading south. There is a barrier between position (11,12) and position (12,12) heading east. There is a barrier between position (1,12) and position (1,13) heading south. A barrier exists between position (1,6) and position (1,7) in the direction of south.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2639401104181683914", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "There is a barrier between position (10,1) and position (11,1) heading east. Position (1,6) and position (1,7) are divided by a barrier heading south. A barrier stands between positions (1,12) and (1,13), heading south. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. There is a barrier between position (10,15) and position (11,15) heading east. A red robot is initially at position (1, 1). Position (10,9) and position (9,9) are divided by a barrier heading west. The green robot starts at coordinates (16, 1). Position (11,12) and position (12,12) are divided by a barrier heading east. There is a barrier between position (10,14) and position (10,15) heading south. The board is a square of 8x8. The plan must contain fourteen moves. The location (1,16) is the starting position for the robot blue. The objective is for the robot blue to reach (13, 4). A yellow robot is initially at position (16, 16).", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(14). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(blue,13,4).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```There is a barrier between position (10,1) and position (11,1) heading east. Position (1,6) and position (1,7) are divided by a barrier heading south. A barrier stands between positions (1,12) and (1,13), heading south. A barrier blocks the way between position (10,8) and position (9,8) in the direction of west. There is a barrier between position (10,15) and position (11,15) heading east. A red robot is initially at position (1, 1). Position (10,9) and position (9,9) are divided by a barrier heading west. The green robot starts at coordinates (16, 1). Position (11,12) and position (12,12) are divided by a barrier heading east. There is a barrier between position (10,14) and position (10,15) heading south. The board is a square of 8x8. The plan must contain fourteen moves. The location (1,16) is the starting position for the robot blue. The objective is for the robot blue to reach (13, 4). A yellow robot is initially at position (16, 16).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1606397179484623297", "problem_id": "39", "problem_name": "Ricochet Robots", "description": "Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.", "format": "The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').", "text": "The board is a square of 8x8. Position (10,1) and position (11,1) are divided by a barrier heading east. A blue robot is initially at position (1, 16). A barrier exists between position (1,12) and position (1,13) in the direction of south. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier stands between positions (10,15) and (11,15), heading east. The red robot starts at coordinates (1, 1). A plan consisting of fourteen moves is required. A barrier stands between positions (10,8) and (9,8), heading west. A barrier exists between position (1,6) and position (1,7) in the direction of south. There is a barrier between position (10,14) and position (10,15) heading south. The aim is for the robot red to reach the coordinates (13, 12). A green robot is initially at position (16, 1). A yellow robot starts at position (16, 16). There is a barrier between position (10,9) and position (9,9) heading west.", "output": "barrier(1,12,south). barrier(1,6,south). barrier(10,1,east). barrier(10,14,south). barrier(10,15,east). barrier(10,8,west). barrier(10,9,west). barrier(11,12,east). dim(1). dim(2). dim(3). dim(4). dim(5). dim(6). dim(7). dim(8). length(14). pos(blue,1,16). pos(green,16,1). pos(red,1,1). pos(yellow,16,16). target(red,13,12).", "prompt": "Given the following problem description between triple backtips: \n ```Ricochet Robots is a board game played on an NxN grid with predefined horizontal and vertical barriers between some of the adjacent board positions. Board positions may be occupied by robots of distinct colors, and the goal is to guide some robot to a target position via a sequence of robot moves. A robot can move horizontally or vertically from its current position; once a direction is chosen, the robot moves in that direction until encountering an obstacle, i.e. a barrier, another robot, or the edge of the board, precluding that the robot moves further. While the original objective of the game is to achieve the goal with a minimum number of moves, we consider a decision version, viz. whether the goal can be established via some sequence (a plan) consisting of a predefined number of robot moves.```\nGiven the following specification for the predicates format: \n```The dimensions of a quadratic board are given by dim/1, e.g. dim(1). dim(2). dim(3). for a 3x3 board. The start positions of robots are given by pos/3}}, e.g. {{{pos(red,2,3). states that a red robot starts at position (2,3). The locations and orientations of barriers are given by barrier/3, e.g. barrier(4,3,east). states that there is a barrier between position (4,3) and position (5,3); note that the same barrier is also represented by barrier(5,3,west)., and a problem instance may include either or both representations. In any atom of the form barrier(x,y,d), a value \"east\", \"west\", \"south\", or \"north\" of d indicates a neighboring position (x+1,y), (x-1,y), (x,y+1), or (x,y-1), respectively, of position (x,y) on the board. The color and location of a target are given by target/3, e.g. target(red,4,3). states that the red robot should be guided to position (4,3). The number of moves in a plan is given by length/1, e.g. length(3). for a plan of three moves. A problem instance contains exactly one fact of the form length(l). and exactly one fact of the form target(c,x,y).; the color name c appears also in some fact of the form pos(c,x',y')., and there is exactly one fact pos(c',x',y'). per color name c' such that no distinct colors share the same start position (x',y').```\nExtract the datalog facts from this text: \n```The board is a square of 8x8. Position (10,1) and position (11,1) are divided by a barrier heading east. A blue robot is initially at position (1, 16). A barrier exists between position (1,12) and position (1,13) in the direction of south. Position (11,12) and position (12,12) are divided by a barrier heading east. A barrier stands between positions (10,15) and (11,15), heading east. The red robot starts at coordinates (1, 1). A plan consisting of fourteen moves is required. A barrier stands between positions (10,8) and (9,8), heading west. A barrier exists between position (1,6) and position (1,7) in the direction of south. There is a barrier between position (10,14) and position (10,15) heading south. The aim is for the robot red to reach the coordinates (13, 12). A green robot is initially at position (16, 1). A yellow robot starts at position (16, 16). There is a barrier between position (10,9) and position (9,9) heading west.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2530563706427351304", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The stone stone_02 must be moved to a goal location. Initially, stone_02 is located at position pos_07_04. Initially, player_01 is located at position pos_09_04. From location pos_02_03 we can reach location pos_02_04 by moving towards direction dir_down. Location pos_03_04 can be reached from location pos_02_04 by moving towards direction dir_right. To travel from location pos_01_07 to location pos_02_07, move towards direction dir_right. Initially, stone_04 is located at position pos_08_05. The following are goal locations where the stones must be placed: pos_04_02, pos_05_02, pos_06_02, pos_07_02. By moving in direction dir_right from location pos_02_03, we can arrive at location pos_03_03. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_02_01. The object stone_01 is initially at position pos_05_04. There is/are eight amount of allowed step/s. We can move from location pos_01_06 to location pos_02_06 by moving towards direction dir_right. Stone stone_03 has to be positioned in a goal location. Player player_01 is the sokoban. Stone stone_04 has to be positioned in a goal location. From location pos_02_04 we can reach location pos_02_03 by moving towards direction dir_up. At position pos_06_05 is stone_03 initially. The following floor locations are clear of objects: pos_01_01, pos_01_06, pos_01_07, pos_02_03, pos_02_04, pos_02_06, pos_02_07, pos_03_02. The stone stone_01 must be put in a goal location. To travel from location pos_01_06 to location pos_01_07, move towards direction dir_down. From location pos_01_07 we can reach location pos_01_06 by moving towards direction dir_up.", "output": "clear(pos_01_01). clear(pos_01_06). clear(pos_01_07). clear(pos_02_03). clear(pos_02_04). clear(pos_02_06). clear(pos_02_07). clear(pos_03_02). isgoal(pos_04_02). isgoal(pos_05_02). isgoal(pos_06_02). isgoal(pos_07_02). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_02_01). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_09_04). at(stone_01,pos_05_04). at(stone_02,pos_07_04). at(stone_03,pos_06_05). at(stone_04,pos_08_05). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_01_06,pos_01_07,dir_down). movedir(pos_01_06,pos_02_06,dir_right). movedir(pos_01_07,pos_01_06,dir_up). movedir(pos_01_07,pos_02_07,dir_right). movedir(pos_02_03,pos_02_04,dir_down). movedir(pos_02_03,pos_03_03,dir_right). movedir(pos_02_04,pos_02_03,dir_up). movedir(pos_02_04,pos_03_04,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The stone stone_02 must be moved to a goal location. Initially, stone_02 is located at position pos_07_04. Initially, player_01 is located at position pos_09_04. From location pos_02_03 we can reach location pos_02_04 by moving towards direction dir_down. Location pos_03_04 can be reached from location pos_02_04 by moving towards direction dir_right. To travel from location pos_01_07 to location pos_02_07, move towards direction dir_right. Initially, stone_04 is located at position pos_08_05. The following are goal locations where the stones must be placed: pos_04_02, pos_05_02, pos_06_02, pos_07_02. By moving in direction dir_right from location pos_02_03, we can arrive at location pos_03_03. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_02_01. The object stone_01 is initially at position pos_05_04. There is/are eight amount of allowed step/s. We can move from location pos_01_06 to location pos_02_06 by moving towards direction dir_right. Stone stone_03 has to be positioned in a goal location. Player player_01 is the sokoban. Stone stone_04 has to be positioned in a goal location. From location pos_02_04 we can reach location pos_02_03 by moving towards direction dir_up. At position pos_06_05 is stone_03 initially. The following floor locations are clear of objects: pos_01_01, pos_01_06, pos_01_07, pos_02_03, pos_02_04, pos_02_06, pos_02_07, pos_03_02. The stone stone_01 must be put in a goal location. To travel from location pos_01_06 to location pos_01_07, move towards direction dir_down. From location pos_01_07 we can reach location pos_01_06 by moving towards direction dir_up.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3059228111393494132", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The stone stone_03 should be placed in a goal location. Initially, stone_05 is located at position pos_03_12. The stone stone_04 must be moved to a goal location. To move from location pos_01_09 to location pos_01_10, go in direction dir_down. Player player_01 is the sokoban. The initial position of stone_03 is pos_05_10. The object stone_04 is initially at position pos_05_11. The following floor locations are clear of objects: pos_01_08, pos_01_09, pos_01_10, pos_01_15, pos_02_02, pos_02_03, pos_02_04, pos_02_05. Location pos_01_08 can be reached from location pos_01_09 by moving towards direction dir_up. stone_01 is initially at position pos_03_03. stone_02 is initially at position pos_03_05. The stone stone_05 must be moved to a goal location. By moving in direction dir_right from location pos_01_08, we can arrive at location pos_02_08. Starting at location pos_02_02, to reach location pos_02_03 move in direction dir_down. The stone stone_06 must be put in a goal location. The following are goal locations where the stones must be placed: pos_03_04, pos_03_06, pos_03_13, pos_04_13, pos_06_13, pos_07_13. The stone stone_02 must be moved to a goal location. From location pos_01_10 we can reach location pos_01_09 by moving towards direction dir_up. There is/are eight amount of allowed step/s. The stone stone_01 must be put in a goal location. Location pos_01_09 can be reached from location pos_01_08 by moving towards direction dir_down. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. Starting at location pos_01_15, to reach location pos_02_15 move in direction dir_right. Initially, player_01 is located at position pos_05_12. Starting at location pos_02_02, to reach location pos_03_02 move in direction dir_right. stone_06 is initially at position pos_07_12.", "output": "clear(pos_01_08). clear(pos_01_09). clear(pos_01_10). clear(pos_01_15). clear(pos_02_02). clear(pos_02_03). clear(pos_02_04). clear(pos_02_05). isgoal(pos_03_04). isgoal(pos_03_06). isgoal(pos_03_13). isgoal(pos_04_13). isgoal(pos_06_13). isgoal(pos_07_13). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_05_12). at(stone_01,pos_03_03). at(stone_02,pos_03_05). at(stone_03,pos_05_10). at(stone_04,pos_05_11). at(stone_05,pos_03_12). at(stone_06,pos_07_12). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). goal(stone_05). goal(stone_06). movedir(pos_01_08,pos_01_09,dir_down). movedir(pos_01_08,pos_02_08,dir_right). movedir(pos_01_09,pos_01_08,dir_up). movedir(pos_01_09,pos_01_10,dir_down). movedir(pos_01_10,pos_01_09,dir_up). movedir(pos_01_15,pos_02_15,dir_right). movedir(pos_02_02,pos_02_03,dir_down). movedir(pos_02_02,pos_03_02,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The stone stone_03 should be placed in a goal location. Initially, stone_05 is located at position pos_03_12. The stone stone_04 must be moved to a goal location. To move from location pos_01_09 to location pos_01_10, go in direction dir_down. Player player_01 is the sokoban. The initial position of stone_03 is pos_05_10. The object stone_04 is initially at position pos_05_11. The following floor locations are clear of objects: pos_01_08, pos_01_09, pos_01_10, pos_01_15, pos_02_02, pos_02_03, pos_02_04, pos_02_05. Location pos_01_08 can be reached from location pos_01_09 by moving towards direction dir_up. stone_01 is initially at position pos_03_03. stone_02 is initially at position pos_03_05. The stone stone_05 must be moved to a goal location. By moving in direction dir_right from location pos_01_08, we can arrive at location pos_02_08. Starting at location pos_02_02, to reach location pos_02_03 move in direction dir_down. The stone stone_06 must be put in a goal location. The following are goal locations where the stones must be placed: pos_03_04, pos_03_06, pos_03_13, pos_04_13, pos_06_13, pos_07_13. The stone stone_02 must be moved to a goal location. From location pos_01_10 we can reach location pos_01_09 by moving towards direction dir_up. There is/are eight amount of allowed step/s. The stone stone_01 must be put in a goal location. Location pos_01_09 can be reached from location pos_01_08 by moving towards direction dir_down. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. Starting at location pos_01_15, to reach location pos_02_15 move in direction dir_right. Initially, player_01 is located at position pos_05_12. Starting at location pos_02_02, to reach location pos_03_02 move in direction dir_right. stone_06 is initially at position pos_07_12.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "489177369096318187", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The initial position of player_01 is pos_11_05. The object stone_03 is initially at position pos_05_05. Stone stone_04 has to be positioned in a goal location. The object stone_04 is initially at position pos_06_05. Location pos_01_03 can be reached from location pos_01_02 by moving towards direction dir_down. At position pos_08_05 is stone_05 initially. Player player_01 is the sokoban. Stone stone_01 has to be positioned in a goal location. From location pos_01_01 we can reach location pos_01_02 by moving towards direction dir_down. At position pos_08_03 is stone_01 initially. Initially, stone_02 is located at position pos_03_05. Location pos_01_01 can be reached from location pos_01_02 by moving towards direction dir_up. To travel from location pos_01_03 to location pos_01_02, move towards direction dir_up. The stone stone_02 must be put in a goal location. There is/are eight amount of allowed step/s. We can move from location pos_02_01 to location pos_01_01 by moving towards direction dir_left. Stone stone_05 has to be positioned in a goal location. Starting at location pos_02_01, to reach location pos_03_01 move in direction dir_right. Location pos_02_01 can be reached from location pos_01_01 by moving towards direction dir_right. From location pos_01_08 we can reach location pos_02_08 by moving towards direction dir_right. The stone stone_03 should be placed in a goal location. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. The following floor locations are clear of objects: pos_01_01, pos_01_02, pos_01_03, pos_01_08, pos_02_01, pos_02_05, pos_02_06, pos_02_08. The following are goal locations where the stones must be placed: pos_07_04, pos_08_04, pos_12_04, pos_13_04, pos_14_04.", "output": "clear(pos_01_01). clear(pos_01_02). clear(pos_01_03). clear(pos_01_08). clear(pos_02_01). clear(pos_02_05). clear(pos_02_06). clear(pos_02_08). isgoal(pos_07_04). isgoal(pos_08_04). isgoal(pos_12_04). isgoal(pos_13_04). isgoal(pos_14_04). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_11_05). at(stone_01,pos_08_03). at(stone_02,pos_03_05). at(stone_03,pos_05_05). at(stone_04,pos_06_05). at(stone_05,pos_08_05). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). goal(stone_05). movedir(pos_01_01,pos_01_02,dir_down). movedir(pos_01_01,pos_02_01,dir_right). movedir(pos_01_02,pos_01_01,dir_up). movedir(pos_01_02,pos_01_03,dir_down). movedir(pos_01_03,pos_01_02,dir_up). movedir(pos_01_08,pos_02_08,dir_right). movedir(pos_02_01,pos_01_01,dir_left). movedir(pos_02_01,pos_03_01,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The initial position of player_01 is pos_11_05. The object stone_03 is initially at position pos_05_05. Stone stone_04 has to be positioned in a goal location. The object stone_04 is initially at position pos_06_05. Location pos_01_03 can be reached from location pos_01_02 by moving towards direction dir_down. At position pos_08_05 is stone_05 initially. Player player_01 is the sokoban. Stone stone_01 has to be positioned in a goal location. From location pos_01_01 we can reach location pos_01_02 by moving towards direction dir_down. At position pos_08_03 is stone_01 initially. Initially, stone_02 is located at position pos_03_05. Location pos_01_01 can be reached from location pos_01_02 by moving towards direction dir_up. To travel from location pos_01_03 to location pos_01_02, move towards direction dir_up. The stone stone_02 must be put in a goal location. There is/are eight amount of allowed step/s. We can move from location pos_02_01 to location pos_01_01 by moving towards direction dir_left. Stone stone_05 has to be positioned in a goal location. Starting at location pos_02_01, to reach location pos_03_01 move in direction dir_right. Location pos_02_01 can be reached from location pos_01_01 by moving towards direction dir_right. From location pos_01_08 we can reach location pos_02_08 by moving towards direction dir_right. The stone stone_03 should be placed in a goal location. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. The following floor locations are clear of objects: pos_01_01, pos_01_02, pos_01_03, pos_01_08, pos_02_01, pos_02_05, pos_02_06, pos_02_08. The following are goal locations where the stones must be placed: pos_07_04, pos_08_04, pos_12_04, pos_13_04, pos_14_04.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1763586012008329492", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The following floor locations are clear of objects: pos_01_06, pos_01_07, pos_01_08, pos_01_09, pos_01_10, pos_01_11, pos_02_02, pos_02_03. Stone stone_03 has to be positioned in a goal location. The following are goal locations where the stones must be placed: pos_04_03, pos_09_03, pos_09_04, pos_09_05. stone_04 is initially at position pos_06_09. The object player_01 is initially at position pos_05_08. To travel from location pos_01_08 to location pos_01_07, move towards direction dir_up. Starting at location pos_01_07, to reach location pos_01_08 move in direction dir_down. The object stone_02 is initially at position pos_06_08. We can move from location pos_01_08 to location pos_01_09 by moving towards direction dir_down. To move from location pos_01_08 to location pos_02_08, go in direction dir_right. Player player_01 is the sokoban. The stone stone_01 should be placed in a goal location. At position pos_05_09 is stone_03 initially. To travel from location pos_01_07 to location pos_01_06, move towards direction dir_up. Starting at location pos_01_09, to reach location pos_01_08 move in direction dir_up. The stone stone_02 should be placed in a goal location. There is/are eight amount of allowed step/s. Starting at location pos_01_09, to reach location pos_01_10 move in direction dir_down. Initially, stone_01 is located at position pos_03_04. Location pos_01_07 can be reached from location pos_01_06 by moving towards direction dir_down. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. Stone stone_04 has to be positioned in a goal location.", "output": "clear(pos_01_06). clear(pos_01_07). clear(pos_01_08). clear(pos_01_09). clear(pos_01_10). clear(pos_01_11). clear(pos_02_02). clear(pos_02_03). isgoal(pos_04_03). isgoal(pos_09_03). isgoal(pos_09_04). isgoal(pos_09_05). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_05_08). at(stone_01,pos_03_04). at(stone_02,pos_06_08). at(stone_03,pos_05_09). at(stone_04,pos_06_09). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_01_06,pos_01_07,dir_down). movedir(pos_01_07,pos_01_06,dir_up). movedir(pos_01_07,pos_01_08,dir_down). movedir(pos_01_08,pos_01_07,dir_up). movedir(pos_01_08,pos_01_09,dir_down). movedir(pos_01_08,pos_02_08,dir_right). movedir(pos_01_09,pos_01_08,dir_up). movedir(pos_01_09,pos_01_10,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The following floor locations are clear of objects: pos_01_06, pos_01_07, pos_01_08, pos_01_09, pos_01_10, pos_01_11, pos_02_02, pos_02_03. Stone stone_03 has to be positioned in a goal location. The following are goal locations where the stones must be placed: pos_04_03, pos_09_03, pos_09_04, pos_09_05. stone_04 is initially at position pos_06_09. The object player_01 is initially at position pos_05_08. To travel from location pos_01_08 to location pos_01_07, move towards direction dir_up. Starting at location pos_01_07, to reach location pos_01_08 move in direction dir_down. The object stone_02 is initially at position pos_06_08. We can move from location pos_01_08 to location pos_01_09 by moving towards direction dir_down. To move from location pos_01_08 to location pos_02_08, go in direction dir_right. Player player_01 is the sokoban. The stone stone_01 should be placed in a goal location. At position pos_05_09 is stone_03 initially. To travel from location pos_01_07 to location pos_01_06, move towards direction dir_up. Starting at location pos_01_09, to reach location pos_01_08 move in direction dir_up. The stone stone_02 should be placed in a goal location. There is/are eight amount of allowed step/s. Starting at location pos_01_09, to reach location pos_01_10 move in direction dir_down. Initially, stone_01 is located at position pos_03_04. Location pos_01_07 can be reached from location pos_01_06 by moving towards direction dir_down. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. Stone stone_04 has to be positioned in a goal location.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1537836895943051283", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. Stone stone_01 has to be positioned in a goal location. To travel from location pos_3_2 to location pos_4_2, move towards direction dir_right. The stone stone_02 should be placed in a goal location. By moving in direction dir_down from location pos_3_2, we can arrive at location pos_3_3. At position pos_5_3 is stone_01 initially. The following floor locations are clear of objects: pos_1_1, pos_2_3, pos_2_4, pos_3_2, pos_3_3, pos_3_4, pos_4_2, pos_4_3. We can move from location pos_2_3 to location pos_3_3 by moving towards direction dir_right. We can move from location pos_2_4 to location pos_3_4 by moving towards direction dir_right. By moving in direction dir_up from location pos_2_4, we can arrive at location pos_2_3. To move from location pos_3_3 to location pos_2_3, go in direction dir_left. The following are goal locations where the stones must be placed: pos_7_2, pos_7_4. player_01 is initially at position pos_7_3. From location pos_3_3 we can reach location pos_3_2 by moving towards direction dir_up. Player player_01 is the sokoban. At position pos_6_3 is stone_02 initially. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_2_1, pos_2_2, pos_2_3. There is/are eight amount of allowed step/s.", "output": "clear(pos_1_1). clear(pos_2_3). clear(pos_2_4). clear(pos_3_2). clear(pos_3_3). clear(pos_3_4). clear(pos_4_2). clear(pos_4_3). isgoal(pos_7_2). isgoal(pos_7_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_2_1). isnongoal(pos_2_2). isnongoal(pos_2_3). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_7_3). at(stone_01,pos_5_3). at(stone_02,pos_6_3). goal(stone_01). goal(stone_02). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_3_2,pos_3_3,dir_down). movedir(pos_3_2,pos_4_2,dir_right). movedir(pos_3_3,pos_2_3,dir_left). movedir(pos_3_3,pos_3_2,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. Stone stone_01 has to be positioned in a goal location. To travel from location pos_3_2 to location pos_4_2, move towards direction dir_right. The stone stone_02 should be placed in a goal location. By moving in direction dir_down from location pos_3_2, we can arrive at location pos_3_3. At position pos_5_3 is stone_01 initially. The following floor locations are clear of objects: pos_1_1, pos_2_3, pos_2_4, pos_3_2, pos_3_3, pos_3_4, pos_4_2, pos_4_3. We can move from location pos_2_3 to location pos_3_3 by moving towards direction dir_right. We can move from location pos_2_4 to location pos_3_4 by moving towards direction dir_right. By moving in direction dir_up from location pos_2_4, we can arrive at location pos_2_3. To move from location pos_3_3 to location pos_2_3, go in direction dir_left. The following are goal locations where the stones must be placed: pos_7_2, pos_7_4. player_01 is initially at position pos_7_3. From location pos_3_3 we can reach location pos_3_2 by moving towards direction dir_up. Player player_01 is the sokoban. At position pos_6_3 is stone_02 initially. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_2_1, pos_2_2, pos_2_3. There is/are eight amount of allowed step/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5971409568591545626", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Stone stone_02 has to be positioned in a goal location. We can move from location pos_2_4 to location pos_2_3 by moving towards direction dir_up. By moving in direction dir_right from location pos_2_2, we can arrive at location pos_3_2. player_01 is initially at position pos_6_4. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. Player player_01 is the sokoban. Starting at location pos_2_5, to reach location pos_2_4 move in direction dir_up. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_2_6, pos_3_2, pos_3_4, pos_3_6. The stone stone_01 must be put in a goal location. From location pos_2_4 we can reach location pos_3_4 by moving towards direction dir_right. We can move from location pos_2_2 to location pos_2_3 by moving towards direction dir_down. Location pos_2_2 can be reached from location pos_2_3 by moving towards direction dir_up. There is/are eight amount of allowed step/s. At position pos_5_4 is stone_02 initially. The initial position of stone_01 is pos_4_4. The following are goal locations where the stones must be placed: pos_2_6, pos_5_2. To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. By moving in direction dir_down from location pos_2_4, we can arrive at location pos_2_5.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_2_6). clear(pos_3_2). clear(pos_3_4). clear(pos_3_6). isgoal(pos_2_6). isgoal(pos_5_2). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_2_1). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_6_4). at(stone_01,pos_4_4). at(stone_02,pos_5_4). goal(stone_01). goal(stone_02). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_2_5,pos_2_4,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Stone stone_02 has to be positioned in a goal location. We can move from location pos_2_4 to location pos_2_3 by moving towards direction dir_up. By moving in direction dir_right from location pos_2_2, we can arrive at location pos_3_2. player_01 is initially at position pos_6_4. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. Player player_01 is the sokoban. Starting at location pos_2_5, to reach location pos_2_4 move in direction dir_up. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_2_6, pos_3_2, pos_3_4, pos_3_6. The stone stone_01 must be put in a goal location. From location pos_2_4 we can reach location pos_3_4 by moving towards direction dir_right. We can move from location pos_2_2 to location pos_2_3 by moving towards direction dir_down. Location pos_2_2 can be reached from location pos_2_3 by moving towards direction dir_up. There is/are eight amount of allowed step/s. At position pos_5_4 is stone_02 initially. The initial position of stone_01 is pos_4_4. The following are goal locations where the stones must be placed: pos_2_6, pos_5_2. To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. By moving in direction dir_down from location pos_2_4, we can arrive at location pos_2_5.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4613720477715175750", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "To move from location pos_2_3 to location pos_2_4, go in direction dir_down. Stone stone_01 has to be positioned in a goal location. From location pos_2_4 we can reach location pos_3_4 by moving towards direction dir_right. Stone stone_03 has to be positioned in a goal location. By moving in direction dir_up from location pos_2_3, we can arrive at location pos_2_2. From location pos_2_2 we can reach location pos_2_3 by moving towards direction dir_down. stone_01 is initially at position pos_3_3. Stone stone_02 has to be positioned in a goal location. The following are goal locations where the stones must be placed: pos_2_2, pos_4_5, pos_5_2. Player player_01 is the sokoban. The object stone_03 is initially at position pos_2_4. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. There is/are eight amount of allowed step/s. From location pos_2_4 we can reach location pos_2_3 by moving towards direction dir_up. Starting at location pos_2_4, to reach location pos_2_5 move in direction dir_down. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_3_2, pos_3_4, pos_3_5, pos_4_2, pos_4_5, pos_5_2. The object stone_02 is initially at position pos_4_3. player_01 is initially at position pos_2_5. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_3. Starting at location pos_2_2, to reach location pos_3_2 move in direction dir_right.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_3_2). clear(pos_3_4). clear(pos_3_5). clear(pos_4_2). clear(pos_4_5). clear(pos_5_2). isgoal(pos_2_2). isgoal(pos_4_5). isgoal(pos_5_2). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_3). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_2_5). at(stone_01,pos_3_3). at(stone_02,pos_4_3). at(stone_03,pos_2_4). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```To move from location pos_2_3 to location pos_2_4, go in direction dir_down. Stone stone_01 has to be positioned in a goal location. From location pos_2_4 we can reach location pos_3_4 by moving towards direction dir_right. Stone stone_03 has to be positioned in a goal location. By moving in direction dir_up from location pos_2_3, we can arrive at location pos_2_2. From location pos_2_2 we can reach location pos_2_3 by moving towards direction dir_down. stone_01 is initially at position pos_3_3. Stone stone_02 has to be positioned in a goal location. The following are goal locations where the stones must be placed: pos_2_2, pos_4_5, pos_5_2. Player player_01 is the sokoban. The object stone_03 is initially at position pos_2_4. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. There is/are eight amount of allowed step/s. From location pos_2_4 we can reach location pos_2_3 by moving towards direction dir_up. Starting at location pos_2_4, to reach location pos_2_5 move in direction dir_down. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_3_2, pos_3_4, pos_3_5, pos_4_2, pos_4_5, pos_5_2. The object stone_02 is initially at position pos_4_3. player_01 is initially at position pos_2_5. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_3. Starting at location pos_2_2, to reach location pos_3_2 move in direction dir_right.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2499050492328911670", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "By moving in direction dir_right from location pos_1_3, we can arrive at location pos_2_3. By moving in direction dir_down from location pos_1_1, we can arrive at location pos_1_2. From location pos_1_3 we can reach location pos_1_2 by moving towards direction dir_up. Player player_01 is the sokoban. We can move from location pos_1_3 to location pos_1_4 by moving towards direction dir_down. We can move from location pos_1_1 to location pos_2_1 by moving towards direction dir_right. There is/are eight amount of allowed step/s. We can move from location pos_1_2 to location pos_1_3 by moving towards direction dir_down. The following are goal locations where the stones must be placed: pos_6_6, pos_6_8. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_9, pos_2_1, pos_2_2, pos_2_3. Stone stone_01 has to be positioned in a goal location. Initially, player_01 is located at position pos_4_3. Location pos_2_2 can be reached from location pos_1_2 by moving towards direction dir_right. By moving in direction dir_up from location pos_1_2, we can arrive at location pos_1_1. Initially, stone_01 is located at position pos_6_6. The stone stone_02 must be moved to a goal location. At position pos_4_7 is stone_02 initially.", "output": "clear(pos_1_1). clear(pos_1_2). clear(pos_1_3). clear(pos_1_4). clear(pos_1_9). clear(pos_2_1). clear(pos_2_2). clear(pos_2_3). isgoal(pos_6_6). isgoal(pos_6_8). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_1_8). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_4_3). at(stone_01,pos_6_6). at(stone_02,pos_4_7). goal(stone_01). goal(stone_02). movedir(pos_1_1,pos_1_2,dir_down). movedir(pos_1_1,pos_2_1,dir_right). movedir(pos_1_2,pos_1_1,dir_up). movedir(pos_1_2,pos_1_3,dir_down). movedir(pos_1_2,pos_2_2,dir_right). movedir(pos_1_3,pos_1_2,dir_up). movedir(pos_1_3,pos_1_4,dir_down). movedir(pos_1_3,pos_2_3,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```By moving in direction dir_right from location pos_1_3, we can arrive at location pos_2_3. By moving in direction dir_down from location pos_1_1, we can arrive at location pos_1_2. From location pos_1_3 we can reach location pos_1_2 by moving towards direction dir_up. Player player_01 is the sokoban. We can move from location pos_1_3 to location pos_1_4 by moving towards direction dir_down. We can move from location pos_1_1 to location pos_2_1 by moving towards direction dir_right. There is/are eight amount of allowed step/s. We can move from location pos_1_2 to location pos_1_3 by moving towards direction dir_down. The following are goal locations where the stones must be placed: pos_6_6, pos_6_8. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_9, pos_2_1, pos_2_2, pos_2_3. Stone stone_01 has to be positioned in a goal location. Initially, player_01 is located at position pos_4_3. Location pos_2_2 can be reached from location pos_1_2 by moving towards direction dir_right. By moving in direction dir_up from location pos_1_2, we can arrive at location pos_1_1. Initially, stone_01 is located at position pos_6_6. The stone stone_02 must be moved to a goal location. At position pos_4_7 is stone_02 initially.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7217753259228517631", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "At position pos_6_4 is player_01 initially. We can move from location pos_2_3 to location pos_2_2 by moving towards direction dir_up. The following are goal locations where the stones must be placed: pos_6_2, pos_6_3. There is/are eight amount of allowed step/s. Initially, stone_01 is located at position pos_4_3. Stone stone_02 has to be positioned in a goal location. Player player_01 is the sokoban. To travel from location pos_2_4 to location pos_2_5, move towards direction dir_down. To travel from location pos_2_5 to location pos_2_4, move towards direction dir_up. From location pos_2_3 we can reach location pos_3_3 by moving towards direction dir_right. We can move from location pos_2_4 to location pos_2_3 by moving towards direction dir_up. Stone stone_01 has to be positioned in a goal location. Starting at location pos_2_2, to reach location pos_2_3 move in direction dir_down. To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_3_2, pos_3_3, pos_3_5, pos_4_4. The initial position of stone_02 is pos_5_3. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_3_2). clear(pos_3_3). clear(pos_3_5). clear(pos_4_4). isgoal(pos_6_2). isgoal(pos_6_3). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_6_4). at(stone_01,pos_4_3). at(stone_02,pos_5_3). goal(stone_01). goal(stone_02). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_5,pos_2_4,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```At position pos_6_4 is player_01 initially. We can move from location pos_2_3 to location pos_2_2 by moving towards direction dir_up. The following are goal locations where the stones must be placed: pos_6_2, pos_6_3. There is/are eight amount of allowed step/s. Initially, stone_01 is located at position pos_4_3. Stone stone_02 has to be positioned in a goal location. Player player_01 is the sokoban. To travel from location pos_2_4 to location pos_2_5, move towards direction dir_down. To travel from location pos_2_5 to location pos_2_4, move towards direction dir_up. From location pos_2_3 we can reach location pos_3_3 by moving towards direction dir_right. We can move from location pos_2_4 to location pos_2_3 by moving towards direction dir_up. Stone stone_01 has to be positioned in a goal location. Starting at location pos_2_2, to reach location pos_2_3 move in direction dir_down. To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_3_2, pos_3_3, pos_3_5, pos_4_4. The initial position of stone_02 is pos_5_3. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1043068408654049224", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "stone_02 is initially at position pos_04_03. We can move from location pos_02_05 to location pos_02_06 by moving towards direction dir_down. stone_01 is initially at position pos_03_03. stone_06 is initially at position pos_08_03. The stone stone_04 must be put in a goal location. Starting at location pos_02_04, to reach location pos_02_05 move in direction dir_down. Stone stone_05 has to be positioned in a goal location. Starting at location pos_02_03, to reach location pos_02_04 move in direction dir_down. Player player_01 is the sokoban. Location pos_02_05 can be reached from location pos_02_06 by moving towards direction dir_up. By moving in direction dir_right from location pos_02_03, we can arrive at location pos_03_03. The stone stone_01 should be placed in a goal location. The stone stone_06 must be moved to a goal location. stone_05 is initially at position pos_07_03. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_02_01. Initially, stone_03 is located at position pos_05_03. The stone stone_02 must be moved to a goal location. By moving in direction dir_up from location pos_02_05, we can arrive at location pos_02_04. The following are goal locations where the stones must be placed: pos_03_02, pos_04_02, pos_05_02, pos_06_02, pos_07_02, pos_08_02, pos_09_02. Location pos_02_03 can be reached from location pos_02_04 by moving towards direction dir_up. stone_04 is initially at position pos_06_03. To travel from location pos_02_04 to location pos_03_04, move towards direction dir_right. The stone stone_03 must be put in a goal location. player_01 is initially at position pos_10_03. The stone stone_07 should be placed in a goal location. There is/are eight amount of allowed step/s. Initially, stone_07 is located at position pos_09_03. The following floor locations are clear of objects: pos_01_01, pos_02_03, pos_02_04, pos_02_05, pos_02_06, pos_03_02, pos_03_04, pos_03_06.", "output": "clear(pos_01_01). clear(pos_02_03). clear(pos_02_04). clear(pos_02_05). clear(pos_02_06). clear(pos_03_02). clear(pos_03_04). clear(pos_03_06). isgoal(pos_03_02). isgoal(pos_04_02). isgoal(pos_05_02). isgoal(pos_06_02). isgoal(pos_07_02). isgoal(pos_08_02). isgoal(pos_09_02). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_02_01). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_10_03). at(stone_01,pos_03_03). at(stone_02,pos_04_03). at(stone_03,pos_05_03). at(stone_04,pos_06_03). at(stone_05,pos_07_03). at(stone_06,pos_08_03). at(stone_07,pos_09_03). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). goal(stone_05). goal(stone_06). goal(stone_07). movedir(pos_02_03,pos_02_04,dir_down). movedir(pos_02_03,pos_03_03,dir_right). movedir(pos_02_04,pos_02_03,dir_up). movedir(pos_02_04,pos_02_05,dir_down). movedir(pos_02_04,pos_03_04,dir_right). movedir(pos_02_05,pos_02_04,dir_up). movedir(pos_02_05,pos_02_06,dir_down). movedir(pos_02_06,pos_02_05,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```stone_02 is initially at position pos_04_03. We can move from location pos_02_05 to location pos_02_06 by moving towards direction dir_down. stone_01 is initially at position pos_03_03. stone_06 is initially at position pos_08_03. The stone stone_04 must be put in a goal location. Starting at location pos_02_04, to reach location pos_02_05 move in direction dir_down. Stone stone_05 has to be positioned in a goal location. Starting at location pos_02_03, to reach location pos_02_04 move in direction dir_down. Player player_01 is the sokoban. Location pos_02_05 can be reached from location pos_02_06 by moving towards direction dir_up. By moving in direction dir_right from location pos_02_03, we can arrive at location pos_03_03. The stone stone_01 should be placed in a goal location. The stone stone_06 must be moved to a goal location. stone_05 is initially at position pos_07_03. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_02_01. Initially, stone_03 is located at position pos_05_03. The stone stone_02 must be moved to a goal location. By moving in direction dir_up from location pos_02_05, we can arrive at location pos_02_04. The following are goal locations where the stones must be placed: pos_03_02, pos_04_02, pos_05_02, pos_06_02, pos_07_02, pos_08_02, pos_09_02. Location pos_02_03 can be reached from location pos_02_04 by moving towards direction dir_up. stone_04 is initially at position pos_06_03. To travel from location pos_02_04 to location pos_03_04, move towards direction dir_right. The stone stone_03 must be put in a goal location. player_01 is initially at position pos_10_03. The stone stone_07 should be placed in a goal location. There is/are eight amount of allowed step/s. Initially, stone_07 is located at position pos_09_03. The following floor locations are clear of objects: pos_01_01, pos_02_03, pos_02_04, pos_02_05, pos_02_06, pos_03_02, pos_03_04, pos_03_06.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2872815264717613426", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "From location pos_1_6 we can reach location pos_1_7 by moving towards direction dir_down. Starting at location pos_1_7, to reach location pos_1_6 move in direction dir_up. The following are goal locations where the stones must be placed: pos_5_6, pos_6_6, pos_7_6. The stone stone_02 must be moved to a goal location. To move from location pos_1_8 to location pos_1_7, go in direction dir_up. At position pos_6_4 is stone_03 initially. By moving in direction dir_right from location pos_1_1, we can arrive at location pos_2_1. The object player_01 is initially at position pos_8_4. The stone stone_01 must be put in a goal location. To move from location pos_1_8 to location pos_1_9, go in direction dir_down. From location pos_1_7 we can reach location pos_1_8 by moving towards direction dir_down. There is/are eight amount of allowed step/s. The object stone_02 is initially at position pos_4_4. From location pos_1_7 we can reach location pos_2_7 by moving towards direction dir_right. stone_01 is initially at position pos_6_3. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. Starting at location pos_1_6, to reach location pos_2_6 move in direction dir_right. Player player_01 is the sokoban. The following floor locations are clear of objects: pos_1_1, pos_1_6, pos_1_7, pos_1_8, pos_1_9, pos_2_1, pos_2_3, pos_2_4. The stone stone_03 should be placed in a goal location.", "output": "clear(pos_1_1). clear(pos_1_6). clear(pos_1_7). clear(pos_1_8). clear(pos_1_9). clear(pos_2_1). clear(pos_2_3). clear(pos_2_4). isgoal(pos_5_6). isgoal(pos_6_6). isgoal(pos_7_6). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_1_8). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_8_4). at(stone_01,pos_6_3). at(stone_02,pos_4_4). at(stone_03,pos_6_4). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_1_1,pos_2_1,dir_right). movedir(pos_1_6,pos_1_7,dir_down). movedir(pos_1_6,pos_2_6,dir_right). movedir(pos_1_7,pos_1_6,dir_up). movedir(pos_1_7,pos_1_8,dir_down). movedir(pos_1_7,pos_2_7,dir_right). movedir(pos_1_8,pos_1_7,dir_up). movedir(pos_1_8,pos_1_9,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```From location pos_1_6 we can reach location pos_1_7 by moving towards direction dir_down. Starting at location pos_1_7, to reach location pos_1_6 move in direction dir_up. The following are goal locations where the stones must be placed: pos_5_6, pos_6_6, pos_7_6. The stone stone_02 must be moved to a goal location. To move from location pos_1_8 to location pos_1_7, go in direction dir_up. At position pos_6_4 is stone_03 initially. By moving in direction dir_right from location pos_1_1, we can arrive at location pos_2_1. The object player_01 is initially at position pos_8_4. The stone stone_01 must be put in a goal location. To move from location pos_1_8 to location pos_1_9, go in direction dir_down. From location pos_1_7 we can reach location pos_1_8 by moving towards direction dir_down. There is/are eight amount of allowed step/s. The object stone_02 is initially at position pos_4_4. From location pos_1_7 we can reach location pos_2_7 by moving towards direction dir_right. stone_01 is initially at position pos_6_3. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. Starting at location pos_1_6, to reach location pos_2_6 move in direction dir_right. Player player_01 is the sokoban. The following floor locations are clear of objects: pos_1_1, pos_1_6, pos_1_7, pos_1_8, pos_1_9, pos_2_1, pos_2_3, pos_2_4. The stone stone_03 should be placed in a goal location.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7101485509754782457", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Initially, stone_01 is located at position pos_04_03. stone_04 is initially at position pos_04_06. From location pos_02_07 we can reach location pos_03_07 by moving towards direction dir_right. At position pos_06_03 is stone_02 initially. Starting at location pos_02_07, to reach location pos_02_08 move in direction dir_down. The stone stone_04 should be placed in a goal location. We can move from location pos_02_06 to location pos_02_07 by moving towards direction dir_down. We can move from location pos_02_05 to location pos_02_06 by moving towards direction dir_down. Player player_01 is the sokoban. Initially, stone_03 is located at position pos_08_04. To move from location pos_02_06 to location pos_03_06, go in direction dir_right. Stone stone_03 has to be positioned in a goal location. We can move from location pos_02_07 to location pos_02_06 by moving towards direction dir_up. We can move from location pos_02_05 to location pos_03_05 by moving towards direction dir_right. The stone stone_01 must be moved to a goal location. There is/are eight amount of allowed step/s. The following floor locations are clear of objects: pos_01_03, pos_02_05, pos_02_06, pos_02_07, pos_02_08, pos_03_01, pos_03_03, pos_03_04. To move from location pos_02_06 to location pos_02_05, go in direction dir_up. At position pos_03_07 is player_01 initially. The stone stone_02 must be moved to a goal location. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. The following are goal locations where the stones must be placed: pos_07_03, pos_07_04, pos_07_05, pos_07_06.", "output": "clear(pos_01_03). clear(pos_02_05). clear(pos_02_06). clear(pos_02_07). clear(pos_02_08). clear(pos_03_01). clear(pos_03_03). clear(pos_03_04). isgoal(pos_07_03). isgoal(pos_07_04). isgoal(pos_07_05). isgoal(pos_07_06). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_03_07). at(stone_01,pos_04_03). at(stone_02,pos_06_03). at(stone_03,pos_08_04). at(stone_04,pos_04_06). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_02_05,pos_02_06,dir_down). movedir(pos_02_05,pos_03_05,dir_right). movedir(pos_02_06,pos_02_05,dir_up). movedir(pos_02_06,pos_02_07,dir_down). movedir(pos_02_06,pos_03_06,dir_right). movedir(pos_02_07,pos_02_06,dir_up). movedir(pos_02_07,pos_02_08,dir_down). movedir(pos_02_07,pos_03_07,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Initially, stone_01 is located at position pos_04_03. stone_04 is initially at position pos_04_06. From location pos_02_07 we can reach location pos_03_07 by moving towards direction dir_right. At position pos_06_03 is stone_02 initially. Starting at location pos_02_07, to reach location pos_02_08 move in direction dir_down. The stone stone_04 should be placed in a goal location. We can move from location pos_02_06 to location pos_02_07 by moving towards direction dir_down. We can move from location pos_02_05 to location pos_02_06 by moving towards direction dir_down. Player player_01 is the sokoban. Initially, stone_03 is located at position pos_08_04. To move from location pos_02_06 to location pos_03_06, go in direction dir_right. Stone stone_03 has to be positioned in a goal location. We can move from location pos_02_07 to location pos_02_06 by moving towards direction dir_up. We can move from location pos_02_05 to location pos_03_05 by moving towards direction dir_right. The stone stone_01 must be moved to a goal location. There is/are eight amount of allowed step/s. The following floor locations are clear of objects: pos_01_03, pos_02_05, pos_02_06, pos_02_07, pos_02_08, pos_03_01, pos_03_03, pos_03_04. To move from location pos_02_06 to location pos_02_05, go in direction dir_up. At position pos_03_07 is player_01 initially. The stone stone_02 must be moved to a goal location. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. The following are goal locations where the stones must be placed: pos_07_03, pos_07_04, pos_07_05, pos_07_06.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8071342101255505348", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The initial position of stone_04 is pos_07_07. The following are goal locations where the stones must be placed: pos_04_04, pos_05_04, pos_05_09, pos_06_04. Player player_01 is the sokoban. Location pos_01_10 can be reached from location pos_01_09 by moving towards direction dir_down. At position pos_07_04 is player_01 initially. The stone stone_03 must be moved to a goal location. The object stone_02 is initially at position pos_04_07. We can move from location pos_02_03 to location pos_02_02 by moving towards direction dir_up. The stone stone_01 must be put in a goal location. From location pos_02_02 we can reach location pos_03_02 by moving towards direction dir_right. The stone stone_02 must be moved to a goal location. Location pos_02_03 can be reached from location pos_02_02 by moving towards direction dir_down. The stone stone_04 must be moved to a goal location. The following floor locations are clear of objects: pos_01_09, pos_01_10, pos_02_02, pos_02_03, pos_02_04, pos_02_05, pos_02_06, pos_02_07. By moving in direction dir_down from location pos_02_03, we can arrive at location pos_02_04. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. To travel from location pos_01_10 to location pos_02_10, move towards direction dir_right. To move from location pos_01_10 to location pos_01_09, go in direction dir_up. From location pos_01_09 we can reach location pos_02_09 by moving towards direction dir_right. There is/are eight amount of allowed step/s. Initially, stone_01 is located at position pos_06_05. At position pos_05_07 is stone_03 initially.", "output": "clear(pos_01_09). clear(pos_01_10). clear(pos_02_02). clear(pos_02_03). clear(pos_02_04). clear(pos_02_05). clear(pos_02_06). clear(pos_02_07). isgoal(pos_04_04). isgoal(pos_05_04). isgoal(pos_05_09). isgoal(pos_06_04). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_07_04). at(stone_01,pos_06_05). at(stone_02,pos_04_07). at(stone_03,pos_05_07). at(stone_04,pos_07_07). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_01_09,pos_01_10,dir_down). movedir(pos_01_09,pos_02_09,dir_right). movedir(pos_01_10,pos_01_09,dir_up). movedir(pos_01_10,pos_02_10,dir_right). movedir(pos_02_02,pos_02_03,dir_down). movedir(pos_02_02,pos_03_02,dir_right). movedir(pos_02_03,pos_02_02,dir_up). movedir(pos_02_03,pos_02_04,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The initial position of stone_04 is pos_07_07. The following are goal locations where the stones must be placed: pos_04_04, pos_05_04, pos_05_09, pos_06_04. Player player_01 is the sokoban. Location pos_01_10 can be reached from location pos_01_09 by moving towards direction dir_down. At position pos_07_04 is player_01 initially. The stone stone_03 must be moved to a goal location. The object stone_02 is initially at position pos_04_07. We can move from location pos_02_03 to location pos_02_02 by moving towards direction dir_up. The stone stone_01 must be put in a goal location. From location pos_02_02 we can reach location pos_03_02 by moving towards direction dir_right. The stone stone_02 must be moved to a goal location. Location pos_02_03 can be reached from location pos_02_02 by moving towards direction dir_down. The stone stone_04 must be moved to a goal location. The following floor locations are clear of objects: pos_01_09, pos_01_10, pos_02_02, pos_02_03, pos_02_04, pos_02_05, pos_02_06, pos_02_07. By moving in direction dir_down from location pos_02_03, we can arrive at location pos_02_04. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. To travel from location pos_01_10 to location pos_02_10, move towards direction dir_right. To move from location pos_01_10 to location pos_01_09, go in direction dir_up. From location pos_01_09 we can reach location pos_02_09 by moving towards direction dir_right. There is/are eight amount of allowed step/s. Initially, stone_01 is located at position pos_06_05. At position pos_05_07 is stone_03 initially.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5529473553969451929", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Player player_01 is the sokoban. From location pos_2_2 we can reach location pos_3_2 by moving towards direction dir_right. From location pos_2_2 we can reach location pos_2_3 by moving towards direction dir_down. Stone stone_02 has to be positioned in a goal location. At position pos_5_3 is stone_01 initially. At position pos_8_3 is player_01 initially. The following floor locations are clear of objects: pos_1_5, pos_1_6, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_3_2, pos_3_3. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. stone_02 is initially at position pos_6_3. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. The stone stone_01 should be placed in a goal location. There is/are eight amount of allowed step/s. To travel from location pos_1_6 to location pos_1_5, move towards direction dir_up. From location pos_1_6 we can reach location pos_2_6 by moving towards direction dir_right. To move from location pos_1_5 to location pos_2_5, go in direction dir_right. The following are goal locations where the stones must be placed: pos_8_2, pos_8_4. By moving in direction dir_down from location pos_1_5, we can arrive at location pos_1_6. To move from location pos_2_3 to location pos_2_2, go in direction dir_up.", "output": "clear(pos_1_5). clear(pos_1_6). clear(pos_2_2). clear(pos_2_3). clear(pos_2_5). clear(pos_2_6). clear(pos_3_2). clear(pos_3_3). isgoal(pos_8_2). isgoal(pos_8_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_8_3). at(stone_01,pos_5_3). at(stone_02,pos_6_3). goal(stone_01). goal(stone_02). movedir(pos_1_5,pos_1_6,dir_down). movedir(pos_1_5,pos_2_5,dir_right). movedir(pos_1_6,pos_1_5,dir_up). movedir(pos_1_6,pos_2_6,dir_right). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_3_3,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Player player_01 is the sokoban. From location pos_2_2 we can reach location pos_3_2 by moving towards direction dir_right. From location pos_2_2 we can reach location pos_2_3 by moving towards direction dir_down. Stone stone_02 has to be positioned in a goal location. At position pos_5_3 is stone_01 initially. At position pos_8_3 is player_01 initially. The following floor locations are clear of objects: pos_1_5, pos_1_6, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_3_2, pos_3_3. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. stone_02 is initially at position pos_6_3. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. The stone stone_01 should be placed in a goal location. There is/are eight amount of allowed step/s. To travel from location pos_1_6 to location pos_1_5, move towards direction dir_up. From location pos_1_6 we can reach location pos_2_6 by moving towards direction dir_right. To move from location pos_1_5 to location pos_2_5, go in direction dir_right. The following are goal locations where the stones must be placed: pos_8_2, pos_8_4. By moving in direction dir_down from location pos_1_5, we can arrive at location pos_1_6. To move from location pos_2_3 to location pos_2_2, go in direction dir_up.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4224634042174354975", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "To move from location pos_2_2 to location pos_2_3, go in direction dir_down. To travel from location pos_2_2 to location pos_3_2, move towards direction dir_right. Player player_01 is the sokoban. The following floor locations are clear of objects: pos_1_6, pos_2_2, pos_2_3, pos_2_4, pos_3_4, pos_3_5, pos_4_2, pos_4_5. The object player_01 is initially at position pos_3_2. The following are goal locations where the stones must be placed: pos_3_5, pos_5_2. By moving in direction dir_right from location pos_2_3, we can arrive at location pos_3_3. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. Initially, stone_02 is located at position pos_4_3. By moving in direction dir_up from location pos_2_3, we can arrive at location pos_2_2. There is/are eight amount of allowed step/s. Starting at location pos_2_4, to reach location pos_3_4 move in direction dir_right. We can move from location pos_2_3 to location pos_2_4 by moving towards direction dir_down. To travel from location pos_3_2 to location pos_2_2, move towards direction dir_left. Starting at location pos_2_4, to reach location pos_2_3 move in direction dir_up. The stone stone_02 must be put in a goal location. Stone stone_01 has to be positioned in a goal location. The object stone_01 is initially at position pos_3_3.", "output": "clear(pos_1_6). clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_3_4). clear(pos_3_5). clear(pos_4_2). clear(pos_4_5). isgoal(pos_3_5). isgoal(pos_5_2). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_3_2). at(stone_01,pos_3_3). at(stone_02,pos_4_3). goal(stone_01). goal(stone_02). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_3_2,pos_2_2,dir_left). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```To move from location pos_2_2 to location pos_2_3, go in direction dir_down. To travel from location pos_2_2 to location pos_3_2, move towards direction dir_right. Player player_01 is the sokoban. The following floor locations are clear of objects: pos_1_6, pos_2_2, pos_2_3, pos_2_4, pos_3_4, pos_3_5, pos_4_2, pos_4_5. The object player_01 is initially at position pos_3_2. The following are goal locations where the stones must be placed: pos_3_5, pos_5_2. By moving in direction dir_right from location pos_2_3, we can arrive at location pos_3_3. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. Initially, stone_02 is located at position pos_4_3. By moving in direction dir_up from location pos_2_3, we can arrive at location pos_2_2. There is/are eight amount of allowed step/s. Starting at location pos_2_4, to reach location pos_3_4 move in direction dir_right. We can move from location pos_2_3 to location pos_2_4 by moving towards direction dir_down. To travel from location pos_3_2 to location pos_2_2, move towards direction dir_left. Starting at location pos_2_4, to reach location pos_2_3 move in direction dir_up. The stone stone_02 must be put in a goal location. Stone stone_01 has to be positioned in a goal location. The object stone_01 is initially at position pos_3_3.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8123721645406042428", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Stone stone_01 has to be positioned in a goal location. stone_02 is initially at position pos_3_5. The stone stone_02 must be put in a goal location. player_01 is initially at position pos_6_6. The stone stone_03 must be put in a goal location. By moving in direction dir_right from location pos_1_1, we can arrive at location pos_2_1. The following are goal locations where the stones must be placed: pos_8_2, pos_8_3, pos_8_4. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. By moving in direction dir_down from location pos_2_3, we can arrive at location pos_2_4. Initially, stone_03 is located at position pos_6_5. From location pos_1_7 we can reach location pos_1_8 by moving towards direction dir_down. There is/are eight amount of allowed step/s. To move from location pos_1_8 to location pos_1_7, go in direction dir_up. To travel from location pos_2_1 to location pos_3_1, move towards direction dir_right. Starting at location pos_1_8, to reach location pos_2_8 move in direction dir_right. Location pos_1_1 can be reached from location pos_2_1 by moving towards direction dir_left. Location pos_2_7 can be reached from location pos_1_7 by moving towards direction dir_right. stone_01 is initially at position pos_5_4. Player player_01 is the sokoban. The following floor locations are clear of objects: pos_1_1, pos_1_7, pos_1_8, pos_2_1, pos_2_3, pos_2_4, pos_2_5, pos_2_7.", "output": "clear(pos_1_1). clear(pos_1_7). clear(pos_1_8). clear(pos_2_1). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_2_7). isgoal(pos_8_2). isgoal(pos_8_3). isgoal(pos_8_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_1_8). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_6_6). at(stone_01,pos_5_4). at(stone_02,pos_3_5). at(stone_03,pos_6_5). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_1_1,pos_2_1,dir_right). movedir(pos_1_7,pos_1_8,dir_down). movedir(pos_1_7,pos_2_7,dir_right). movedir(pos_1_8,pos_1_7,dir_up). movedir(pos_1_8,pos_2_8,dir_right). movedir(pos_2_1,pos_1_1,dir_left). movedir(pos_2_1,pos_3_1,dir_right). movedir(pos_2_3,pos_2_4,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Stone stone_01 has to be positioned in a goal location. stone_02 is initially at position pos_3_5. The stone stone_02 must be put in a goal location. player_01 is initially at position pos_6_6. The stone stone_03 must be put in a goal location. By moving in direction dir_right from location pos_1_1, we can arrive at location pos_2_1. The following are goal locations where the stones must be placed: pos_8_2, pos_8_3, pos_8_4. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. By moving in direction dir_down from location pos_2_3, we can arrive at location pos_2_4. Initially, stone_03 is located at position pos_6_5. From location pos_1_7 we can reach location pos_1_8 by moving towards direction dir_down. There is/are eight amount of allowed step/s. To move from location pos_1_8 to location pos_1_7, go in direction dir_up. To travel from location pos_2_1 to location pos_3_1, move towards direction dir_right. Starting at location pos_1_8, to reach location pos_2_8 move in direction dir_right. Location pos_1_1 can be reached from location pos_2_1 by moving towards direction dir_left. Location pos_2_7 can be reached from location pos_1_7 by moving towards direction dir_right. stone_01 is initially at position pos_5_4. Player player_01 is the sokoban. The following floor locations are clear of objects: pos_1_1, pos_1_7, pos_1_8, pos_2_1, pos_2_3, pos_2_4, pos_2_5, pos_2_7.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5637864467967830674", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The following are goal locations where the stones must be placed: pos_5_2, pos_5_4. From location pos_3_2 we can reach location pos_2_2 by moving towards direction dir_left. stone_01 is initially at position pos_3_3. At position pos_4_3 is stone_02 initially. By moving in direction dir_right from location pos_2_3, we can arrive at location pos_3_3. The stone stone_01 should be placed in a goal location. Player player_01 is the sokoban. At position pos_5_3 is player_01 initially. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up. There is/are eight amount of allowed step/s. Starting at location pos_2_2, to reach location pos_2_3 move in direction dir_down. The stone stone_02 must be put in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_2_1, pos_2_2, pos_2_3. Location pos_2_3 can be reached from location pos_2_4 by moving towards direction dir_up. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_3_2, pos_3_4, pos_4_2, pos_5_2, pos_5_4. Location pos_3_4 can be reached from location pos_2_4 by moving towards direction dir_right. Starting at location pos_2_3, to reach location pos_2_4 move in direction dir_down.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_3_2). clear(pos_3_4). clear(pos_4_2). clear(pos_5_2). clear(pos_5_4). isgoal(pos_5_2). isgoal(pos_5_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_2_1). isnongoal(pos_2_2). isnongoal(pos_2_3). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_5_3). at(stone_01,pos_3_3). at(stone_02,pos_4_3). goal(stone_01). goal(stone_02). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_3_2,pos_2_2,dir_left). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The following are goal locations where the stones must be placed: pos_5_2, pos_5_4. From location pos_3_2 we can reach location pos_2_2 by moving towards direction dir_left. stone_01 is initially at position pos_3_3. At position pos_4_3 is stone_02 initially. By moving in direction dir_right from location pos_2_3, we can arrive at location pos_3_3. The stone stone_01 should be placed in a goal location. Player player_01 is the sokoban. At position pos_5_3 is player_01 initially. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up. There is/are eight amount of allowed step/s. Starting at location pos_2_2, to reach location pos_2_3 move in direction dir_down. The stone stone_02 must be put in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_2_1, pos_2_2, pos_2_3. Location pos_2_3 can be reached from location pos_2_4 by moving towards direction dir_up. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_3_2, pos_3_4, pos_4_2, pos_5_2, pos_5_4. Location pos_3_4 can be reached from location pos_2_4 by moving towards direction dir_right. Starting at location pos_2_3, to reach location pos_2_4 move in direction dir_down.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8289581279766476669", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Location pos_2_5 can be reached from location pos_1_5 by moving towards direction dir_right. The initial position of stone_01 is pos_5_3. We can move from location pos_1_6 to location pos_1_5 by moving towards direction dir_up. We can move from location pos_1_6 to location pos_2_6 by moving towards direction dir_right. There is/are eight amount of allowed step/s. The following floor locations are clear of objects: pos_1_5, pos_1_6, pos_1_7, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_2_7. Starting at location pos_1_5, to reach location pos_1_6 move in direction dir_down. The object stone_02 is initially at position pos_6_3. The initial position of player_01 is pos_7_3. To travel from location pos_1_7 to location pos_1_6, move towards direction dir_up. Starting at location pos_1_7, to reach location pos_2_7 move in direction dir_right. The following are goal locations where the stones must be placed: pos_7_2, pos_7_4. Player player_01 is the sokoban. The stone stone_01 should be placed in a goal location. From location pos_1_6 we can reach location pos_1_7 by moving towards direction dir_down. The stone stone_02 must be moved to a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. Starting at location pos_2_2, to reach location pos_2_3 move in direction dir_down.", "output": "clear(pos_1_5). clear(pos_1_6). clear(pos_1_7). clear(pos_2_2). clear(pos_2_3). clear(pos_2_5). clear(pos_2_6). clear(pos_2_7). isgoal(pos_7_2). isgoal(pos_7_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_2_1). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_7_3). at(stone_01,pos_5_3). at(stone_02,pos_6_3). goal(stone_01). goal(stone_02). movedir(pos_1_5,pos_1_6,dir_down). movedir(pos_1_5,pos_2_5,dir_right). movedir(pos_1_6,pos_1_5,dir_up). movedir(pos_1_6,pos_1_7,dir_down). movedir(pos_1_6,pos_2_6,dir_right). movedir(pos_1_7,pos_1_6,dir_up). movedir(pos_1_7,pos_2_7,dir_right). movedir(pos_2_2,pos_2_3,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Location pos_2_5 can be reached from location pos_1_5 by moving towards direction dir_right. The initial position of stone_01 is pos_5_3. We can move from location pos_1_6 to location pos_1_5 by moving towards direction dir_up. We can move from location pos_1_6 to location pos_2_6 by moving towards direction dir_right. There is/are eight amount of allowed step/s. The following floor locations are clear of objects: pos_1_5, pos_1_6, pos_1_7, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_2_7. Starting at location pos_1_5, to reach location pos_1_6 move in direction dir_down. The object stone_02 is initially at position pos_6_3. The initial position of player_01 is pos_7_3. To travel from location pos_1_7 to location pos_1_6, move towards direction dir_up. Starting at location pos_1_7, to reach location pos_2_7 move in direction dir_right. The following are goal locations where the stones must be placed: pos_7_2, pos_7_4. Player player_01 is the sokoban. The stone stone_01 should be placed in a goal location. From location pos_1_6 we can reach location pos_1_7 by moving towards direction dir_down. The stone stone_02 must be moved to a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. Starting at location pos_2_2, to reach location pos_2_3 move in direction dir_down.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "732630903226714783", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "At position pos_4_3 is stone_01 initially. Location pos_2_4 can be reached from location pos_2_5 by moving towards direction dir_up. To move from location pos_1_1 to location pos_1_2, go in direction dir_down. From location pos_2_4 we can reach location pos_2_5 by moving towards direction dir_down. Player player_01 is the sokoban. player_01 is initially at position pos_3_3. The stone stone_03 must be put in a goal location. The initial position of stone_02 is pos_3_4. The following are goal locations where the stones must be placed: pos_3_5, pos_5_3, pos_5_5. The stone stone_02 must be put in a goal location. To travel from location pos_2_1 to location pos_1_1, move towards direction dir_left. The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_1_7, pos_2_1, pos_2_4, pos_2_5, pos_2_7, pos_3_5. stone_03 is initially at position pos_4_4. Location pos_2_1 can be reached from location pos_1_1 by moving towards direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. The stone stone_01 must be put in a goal location. There is/are eight amount of allowed step/s. Location pos_2_7 can be reached from location pos_1_7 by moving towards direction dir_right. By moving in direction dir_up from location pos_1_2, we can arrive at location pos_1_1. To travel from location pos_2_4 to location pos_3_4, move towards direction dir_right.", "output": "clear(pos_1_1). clear(pos_1_2). clear(pos_1_7). clear(pos_2_1). clear(pos_2_4). clear(pos_2_5). clear(pos_2_7). clear(pos_3_5). isgoal(pos_3_5). isgoal(pos_5_3). isgoal(pos_5_5). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_2_1). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_3_3). at(stone_01,pos_4_3). at(stone_02,pos_3_4). at(stone_03,pos_4_4). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_1_1,pos_1_2,dir_down). movedir(pos_1_1,pos_2_1,dir_right). movedir(pos_1_2,pos_1_1,dir_up). movedir(pos_1_7,pos_2_7,dir_right). movedir(pos_2_1,pos_1_1,dir_left). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_2_5,pos_2_4,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```At position pos_4_3 is stone_01 initially. Location pos_2_4 can be reached from location pos_2_5 by moving towards direction dir_up. To move from location pos_1_1 to location pos_1_2, go in direction dir_down. From location pos_2_4 we can reach location pos_2_5 by moving towards direction dir_down. Player player_01 is the sokoban. player_01 is initially at position pos_3_3. The stone stone_03 must be put in a goal location. The initial position of stone_02 is pos_3_4. The following are goal locations where the stones must be placed: pos_3_5, pos_5_3, pos_5_5. The stone stone_02 must be put in a goal location. To travel from location pos_2_1 to location pos_1_1, move towards direction dir_left. The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_1_7, pos_2_1, pos_2_4, pos_2_5, pos_2_7, pos_3_5. stone_03 is initially at position pos_4_4. Location pos_2_1 can be reached from location pos_1_1 by moving towards direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. The stone stone_01 must be put in a goal location. There is/are eight amount of allowed step/s. Location pos_2_7 can be reached from location pos_1_7 by moving towards direction dir_right. By moving in direction dir_up from location pos_1_2, we can arrive at location pos_1_1. To travel from location pos_2_4 to location pos_3_4, move towards direction dir_right.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2924794603475697866", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "There is/are eight amount of allowed step/s. The stone stone_02 must be moved to a goal location. The following are goal locations where the stones must be placed: pos_8_2, pos_8_4. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. By moving in direction dir_right from location pos_2_2, we can arrive at location pos_3_2. Location pos_2_2 can be reached from location pos_2_3 by moving towards direction dir_up. Player player_01 is the sokoban. The stone stone_01 must be moved to a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. Location pos_2_6 can be reached from location pos_1_6 by moving towards direction dir_right. The following floor locations are clear of objects: pos_1_5, pos_1_6, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_3_2, pos_3_3. Starting at location pos_1_5, to reach location pos_2_5 move in direction dir_right. The initial position of stone_01 is pos_5_3. Initially, player_01 is located at position pos_8_3. At position pos_6_3 is stone_02 initially. Location pos_1_5 can be reached from location pos_1_6 by moving towards direction dir_up. To travel from location pos_1_5 to location pos_1_6, move towards direction dir_down. To move from location pos_2_2 to location pos_2_3, go in direction dir_down.", "output": "clear(pos_1_5). clear(pos_1_6). clear(pos_2_2). clear(pos_2_3). clear(pos_2_5). clear(pos_2_6). clear(pos_3_2). clear(pos_3_3). isgoal(pos_8_2). isgoal(pos_8_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_8_3). at(stone_01,pos_5_3). at(stone_02,pos_6_3). goal(stone_01). goal(stone_02). movedir(pos_1_5,pos_1_6,dir_down). movedir(pos_1_5,pos_2_5,dir_right). movedir(pos_1_6,pos_1_5,dir_up). movedir(pos_1_6,pos_2_6,dir_right). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_3_3,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```There is/are eight amount of allowed step/s. The stone stone_02 must be moved to a goal location. The following are goal locations where the stones must be placed: pos_8_2, pos_8_4. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. By moving in direction dir_right from location pos_2_2, we can arrive at location pos_3_2. Location pos_2_2 can be reached from location pos_2_3 by moving towards direction dir_up. Player player_01 is the sokoban. The stone stone_01 must be moved to a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. Location pos_2_6 can be reached from location pos_1_6 by moving towards direction dir_right. The following floor locations are clear of objects: pos_1_5, pos_1_6, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_3_2, pos_3_3. Starting at location pos_1_5, to reach location pos_2_5 move in direction dir_right. The initial position of stone_01 is pos_5_3. Initially, player_01 is located at position pos_8_3. At position pos_6_3 is stone_02 initially. Location pos_1_5 can be reached from location pos_1_6 by moving towards direction dir_up. To travel from location pos_1_5 to location pos_1_6, move towards direction dir_down. To move from location pos_2_2 to location pos_2_3, go in direction dir_down.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2680258011185192027", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_2_4, pos_2_5, pos_3_2, pos_3_3, pos_3_5, pos_4_2. We can move from location pos_1_2 to location pos_1_1 by moving towards direction dir_up. To move from location pos_3_2 to location pos_3_3, go in direction dir_down. Player player_01 is the sokoban. To travel from location pos_2_5 to location pos_2_4, move towards direction dir_up. To move from location pos_2_4 to location pos_3_4, go in direction dir_right. From location pos_1_1 we can reach location pos_1_2 by moving towards direction dir_down. The following are goal locations where the stones must be placed: pos_3_5, pos_4_5, pos_5_5. At position pos_3_4 is stone_01 initially. To move from location pos_3_2 to location pos_4_2, go in direction dir_right. Stone stone_02 has to be positioned in a goal location. The stone stone_01 must be moved to a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. There is/are eight amount of allowed step/s. At position pos_4_5 is player_01 initially. stone_02 is initially at position pos_4_4. Starting at location pos_2_5, to reach location pos_3_5 move in direction dir_right. We can move from location pos_2_4 to location pos_2_5 by moving towards direction dir_down. The stone stone_03 must be moved to a goal location. At position pos_5_4 is stone_03 initially.", "output": "clear(pos_1_1). clear(pos_1_2). clear(pos_2_4). clear(pos_2_5). clear(pos_3_2). clear(pos_3_3). clear(pos_3_5). clear(pos_4_2). isgoal(pos_3_5). isgoal(pos_4_5). isgoal(pos_5_5). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_4_5). at(stone_01,pos_3_4). at(stone_02,pos_4_4). at(stone_03,pos_5_4). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_1_1,pos_1_2,dir_down). movedir(pos_1_2,pos_1_1,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_2_5,pos_2_4,dir_up). movedir(pos_2_5,pos_3_5,dir_right). movedir(pos_3_2,pos_3_3,dir_down). movedir(pos_3_2,pos_4_2,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_2_4, pos_2_5, pos_3_2, pos_3_3, pos_3_5, pos_4_2. We can move from location pos_1_2 to location pos_1_1 by moving towards direction dir_up. To move from location pos_3_2 to location pos_3_3, go in direction dir_down. Player player_01 is the sokoban. To travel from location pos_2_5 to location pos_2_4, move towards direction dir_up. To move from location pos_2_4 to location pos_3_4, go in direction dir_right. From location pos_1_1 we can reach location pos_1_2 by moving towards direction dir_down. The following are goal locations where the stones must be placed: pos_3_5, pos_4_5, pos_5_5. At position pos_3_4 is stone_01 initially. To move from location pos_3_2 to location pos_4_2, go in direction dir_right. Stone stone_02 has to be positioned in a goal location. The stone stone_01 must be moved to a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. There is/are eight amount of allowed step/s. At position pos_4_5 is player_01 initially. stone_02 is initially at position pos_4_4. Starting at location pos_2_5, to reach location pos_3_5 move in direction dir_right. We can move from location pos_2_4 to location pos_2_5 by moving towards direction dir_down. The stone stone_03 must be moved to a goal location. At position pos_5_4 is stone_03 initially.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "314259599296722396", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The stone stone_02 should be placed in a goal location. The following are goal locations where the stones must be placed: pos_4_5, pos_5_5, pos_6_5. The stone stone_03 should be placed in a goal location. The initial position of stone_03 is pos_3_4. From location pos_2_5 we can reach location pos_2_6 by moving towards direction dir_down. The initial position of player_01 is pos_3_2. To travel from location pos_1_8 to location pos_2_8, move towards direction dir_right. Player player_01 is the sokoban. By moving in direction dir_right from location pos_2_5, we can arrive at location pos_3_5. The following floor locations are clear of objects: pos_1_8, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_2_8, pos_3_5, pos_3_6. From location pos_2_6 we can reach location pos_2_5 by moving towards direction dir_up. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. Initially, stone_01 is located at position pos_3_3. stone_02 is initially at position pos_5_3. We can move from location pos_2_2 to location pos_2_3 by moving towards direction dir_down. Starting at location pos_2_2, to reach location pos_3_2 move in direction dir_right. There is/are eight amount of allowed step/s. The stone stone_01 should be placed in a goal location. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up.", "output": "clear(pos_1_8). clear(pos_2_2). clear(pos_2_3). clear(pos_2_5). clear(pos_2_6). clear(pos_2_8). clear(pos_3_5). clear(pos_3_6). isgoal(pos_4_5). isgoal(pos_5_5). isgoal(pos_6_5). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_1_8). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_3_2). at(stone_01,pos_3_3). at(stone_02,pos_5_3). at(stone_03,pos_3_4). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_1_8,pos_2_8,dir_right). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_5,pos_2_6,dir_down). movedir(pos_2_5,pos_3_5,dir_right). movedir(pos_2_6,pos_2_5,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The stone stone_02 should be placed in a goal location. The following are goal locations where the stones must be placed: pos_4_5, pos_5_5, pos_6_5. The stone stone_03 should be placed in a goal location. The initial position of stone_03 is pos_3_4. From location pos_2_5 we can reach location pos_2_6 by moving towards direction dir_down. The initial position of player_01 is pos_3_2. To travel from location pos_1_8 to location pos_2_8, move towards direction dir_right. Player player_01 is the sokoban. By moving in direction dir_right from location pos_2_5, we can arrive at location pos_3_5. The following floor locations are clear of objects: pos_1_8, pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_2_8, pos_3_5, pos_3_6. From location pos_2_6 we can reach location pos_2_5 by moving towards direction dir_up. Starting at location pos_2_3, to reach location pos_3_3 move in direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. Initially, stone_01 is located at position pos_3_3. stone_02 is initially at position pos_5_3. We can move from location pos_2_2 to location pos_2_3 by moving towards direction dir_down. Starting at location pos_2_2, to reach location pos_3_2 move in direction dir_right. There is/are eight amount of allowed step/s. The stone stone_01 should be placed in a goal location. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "755151697663962962", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "To move from location pos_2_2 to location pos_2_3, go in direction dir_down. The following are goal locations where the stones must be placed: pos_7_2, pos_7_3, pos_7_4. The object player_01 is initially at position pos_3_3. The stone stone_01 must be moved to a goal location. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_3_2, pos_3_4, pos_4_2, pos_5_2, pos_5_4. To move from location pos_2_4 to location pos_2_3, go in direction dir_up. Stone stone_02 has to be positioned in a goal location. To travel from location pos_2_2 to location pos_3_2, move towards direction dir_right. The object stone_01 is initially at position pos_4_3. The stone stone_03 should be placed in a goal location. Starting at location pos_2_3, to reach location pos_2_4 move in direction dir_down. Starting at location pos_2_4, to reach location pos_3_4 move in direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_2_1, pos_2_2, pos_2_3. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up. By moving in direction dir_left from location pos_3_2, we can arrive at location pos_2_2. Player player_01 is the sokoban. To travel from location pos_2_3 to location pos_3_3, move towards direction dir_right. The initial position of stone_03 is pos_6_3. The object stone_02 is initially at position pos_5_3. There is/are eight amount of allowed step/s.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_3_2). clear(pos_3_4). clear(pos_4_2). clear(pos_5_2). clear(pos_5_4). isgoal(pos_7_2). isgoal(pos_7_3). isgoal(pos_7_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_2_1). isnongoal(pos_2_2). isnongoal(pos_2_3). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_3_3). at(stone_01,pos_4_3). at(stone_02,pos_5_3). at(stone_03,pos_6_3). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_3_2,pos_2_2,dir_left). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```To move from location pos_2_2 to location pos_2_3, go in direction dir_down. The following are goal locations where the stones must be placed: pos_7_2, pos_7_3, pos_7_4. The object player_01 is initially at position pos_3_3. The stone stone_01 must be moved to a goal location. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_3_2, pos_3_4, pos_4_2, pos_5_2, pos_5_4. To move from location pos_2_4 to location pos_2_3, go in direction dir_up. Stone stone_02 has to be positioned in a goal location. To travel from location pos_2_2 to location pos_3_2, move towards direction dir_right. The object stone_01 is initially at position pos_4_3. The stone stone_03 should be placed in a goal location. Starting at location pos_2_3, to reach location pos_2_4 move in direction dir_down. Starting at location pos_2_4, to reach location pos_3_4 move in direction dir_right. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_2_1, pos_2_2, pos_2_3. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up. By moving in direction dir_left from location pos_3_2, we can arrive at location pos_2_2. Player player_01 is the sokoban. To travel from location pos_2_3 to location pos_3_3, move towards direction dir_right. The initial position of stone_03 is pos_6_3. The object stone_02 is initially at position pos_5_3. There is/are eight amount of allowed step/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4835893583900242629", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The object stone_02 is initially at position pos_7_4. The initial position of stone_01 is pos_7_3. By moving in direction dir_left from location pos_2_1, we can arrive at location pos_1_1. Initially, player_01 is located at position pos_7_5. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. We can move from location pos_2_3 to location pos_2_4 by moving towards direction dir_down. Starting at location pos_2_5, to reach location pos_2_4 move in direction dir_up. Player player_01 is the sokoban. The stone stone_02 should be placed in a goal location. From location pos_2_3 we can reach location pos_3_3 by moving towards direction dir_right. There is/are eight amount of allowed step/s. The following floor locations are clear of objects: pos_1_1, pos_2_1, pos_2_3, pos_2_4, pos_2_5, pos_3_3, pos_3_5, pos_4_2. From location pos_1_1 we can reach location pos_2_1 by moving towards direction dir_right. We can move from location pos_2_4 to location pos_2_3 by moving towards direction dir_up. The following are goal locations where the stones must be placed: pos_3_5, pos_5_5. We can move from location pos_2_5 to location pos_3_5 by moving towards direction dir_right. From location pos_2_4 we can reach location pos_2_5 by moving towards direction dir_down. Stone stone_01 has to be positioned in a goal location.", "output": "clear(pos_1_1). clear(pos_2_1). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_3_3). clear(pos_3_5). clear(pos_4_2). isgoal(pos_3_5). isgoal(pos_5_5). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_7_5). at(stone_01,pos_7_3). at(stone_02,pos_7_4). goal(stone_01). goal(stone_02). movedir(pos_1_1,pos_2_1,dir_right). movedir(pos_2_1,pos_1_1,dir_left). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_5,pos_2_4,dir_up). movedir(pos_2_5,pos_3_5,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The object stone_02 is initially at position pos_7_4. The initial position of stone_01 is pos_7_3. By moving in direction dir_left from location pos_2_1, we can arrive at location pos_1_1. Initially, player_01 is located at position pos_7_5. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. We can move from location pos_2_3 to location pos_2_4 by moving towards direction dir_down. Starting at location pos_2_5, to reach location pos_2_4 move in direction dir_up. Player player_01 is the sokoban. The stone stone_02 should be placed in a goal location. From location pos_2_3 we can reach location pos_3_3 by moving towards direction dir_right. There is/are eight amount of allowed step/s. The following floor locations are clear of objects: pos_1_1, pos_2_1, pos_2_3, pos_2_4, pos_2_5, pos_3_3, pos_3_5, pos_4_2. From location pos_1_1 we can reach location pos_2_1 by moving towards direction dir_right. We can move from location pos_2_4 to location pos_2_3 by moving towards direction dir_up. The following are goal locations where the stones must be placed: pos_3_5, pos_5_5. We can move from location pos_2_5 to location pos_3_5 by moving towards direction dir_right. From location pos_2_4 we can reach location pos_2_5 by moving towards direction dir_down. Stone stone_01 has to be positioned in a goal location.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1365709239525704022", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "By moving in direction dir_down from location pos_1_1, we can arrive at location pos_1_2. Initially, player_01 is located at position pos_5_4. Initially, stone_03 is located at position pos_6_4. The stone stone_02 must be put in a goal location. To move from location pos_1_2 to location pos_1_3, go in direction dir_down. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. Stone stone_01 has to be positioned in a goal location. Player player_01 is the sokoban. The object stone_01 is initially at position pos_5_3. The object stone_02 is initially at position pos_4_4. The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_1_3, pos_2_5, pos_2_6, pos_3_2, pos_3_3, pos_3_4. There is/are eight amount of allowed step/s. The stone stone_04 must be moved to a goal location. We can move from location pos_1_3 to location pos_1_2 by moving towards direction dir_up. The stone stone_03 should be placed in a goal location. The following are goal locations where the stones must be placed: pos_4_3, pos_4_5, pos_6_3, pos_6_5. To move from location pos_2_6 to location pos_2_5, go in direction dir_up. Starting at location pos_2_6, to reach location pos_3_6 move in direction dir_right. The initial position of stone_04 is pos_5_5. We can move from location pos_1_2 to location pos_1_1 by moving towards direction dir_up. From location pos_2_5 we can reach location pos_3_5 by moving towards direction dir_right. From location pos_2_5 we can reach location pos_2_6 by moving towards direction dir_down.", "output": "clear(pos_1_1). clear(pos_1_2). clear(pos_1_3). clear(pos_2_5). clear(pos_2_6). clear(pos_3_2). clear(pos_3_3). clear(pos_3_4). isgoal(pos_4_3). isgoal(pos_4_5). isgoal(pos_6_3). isgoal(pos_6_5). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_2_1). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_5_4). at(stone_01,pos_5_3). at(stone_02,pos_4_4). at(stone_03,pos_6_4). at(stone_04,pos_5_5). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_1_1,pos_1_2,dir_down). movedir(pos_1_2,pos_1_1,dir_up). movedir(pos_1_2,pos_1_3,dir_down). movedir(pos_1_3,pos_1_2,dir_up). movedir(pos_2_5,pos_2_6,dir_down). movedir(pos_2_5,pos_3_5,dir_right). movedir(pos_2_6,pos_2_5,dir_up). movedir(pos_2_6,pos_3_6,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```By moving in direction dir_down from location pos_1_1, we can arrive at location pos_1_2. Initially, player_01 is located at position pos_5_4. Initially, stone_03 is located at position pos_6_4. The stone stone_02 must be put in a goal location. To move from location pos_1_2 to location pos_1_3, go in direction dir_down. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. Stone stone_01 has to be positioned in a goal location. Player player_01 is the sokoban. The object stone_01 is initially at position pos_5_3. The object stone_02 is initially at position pos_4_4. The following floor locations are clear of objects: pos_1_1, pos_1_2, pos_1_3, pos_2_5, pos_2_6, pos_3_2, pos_3_3, pos_3_4. There is/are eight amount of allowed step/s. The stone stone_04 must be moved to a goal location. We can move from location pos_1_3 to location pos_1_2 by moving towards direction dir_up. The stone stone_03 should be placed in a goal location. The following are goal locations where the stones must be placed: pos_4_3, pos_4_5, pos_6_3, pos_6_5. To move from location pos_2_6 to location pos_2_5, go in direction dir_up. Starting at location pos_2_6, to reach location pos_3_6 move in direction dir_right. The initial position of stone_04 is pos_5_5. We can move from location pos_1_2 to location pos_1_1 by moving towards direction dir_up. From location pos_2_5 we can reach location pos_3_5 by moving towards direction dir_right. From location pos_2_5 we can reach location pos_2_6 by moving towards direction dir_down.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1883573454799865443", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "At position pos_5_4 is stone_03 initially. We can move from location pos_2_4 to location pos_2_5 by moving towards direction dir_down. Stone stone_02 has to be positioned in a goal location. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_3_2, pos_3_3, pos_3_4, pos_3_5. The initial position of stone_01 is pos_4_2. The following are goal locations where the stones must be placed: pos_4_5, pos_6_2, pos_6_4. Initially, player_01 is located at position pos_4_3. Initially, stone_02 is located at position pos_5_3. Starting at location pos_2_4, to reach location pos_3_4 move in direction dir_right. There is/are eight amount of allowed step/s. The stone stone_01 should be placed in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. To travel from location pos_2_2 to location pos_3_2, move towards direction dir_right. To travel from location pos_2_3 to location pos_2_2, move towards direction dir_up. To move from location pos_2_4 to location pos_2_3, go in direction dir_up. The stone stone_03 should be placed in a goal location. We can move from location pos_2_2 to location pos_2_3 by moving towards direction dir_down. We can move from location pos_2_3 to location pos_2_4 by moving towards direction dir_down. Player player_01 is the sokoban. To travel from location pos_2_3 to location pos_3_3, move towards direction dir_right.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_3_2). clear(pos_3_3). clear(pos_3_4). clear(pos_3_5). isgoal(pos_4_5). isgoal(pos_6_2). isgoal(pos_6_4). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_2_1). isnongoal(pos_2_2). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_4_3). at(stone_01,pos_4_2). at(stone_02,pos_5_3). at(stone_03,pos_5_4). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```At position pos_5_4 is stone_03 initially. We can move from location pos_2_4 to location pos_2_5 by moving towards direction dir_down. Stone stone_02 has to be positioned in a goal location. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_3_2, pos_3_3, pos_3_4, pos_3_5. The initial position of stone_01 is pos_4_2. The following are goal locations where the stones must be placed: pos_4_5, pos_6_2, pos_6_4. Initially, player_01 is located at position pos_4_3. Initially, stone_02 is located at position pos_5_3. Starting at location pos_2_4, to reach location pos_3_4 move in direction dir_right. There is/are eight amount of allowed step/s. The stone stone_01 should be placed in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_2_1, pos_2_2. To travel from location pos_2_2 to location pos_3_2, move towards direction dir_right. To travel from location pos_2_3 to location pos_2_2, move towards direction dir_up. To move from location pos_2_4 to location pos_2_3, go in direction dir_up. The stone stone_03 should be placed in a goal location. We can move from location pos_2_2 to location pos_2_3 by moving towards direction dir_down. We can move from location pos_2_3 to location pos_2_4 by moving towards direction dir_down. Player player_01 is the sokoban. To travel from location pos_2_3 to location pos_3_3, move towards direction dir_right.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4767702459031633353", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "The object player_01 is initially at position pos_04_05. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. By moving in direction dir_right from location pos_01_02, we can arrive at location pos_02_02. Stone stone_01 has to be positioned in a goal location. Player player_01 is the sokoban. Stone stone_02 has to be positioned in a goal location. The following are goal locations where the stones must be placed: pos_04_08, pos_05_08, pos_06_08. Starting at location pos_01_03, to reach location pos_01_04 move in direction dir_down. To move from location pos_01_04 to location pos_01_03, go in direction dir_up. Starting at location pos_01_02, to reach location pos_01_01 move in direction dir_up. The stone stone_03 must be moved to a goal location. We can move from location pos_01_03 to location pos_01_02 by moving towards direction dir_up. The object stone_02 is initially at position pos_05_04. At position pos_04_04 is stone_01 initially. To move from location pos_01_01 to location pos_02_01, go in direction dir_right. At position pos_05_05 is stone_03 initially. There is/are eight amount of allowed step/s. To move from location pos_01_01 to location pos_01_02, go in direction dir_down. The following floor locations are clear of objects: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_02_01, pos_02_02. Starting at location pos_01_02, to reach location pos_01_03 move in direction dir_down.", "output": "clear(pos_01_01). clear(pos_01_02). clear(pos_01_03). clear(pos_01_04). clear(pos_01_05). clear(pos_01_06). clear(pos_02_01). clear(pos_02_02). isgoal(pos_04_08). isgoal(pos_05_08). isgoal(pos_06_08). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_04_05). at(stone_01,pos_04_04). at(stone_02,pos_05_04). at(stone_03,pos_05_05). goal(stone_01). goal(stone_02). goal(stone_03). movedir(pos_01_01,pos_01_02,dir_down). movedir(pos_01_01,pos_02_01,dir_right). movedir(pos_01_02,pos_01_01,dir_up). movedir(pos_01_02,pos_01_03,dir_down). movedir(pos_01_02,pos_02_02,dir_right). movedir(pos_01_03,pos_01_02,dir_up). movedir(pos_01_03,pos_01_04,dir_down). movedir(pos_01_04,pos_01_03,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```The object player_01 is initially at position pos_04_05. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. By moving in direction dir_right from location pos_01_02, we can arrive at location pos_02_02. Stone stone_01 has to be positioned in a goal location. Player player_01 is the sokoban. Stone stone_02 has to be positioned in a goal location. The following are goal locations where the stones must be placed: pos_04_08, pos_05_08, pos_06_08. Starting at location pos_01_03, to reach location pos_01_04 move in direction dir_down. To move from location pos_01_04 to location pos_01_03, go in direction dir_up. Starting at location pos_01_02, to reach location pos_01_01 move in direction dir_up. The stone stone_03 must be moved to a goal location. We can move from location pos_01_03 to location pos_01_02 by moving towards direction dir_up. The object stone_02 is initially at position pos_05_04. At position pos_04_04 is stone_01 initially. To move from location pos_01_01 to location pos_02_01, go in direction dir_right. At position pos_05_05 is stone_03 initially. There is/are eight amount of allowed step/s. To move from location pos_01_01 to location pos_01_02, go in direction dir_down. The following floor locations are clear of objects: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_02_01, pos_02_02. Starting at location pos_01_02, to reach location pos_01_03 move in direction dir_down.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1758448585626471766", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Location pos_2_3 can be reached from location pos_2_4 by moving towards direction dir_up. Location pos_2_3 can be reached from location pos_2_2 by moving towards direction dir_down. player_01 is initially at position pos_5_5. By moving in direction dir_down from location pos_2_3, we can arrive at location pos_2_4. The stone stone_02 must be put in a goal location. To travel from location pos_2_4 to location pos_3_4, move towards direction dir_right. The stone stone_04 must be put in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. To move from location pos_2_2 to location pos_3_2, go in direction dir_right. The initial position of stone_02 is pos_6_3. By moving in direction dir_right from location pos_2_3, we can arrive at location pos_3_3. The object stone_01 is initially at position pos_2_3. To move from location pos_2_3 to location pos_2_2, go in direction dir_up. The initial position of stone_05 is pos_6_5. There is/are eight amount of allowed step/s. Location pos_2_5 can be reached from location pos_2_4 by moving towards direction dir_down. The stone stone_03 should be placed in a goal location. The following floor locations are clear of objects: pos_2_2, pos_2_4, pos_2_5, pos_2_6, pos_3_2, pos_3_3, pos_3_5, pos_3_6. The stone stone_01 must be put in a goal location. Initially, stone_03 is located at position pos_3_4. The initial position of stone_04 is pos_4_5. The stone stone_05 must be put in a goal location. Player player_01 is the sokoban. The following are goal locations where the stones must be placed: pos_2_2, pos_3_2, pos_4_2, pos_5_2, pos_6_2.", "output": "clear(pos_2_2). clear(pos_2_4). clear(pos_2_5). clear(pos_2_6). clear(pos_3_2). clear(pos_3_3). clear(pos_3_5). clear(pos_3_6). isgoal(pos_2_2). isgoal(pos_3_2). isgoal(pos_4_2). isgoal(pos_5_2). isgoal(pos_6_2). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_2_1). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_5_5). at(stone_01,pos_2_3). at(stone_02,pos_6_3). at(stone_03,pos_3_4). at(stone_04,pos_4_5). at(stone_05,pos_6_5). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). goal(stone_05). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Location pos_2_3 can be reached from location pos_2_4 by moving towards direction dir_up. Location pos_2_3 can be reached from location pos_2_2 by moving towards direction dir_down. player_01 is initially at position pos_5_5. By moving in direction dir_down from location pos_2_3, we can arrive at location pos_2_4. The stone stone_02 must be put in a goal location. To travel from location pos_2_4 to location pos_3_4, move towards direction dir_right. The stone stone_04 must be put in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. To move from location pos_2_2 to location pos_3_2, go in direction dir_right. The initial position of stone_02 is pos_6_3. By moving in direction dir_right from location pos_2_3, we can arrive at location pos_3_3. The object stone_01 is initially at position pos_2_3. To move from location pos_2_3 to location pos_2_2, go in direction dir_up. The initial position of stone_05 is pos_6_5. There is/are eight amount of allowed step/s. Location pos_2_5 can be reached from location pos_2_4 by moving towards direction dir_down. The stone stone_03 should be placed in a goal location. The following floor locations are clear of objects: pos_2_2, pos_2_4, pos_2_5, pos_2_6, pos_3_2, pos_3_3, pos_3_5, pos_3_6. The stone stone_01 must be put in a goal location. Initially, stone_03 is located at position pos_3_4. The initial position of stone_04 is pos_4_5. The stone stone_05 must be put in a goal location. Player player_01 is the sokoban. The following are goal locations where the stones must be placed: pos_2_2, pos_3_2, pos_4_2, pos_5_2, pos_6_2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6238369641616294649", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "To travel from location pos_01_08 to location pos_01_07, move towards direction dir_up. Location pos_01_08 can be reached from location pos_01_07 by moving towards direction dir_down. stone_04 is initially at position pos_09_06. The stone stone_03 should be placed in a goal location. From location pos_01_07 we can reach location pos_02_07 by moving towards direction dir_right. The initial position of stone_01 is pos_08_03. We can move from location pos_02_03 to location pos_02_04 by moving towards direction dir_down. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. At position pos_04_04 is player_01 initially. We can move from location pos_02_03 to location pos_02_02 by moving towards direction dir_up. From location pos_01_08 we can reach location pos_02_08 by moving towards direction dir_right. The following floor locations are clear of objects: pos_01_07, pos_01_08, pos_02_02, pos_02_03, pos_02_04, pos_02_05, pos_02_07, pos_02_08. The stone stone_02 must be moved to a goal location. Initially, stone_02 is located at position pos_09_03. The initial position of stone_03 is pos_09_05. The following are goal locations where the stones must be placed: pos_02_02, pos_03_02, pos_04_02, pos_05_02. Player player_01 is the sokoban. The stone stone_01 must be moved to a goal location. Starting at location pos_02_02, to reach location pos_03_02 move in direction dir_right. The stone stone_04 must be moved to a goal location. Starting at location pos_02_02, to reach location pos_02_03 move in direction dir_down. There is/are eight amount of allowed step/s.", "output": "clear(pos_01_07). clear(pos_01_08). clear(pos_02_02). clear(pos_02_03). clear(pos_02_04). clear(pos_02_05). clear(pos_02_07). clear(pos_02_08). isgoal(pos_02_02). isgoal(pos_03_02). isgoal(pos_04_02). isgoal(pos_05_02). isnongoal(pos_01_01). isnongoal(pos_01_02). isnongoal(pos_01_03). isnongoal(pos_01_04). isnongoal(pos_01_05). isnongoal(pos_01_06). isnongoal(pos_01_07). isnongoal(pos_01_08). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_04_04). at(stone_01,pos_08_03). at(stone_02,pos_09_03). at(stone_03,pos_09_05). at(stone_04,pos_09_06). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_01_07,pos_01_08,dir_down). movedir(pos_01_07,pos_02_07,dir_right). movedir(pos_01_08,pos_01_07,dir_up). movedir(pos_01_08,pos_02_08,dir_right). movedir(pos_02_02,pos_02_03,dir_down). movedir(pos_02_02,pos_03_02,dir_right). movedir(pos_02_03,pos_02_02,dir_up). movedir(pos_02_03,pos_02_04,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```To travel from location pos_01_08 to location pos_01_07, move towards direction dir_up. Location pos_01_08 can be reached from location pos_01_07 by moving towards direction dir_down. stone_04 is initially at position pos_09_06. The stone stone_03 should be placed in a goal location. From location pos_01_07 we can reach location pos_02_07 by moving towards direction dir_right. The initial position of stone_01 is pos_08_03. We can move from location pos_02_03 to location pos_02_04 by moving towards direction dir_down. The following are not goal locations: pos_01_01, pos_01_02, pos_01_03, pos_01_04, pos_01_05, pos_01_06, pos_01_07, pos_01_08. At position pos_04_04 is player_01 initially. We can move from location pos_02_03 to location pos_02_02 by moving towards direction dir_up. From location pos_01_08 we can reach location pos_02_08 by moving towards direction dir_right. The following floor locations are clear of objects: pos_01_07, pos_01_08, pos_02_02, pos_02_03, pos_02_04, pos_02_05, pos_02_07, pos_02_08. The stone stone_02 must be moved to a goal location. Initially, stone_02 is located at position pos_09_03. The initial position of stone_03 is pos_09_05. The following are goal locations where the stones must be placed: pos_02_02, pos_03_02, pos_04_02, pos_05_02. Player player_01 is the sokoban. The stone stone_01 must be moved to a goal location. Starting at location pos_02_02, to reach location pos_03_02 move in direction dir_right. The stone stone_04 must be moved to a goal location. Starting at location pos_02_02, to reach location pos_02_03 move in direction dir_down. There is/are eight amount of allowed step/s.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3123594371161708659", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "To move from location pos_2_4 to location pos_2_3, go in direction dir_up. By moving in direction dir_up from location pos_2_5, we can arrive at location pos_2_4. The stone stone_03 must be moved to a goal location. To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. Stone stone_02 has to be positioned in a goal location. The stone stone_04 must be put in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_3_2, pos_3_5, pos_3_6, pos_4_2. We can move from location pos_2_4 to location pos_3_4 by moving towards direction dir_right. The following are goal locations where the stones must be placed: pos_2_2, pos_2_6, pos_6_2, pos_6_6. The initial position of player_01 is pos_2_4. Stone stone_01 has to be positioned in a goal location. Initially, stone_01 is located at position pos_5_3. There is/are eight amount of allowed step/s. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. To move from location pos_2_2 to location pos_2_3, go in direction dir_down. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up. stone_04 is initially at position pos_5_5. Player player_01 is the sokoban. Initially, stone_03 is located at position pos_4_4. To travel from location pos_2_4 to location pos_2_5, move towards direction dir_down. At position pos_3_4 is stone_02 initially.", "output": "clear(pos_2_2). clear(pos_2_3). clear(pos_2_5). clear(pos_2_6). clear(pos_3_2). clear(pos_3_5). clear(pos_3_6). clear(pos_4_2). isgoal(pos_2_2). isgoal(pos_2_6). isgoal(pos_6_2). isgoal(pos_6_6). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_2_1). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_2_4). at(stone_01,pos_5_3). at(stone_02,pos_3_4). at(stone_03,pos_4_4). at(stone_04,pos_5_5). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_4,pos_3_4,dir_right). movedir(pos_2_5,pos_2_4,dir_up). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```To move from location pos_2_4 to location pos_2_3, go in direction dir_up. By moving in direction dir_up from location pos_2_5, we can arrive at location pos_2_4. The stone stone_03 must be moved to a goal location. To travel from location pos_2_3 to location pos_2_4, move towards direction dir_down. Stone stone_02 has to be positioned in a goal location. The stone stone_04 must be put in a goal location. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_2_1. The following floor locations are clear of objects: pos_2_2, pos_2_3, pos_2_5, pos_2_6, pos_3_2, pos_3_5, pos_3_6, pos_4_2. We can move from location pos_2_4 to location pos_3_4 by moving towards direction dir_right. The following are goal locations where the stones must be placed: pos_2_2, pos_2_6, pos_6_2, pos_6_6. The initial position of player_01 is pos_2_4. Stone stone_01 has to be positioned in a goal location. Initially, stone_01 is located at position pos_5_3. There is/are eight amount of allowed step/s. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. To move from location pos_2_2 to location pos_2_3, go in direction dir_down. From location pos_2_3 we can reach location pos_2_2 by moving towards direction dir_up. stone_04 is initially at position pos_5_5. Player player_01 is the sokoban. Initially, stone_03 is located at position pos_4_4. To travel from location pos_2_4 to location pos_2_5, move towards direction dir_down. At position pos_3_4 is stone_02 initially.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1270541915846736969", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Location pos_3_3 can be reached from location pos_2_3 by moving towards direction dir_right. To move from location pos_2_2 to location pos_2_3, go in direction dir_down. The initial position of stone_04 is pos_3_6. Player player_01 is the sokoban. There is/are eight amount of allowed step/s. To move from location pos_2_4 to location pos_2_5, go in direction dir_down. The object stone_01 is initially at position pos_3_3. The following are goal locations where the stones must be placed: pos_4_4, pos_4_5, pos_4_6, pos_4_7. The following floor locations are clear of objects: pos_1_8, pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_2_6, pos_2_8, pos_4_4. Stone stone_04 has to be positioned in a goal location. At position pos_3_4 is stone_02 initially. Stone stone_02 has to be positioned in a goal location. At position pos_3_5 is stone_03 initially. To travel from location pos_2_4 to location pos_2_3, move towards direction dir_up. player_01 is initially at position pos_3_2. The stone stone_03 must be put in a goal location. To move from location pos_1_8 to location pos_2_8, go in direction dir_right. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. The stone stone_01 must be put in a goal location. Location pos_2_4 can be reached from location pos_2_3 by moving towards direction dir_down. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. Starting at location pos_2_3, to reach location pos_2_2 move in direction dir_up.", "output": "clear(pos_1_8). clear(pos_2_2). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_2_6). clear(pos_2_8). clear(pos_4_4). isgoal(pos_4_4). isgoal(pos_4_5). isgoal(pos_4_6). isgoal(pos_4_7). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_1_8). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_3_2). at(stone_01,pos_3_3). at(stone_02,pos_3_4). at(stone_03,pos_3_5). at(stone_04,pos_3_6). goal(stone_01). goal(stone_02). goal(stone_03). goal(stone_04). movedir(pos_1_8,pos_2_8,dir_right). movedir(pos_2_2,pos_2_3,dir_down). movedir(pos_2_2,pos_3_2,dir_right). movedir(pos_2_3,pos_2_2,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Location pos_3_3 can be reached from location pos_2_3 by moving towards direction dir_right. To move from location pos_2_2 to location pos_2_3, go in direction dir_down. The initial position of stone_04 is pos_3_6. Player player_01 is the sokoban. There is/are eight amount of allowed step/s. To move from location pos_2_4 to location pos_2_5, go in direction dir_down. The object stone_01 is initially at position pos_3_3. The following are goal locations where the stones must be placed: pos_4_4, pos_4_5, pos_4_6, pos_4_7. The following floor locations are clear of objects: pos_1_8, pos_2_2, pos_2_3, pos_2_4, pos_2_5, pos_2_6, pos_2_8, pos_4_4. Stone stone_04 has to be positioned in a goal location. At position pos_3_4 is stone_02 initially. Stone stone_02 has to be positioned in a goal location. At position pos_3_5 is stone_03 initially. To travel from location pos_2_4 to location pos_2_3, move towards direction dir_up. player_01 is initially at position pos_3_2. The stone stone_03 must be put in a goal location. To move from location pos_1_8 to location pos_2_8, go in direction dir_right. We can move from location pos_2_2 to location pos_3_2 by moving towards direction dir_right. The stone stone_01 must be put in a goal location. Location pos_2_4 can be reached from location pos_2_3 by moving towards direction dir_down. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. Starting at location pos_2_3, to reach location pos_2_2 move in direction dir_up.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4249231079314369573", "problem_id": "45", "problem_name": "Sokoban", "description": "Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.", "format": "In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.", "text": "Initially, player_01 is located at position pos_5_6. stone_01 is initially at position pos_5_4. The stone stone_01 should be placed in a goal location. To move from location pos_2_5 to location pos_2_4, go in direction dir_up. There is/are eight amount of allowed step/s. From location pos_2_4 we can reach location pos_2_3 by moving towards direction dir_up. To travel from location pos_1_8 to location pos_1_7, move towards direction dir_up. Player player_01 is the sokoban. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. We can move from location pos_2_5 to location pos_3_5 by moving towards direction dir_right. The following are goal locations where the stones must be placed: pos_4_5, pos_6_5. The following floor locations are clear of objects: pos_1_1, pos_1_7, pos_1_8, pos_2_3, pos_2_4, pos_2_5, pos_3_2, pos_3_3. By moving in direction dir_down from location pos_1_7, we can arrive at location pos_1_8. Stone stone_02 has to be positioned in a goal location. To travel from location pos_2_3 to location pos_3_3, move towards direction dir_right. Location pos_2_4 can be reached from location pos_2_3 by moving towards direction dir_down. Location pos_2_5 can be reached from location pos_2_4 by moving towards direction dir_down. The object stone_02 is initially at position pos_4_5.", "output": "clear(pos_1_1). clear(pos_1_7). clear(pos_1_8). clear(pos_2_3). clear(pos_2_4). clear(pos_2_5). clear(pos_3_2). clear(pos_3_3). isgoal(pos_4_5). isgoal(pos_6_5). isnongoal(pos_1_1). isnongoal(pos_1_2). isnongoal(pos_1_3). isnongoal(pos_1_4). isnongoal(pos_1_5). isnongoal(pos_1_6). isnongoal(pos_1_7). isnongoal(pos_1_8). step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8). at(player_01,pos_5_6). at(stone_01,pos_5_4). at(stone_02,pos_4_5). goal(stone_01). goal(stone_02). movedir(pos_1_7,pos_1_8,dir_down). movedir(pos_1_8,pos_1_7,dir_up). movedir(pos_2_3,pos_2_4,dir_down). movedir(pos_2_3,pos_3_3,dir_right). movedir(pos_2_4,pos_2_3,dir_up). movedir(pos_2_4,pos_2_5,dir_down). movedir(pos_2_5,pos_2_4,dir_up). movedir(pos_2_5,pos_3_5,dir_right). player(player_01).", "prompt": "Given the following problem description between triple backtips: \n ```Sokoban is a classic problem which appeared so far in all the ASP Competitions. This year the problem specifications were adapted in order to adhere to the specifications of the homologous problem used at IPC 2011 and 2008, in order to achieve a clearer comparative picture between planners and ASP solvers.\nSokoban is a game puzzle developed by the Japanese company Thinking Rabbit, Inc. in 1982. 'Sokoban' means 'warehouse-keeper' in Japanese. Each puzzle consists of a room layout (a number of square fields representing walls or parts of the floor, some of which are marked as storage space) and a starting situation (one sokoban and a number of boxes, all of which must reside on some floor location, where one box occupies precisely one location and each location can hold at most one box). The goal is to move all boxes onto storage locations. To this end, the sokoban can walk on floor locations (unless occupied by some box), and push single boxes onto unoccupied floor locations.\nIn the decision version of this problem, the question to answer is whether a solution involving at most N actions exists, for N given as input. If so, a witness containing the sequence of actions should be produced; otherwise no solution should be output.```\nGiven the following specification for the predicates format: \n```In our setting, an instance contains the warehouse layout, representing the floor locations, and in particular their horizontal and vertical relationships; storage locations, where the boxes should eventually go to; and, initial positions of stones and the sokoban. This information is encoded as facts using predicates movedir/3, goal/1, stone/1, isgoal/2, player/1, at/2, clear/2 as follows:\n\nmovedir(x,y,dir): y is a location reachable by location x by moving towards direction dir, where dir can be one of 'dir_up','dir_down','dir_left','dir_right'.\n\ngoal(s): the stone s must be put in a goal location stone(s): s is a stone isgoal(l): l is a goal location isnongoal(l): l is not a goal location. This information can be obtained by complehementing information given by isgoal, but it has been retained for compatibility with the IPC 2011 domain description. player(p): p is the sokoban. at(o,p): the object o (either the sokoban or a stone) is initially at position p. clear(p): the floor location p is clear of objects.\n\nEach instance has exactly one fact for player/1. There can be in principle non-goal stones (i.e. there can be s such that stone(s) holds, but not goal(s)).\n\nAn instance also contains a sequence of time-steps for warehouse configurations, between which the actions occur:\n\nstep(s): s is an allowed step. It can be assumed steps are consecutive integers ranging from 1 towards a limit value N. Steps are associated to actions. It's up to problem modeller's how to treat properly the presence of N+1 intermediate states.```\nExtract the datalog facts from this text: \n```Initially, player_01 is located at position pos_5_6. stone_01 is initially at position pos_5_4. The stone stone_01 should be placed in a goal location. To move from location pos_2_5 to location pos_2_4, go in direction dir_up. There is/are eight amount of allowed step/s. From location pos_2_4 we can reach location pos_2_3 by moving towards direction dir_up. To travel from location pos_1_8 to location pos_1_7, move towards direction dir_up. Player player_01 is the sokoban. The following are not goal locations: pos_1_1, pos_1_2, pos_1_3, pos_1_4, pos_1_5, pos_1_6, pos_1_7, pos_1_8. We can move from location pos_2_5 to location pos_3_5 by moving towards direction dir_right. The following are goal locations where the stones must be placed: pos_4_5, pos_6_5. The following floor locations are clear of objects: pos_1_1, pos_1_7, pos_1_8, pos_2_3, pos_2_4, pos_2_5, pos_3_2, pos_3_3. By moving in direction dir_down from location pos_1_7, we can arrive at location pos_1_8. Stone stone_02 has to be positioned in a goal location. To travel from location pos_2_3 to location pos_3_3, move towards direction dir_right. Location pos_2_4 can be reached from location pos_2_3 by moving towards direction dir_down. Location pos_2_5 can be reached from location pos_2_4 by moving towards direction dir_down. The object stone_02 is initially at position pos_4_5.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "22903256911837303", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m105 received a rating of ninety-seven from the woman w1. The man m1 has rated the woman w10 with a score of fifty-nine. The man m104 got a rating of fourteen from the woman w1. The man m1 gave the woman w102 a rating of ninety-eight. The woman w1 judged the man m100 with a result of eight. A rating of fifty-six was assigned to the woman w104 by the man m1. The man m10 got a rating of thirty-eight from the woman w1. The man m1 has rated the woman w105 with a score of seventy-six. The man m1 gave the woman w103 a rating of thirty-six. The woman w1 placed the man m1 at a level of twenty-nine. The man m102 got a rating of thirty-four from the woman w1. The woman w100 received a rating of twenty-eight from the man m1. The woman w1 rated the man m101 with a figure of seventy. The woman w1 judged the man m103 with a result of ninety-six. The man m1 has ranked the woman w101 with a score of thirty-three. The man m1 ranked the woman w1 with a value of eighty-three.", "output": "manAssignsScore(m1,w1,83). manAssignsScore(m1,w10,59). manAssignsScore(m1,w100,28). manAssignsScore(m1,w101,33). manAssignsScore(m1,w102,98). manAssignsScore(m1,w103,36). manAssignsScore(m1,w104,56). manAssignsScore(m1,w105,76). womanAssignsScore(w1,m1,29). womanAssignsScore(w1,m10,38). womanAssignsScore(w1,m100,8). womanAssignsScore(w1,m101,70). womanAssignsScore(w1,m102,34). womanAssignsScore(w1,m103,96). womanAssignsScore(w1,m104,14). womanAssignsScore(w1,m105,97).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m105 received a rating of ninety-seven from the woman w1. The man m1 has rated the woman w10 with a score of fifty-nine. The man m104 got a rating of fourteen from the woman w1. The man m1 gave the woman w102 a rating of ninety-eight. The woman w1 judged the man m100 with a result of eight. A rating of fifty-six was assigned to the woman w104 by the man m1. The man m10 got a rating of thirty-eight from the woman w1. The man m1 has rated the woman w105 with a score of seventy-six. The man m1 gave the woman w103 a rating of thirty-six. The woman w1 placed the man m1 at a level of twenty-nine. The man m102 got a rating of thirty-four from the woman w1. The woman w100 received a rating of twenty-eight from the man m1. The woman w1 rated the man m101 with a figure of seventy. The woman w1 judged the man m103 with a result of ninety-six. The man m1 has ranked the woman w101 with a score of thirty-three. The man m1 ranked the woman w1 with a value of eighty-three.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5253518857958205808", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m10 received a rating of eighty from the woman w1. The woman w1 ranked the man m102 with a value of sixty-one. The man m1 ranked the woman w102 with a value of sixty-four. The man m1 ranked the woman w1 with a value of forty-five. The woman w1 judged the man m101 with a result of four. The man m1 gave the woman w100 a score of eighty-seven. A rating of one was assigned to the woman w104 by the man m1. The woman w103 was given a rating of eighty-six by the man m1. The man m1 ranked the woman w105 with a value of fifty-two. The woman w101 received a rating of eleven from the man m1. The woman w1 judged the man m100 with a result of three. The man m1 has rated the woman w10 with a score of sixty-six. The woman w1 placed the man m103 at a level of thirty-nine. The woman w1 placed the man m1 at a level of thirty. A rating of fifty-six was assigned to the man m104 by the woman w1. The man m105 received a rating of ninety-one from the woman w1.", "output": "manAssignsScore(m1,w1,45). manAssignsScore(m1,w10,66). manAssignsScore(m1,w100,87). manAssignsScore(m1,w101,11). manAssignsScore(m1,w102,64). manAssignsScore(m1,w103,86). manAssignsScore(m1,w104,1). manAssignsScore(m1,w105,52). womanAssignsScore(w1,m1,30). womanAssignsScore(w1,m10,80). womanAssignsScore(w1,m100,3). womanAssignsScore(w1,m101,4). womanAssignsScore(w1,m102,61). womanAssignsScore(w1,m103,39). womanAssignsScore(w1,m104,56). womanAssignsScore(w1,m105,91).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m10 received a rating of eighty from the woman w1. The woman w1 ranked the man m102 with a value of sixty-one. The man m1 ranked the woman w102 with a value of sixty-four. The man m1 ranked the woman w1 with a value of forty-five. The woman w1 judged the man m101 with a result of four. The man m1 gave the woman w100 a score of eighty-seven. A rating of one was assigned to the woman w104 by the man m1. The woman w103 was given a rating of eighty-six by the man m1. The man m1 ranked the woman w105 with a value of fifty-two. The woman w101 received a rating of eleven from the man m1. The woman w1 judged the man m100 with a result of three. The man m1 has rated the woman w10 with a score of sixty-six. The woman w1 placed the man m103 at a level of thirty-nine. The woman w1 placed the man m1 at a level of thirty. A rating of fifty-six was assigned to the man m104 by the woman w1. The man m105 received a rating of ninety-one from the woman w1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4306979946651431262", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 gave the woman w104 a score of ninety-five. The woman w1 assigned a value of m10 to the man eight. The woman w1 placed the man m101 at a level of eighty-nine. The woman w1 ranked the man m1 with a value of eighty-seven. The woman w105 was given a rating of seventy-six by the man m1. The woman w1 judged the man m102 with a result of seventy-one. The woman w1 assigned a value of m103 to the man six. A rating of fifty-three was assigned to the man m100 by the woman w1. The woman w1 placed the man m105 at a level of ninety-six. The man m1 has rated the woman w101 with a score of sixty-eight. The woman w103 received a rating of fifty-six from the man m1. The woman w10 received a rating of fifty-five from the man m1. The woman w100 received a rating of seventy-two from the man m1. The woman w102 was given a rating of fifty-five by the man m1. The man m1 has rated the woman w1 with a score of nine. The woman w1 placed the man m104 at a level of seventy-three.", "output": "manAssignsScore(m1,w1,9). manAssignsScore(m1,w10,55). manAssignsScore(m1,w100,72). manAssignsScore(m1,w101,68). manAssignsScore(m1,w102,55). manAssignsScore(m1,w103,56). manAssignsScore(m1,w104,95). manAssignsScore(m1,w105,76). womanAssignsScore(w1,m1,87). womanAssignsScore(w1,m10,8). womanAssignsScore(w1,m100,53). womanAssignsScore(w1,m101,89). womanAssignsScore(w1,m102,71). womanAssignsScore(w1,m103,6). womanAssignsScore(w1,m104,73). womanAssignsScore(w1,m105,96).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 gave the woman w104 a score of ninety-five. The woman w1 assigned a value of m10 to the man eight. The woman w1 placed the man m101 at a level of eighty-nine. The woman w1 ranked the man m1 with a value of eighty-seven. The woman w105 was given a rating of seventy-six by the man m1. The woman w1 judged the man m102 with a result of seventy-one. The woman w1 assigned a value of m103 to the man six. A rating of fifty-three was assigned to the man m100 by the woman w1. The woman w1 placed the man m105 at a level of ninety-six. The man m1 has rated the woman w101 with a score of sixty-eight. The woman w103 received a rating of fifty-six from the man m1. The woman w10 received a rating of fifty-five from the man m1. The woman w100 received a rating of seventy-two from the man m1. The woman w102 was given a rating of fifty-five by the man m1. The man m1 has rated the woman w1 with a score of nine. The woman w1 placed the man m104 at a level of seventy-three.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8949913547797294765", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 ranked the man m104 with a value of thirty-nine. The woman w1 assigned a value of m101 to the man thirty-four. The man m1 ranked the woman w100 with a value of twenty-one. A rating of thirty was assigned to the man m100 by the woman w1. The man m1 ranked the woman w103 with a value of twenty. The woman w1 placed the man m1 at a level of sixty. The woman w1 judged the man m10 with a result of fifty-nine. The man m105 received a rating of seventy from the woman w1. The man m1 ranked the woman w102 with a value of seventy. The man m1 has ranked the woman w1 with a score of fifty-seven. A rating of seventy-three was assigned to the woman w105 by the man m1. The man m1 has rated the woman w104 with a score of fifty. The woman w1 ranked the man m102 with a value of twenty-two. The man m1 gave the woman w10 a rating of twenty-two. The woman w101 received a rating of forty-eight from the man m1. The woman w1 assigned a value of m103 to the man twelve.", "output": "manAssignsScore(m1,w1,57). manAssignsScore(m1,w10,22). manAssignsScore(m1,w100,21). manAssignsScore(m1,w101,48). manAssignsScore(m1,w102,70). manAssignsScore(m1,w103,20). manAssignsScore(m1,w104,50). manAssignsScore(m1,w105,73). womanAssignsScore(w1,m1,60). womanAssignsScore(w1,m10,59). womanAssignsScore(w1,m100,30). womanAssignsScore(w1,m101,34). womanAssignsScore(w1,m102,22). womanAssignsScore(w1,m103,12). womanAssignsScore(w1,m104,39). womanAssignsScore(w1,m105,70).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 ranked the man m104 with a value of thirty-nine. The woman w1 assigned a value of m101 to the man thirty-four. The man m1 ranked the woman w100 with a value of twenty-one. A rating of thirty was assigned to the man m100 by the woman w1. The man m1 ranked the woman w103 with a value of twenty. The woman w1 placed the man m1 at a level of sixty. The woman w1 judged the man m10 with a result of fifty-nine. The man m105 received a rating of seventy from the woman w1. The man m1 ranked the woman w102 with a value of seventy. The man m1 has ranked the woman w1 with a score of fifty-seven. A rating of seventy-three was assigned to the woman w105 by the man m1. The man m1 has rated the woman w104 with a score of fifty. The woman w1 ranked the man m102 with a value of twenty-two. The man m1 gave the woman w10 a rating of twenty-two. The woman w101 received a rating of forty-eight from the man m1. The woman w1 assigned a value of m103 to the man twelve.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7810090304943886615", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w104 received a rating of seventy-two from the man m1. The woman w1 ranked the man m104 with a value of seventy-three. The man m1 has rated the woman w100 with a score of eighty-seven. The man m105 received a rating of seventeen from the woman w1. The man m1 gave the woman w1 a score of ninety. A rating of eighteen was assigned to the man m1 by the woman w1. The man m101 received a rating of fifty from the woman w1. The man m1 has ranked the woman w10 with a score of sixty. The woman w1 assigned a value of m103 to the man ninety. The woman w1 judged the man m10 with a result of seventy-eight. The woman w101 was given a rating of thirty-eight by the man m1. The man m1 ranked the woman w103 with a value of ninety-eight. The woman w1 assigned a value of m102 to the man ninety-three. The woman w1 judged the man m100 with a result of twenty-three. The woman w102 was given a rating of ninety-two by the man m1. A rating of thirty-four was assigned to the woman w105 by the man m1.", "output": "manAssignsScore(m1,w1,90). manAssignsScore(m1,w10,60). manAssignsScore(m1,w100,87). manAssignsScore(m1,w101,38). manAssignsScore(m1,w102,92). manAssignsScore(m1,w103,98). manAssignsScore(m1,w104,72). manAssignsScore(m1,w105,34). womanAssignsScore(w1,m1,18). womanAssignsScore(w1,m10,78). womanAssignsScore(w1,m100,23). womanAssignsScore(w1,m101,50). womanAssignsScore(w1,m102,93). womanAssignsScore(w1,m103,90). womanAssignsScore(w1,m104,73). womanAssignsScore(w1,m105,17).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w104 received a rating of seventy-two from the man m1. The woman w1 ranked the man m104 with a value of seventy-three. The man m1 has rated the woman w100 with a score of eighty-seven. The man m105 received a rating of seventeen from the woman w1. The man m1 gave the woman w1 a score of ninety. A rating of eighteen was assigned to the man m1 by the woman w1. The man m101 received a rating of fifty from the woman w1. The man m1 has ranked the woman w10 with a score of sixty. The woman w1 assigned a value of m103 to the man ninety. The woman w1 judged the man m10 with a result of seventy-eight. The woman w101 was given a rating of thirty-eight by the man m1. The man m1 ranked the woman w103 with a value of ninety-eight. The woman w1 assigned a value of m102 to the man ninety-three. The woman w1 judged the man m100 with a result of twenty-three. The woman w102 was given a rating of ninety-two by the man m1. A rating of thirty-four was assigned to the woman w105 by the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6577284639761619027", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 placed the man m101 at a level of forty-two. The man m1 gave the woman w102 a rating of ten. The woman w1 judged the man m104 with a result of one. The man m1 gave the woman w104 a score of sixty-six. The woman w1 rated the man m105 with a figure of twenty-nine. A rating of thirty-three was assigned to the woman w100 by the man m1. The woman w1 ranked the man m103 with a value of five. The woman w1 placed the man m102 at a level of forty-four. The man m1 has ranked the woman w105 with a score of forty-six. The man m1 gave the woman w101 a score of seventy-one. The man m1 has ranked the woman w10 with a score of thirty-three. The man m1 ranked the woman w103 with a value of forty-one. The woman w1 judged the man m10 with a result of twenty-nine. A rating of forty was assigned to the man m1 by the woman w1. The man m100 received a rating of two from the woman w1. A rating of eleven was assigned to the woman w1 by the man m1.", "output": "manAssignsScore(m1,w1,11). manAssignsScore(m1,w10,33). manAssignsScore(m1,w100,33). manAssignsScore(m1,w101,71). manAssignsScore(m1,w102,10). manAssignsScore(m1,w103,41). manAssignsScore(m1,w104,66). manAssignsScore(m1,w105,46). womanAssignsScore(w1,m1,40). womanAssignsScore(w1,m10,29). womanAssignsScore(w1,m100,2). womanAssignsScore(w1,m101,42). womanAssignsScore(w1,m102,44). womanAssignsScore(w1,m103,5). womanAssignsScore(w1,m104,1). womanAssignsScore(w1,m105,29).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 placed the man m101 at a level of forty-two. The man m1 gave the woman w102 a rating of ten. The woman w1 judged the man m104 with a result of one. The man m1 gave the woman w104 a score of sixty-six. The woman w1 rated the man m105 with a figure of twenty-nine. A rating of thirty-three was assigned to the woman w100 by the man m1. The woman w1 ranked the man m103 with a value of five. The woman w1 placed the man m102 at a level of forty-four. The man m1 has ranked the woman w105 with a score of forty-six. The man m1 gave the woman w101 a score of seventy-one. The man m1 has ranked the woman w10 with a score of thirty-three. The man m1 ranked the woman w103 with a value of forty-one. The woman w1 judged the man m10 with a result of twenty-nine. A rating of forty was assigned to the man m1 by the woman w1. The man m100 received a rating of two from the woman w1. A rating of eleven was assigned to the woman w1 by the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6702955049624653677", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m103 received a rating of sixty-five from the woman w1. The woman w1 ranked the man m102 with a value of eighteen. The woman w105 received a rating of thirty-four from the man m1. The woman w1 rated the man m104 with a figure of eighty-nine. A rating of ninety was assigned to the woman w101 by the man m1. The man m1 gave the woman w10 a rating of eighty-three. The man m1 ranked the woman w100 with a value of seven. The woman w1 ranked the man m105 with a value of sixty. The man m1 received a rating of forty-two from the woman w1. The woman w1 judged the man m10 with a result of forty-two. The woman w1 ranked the man m100 with a value of eighty-six. The man m1 has ranked the woman w102 with a score of fifty. The man m1 ranked the woman w1 with a value of seventy-five. The man m1 gave the woman w103 a score of ninety-three. The man m1 gave the woman w104 a score of forty-two. The woman w1 placed the man m101 at a level of twenty-one.", "output": "manAssignsScore(m1,w1,75). manAssignsScore(m1,w10,83). manAssignsScore(m1,w100,7). manAssignsScore(m1,w101,90). manAssignsScore(m1,w102,50). manAssignsScore(m1,w103,93). manAssignsScore(m1,w104,42). manAssignsScore(m1,w105,34). womanAssignsScore(w1,m1,42). womanAssignsScore(w1,m10,42). womanAssignsScore(w1,m100,86). womanAssignsScore(w1,m101,21). womanAssignsScore(w1,m102,18). womanAssignsScore(w1,m103,65). womanAssignsScore(w1,m104,89). womanAssignsScore(w1,m105,60).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m103 received a rating of sixty-five from the woman w1. The woman w1 ranked the man m102 with a value of eighteen. The woman w105 received a rating of thirty-four from the man m1. The woman w1 rated the man m104 with a figure of eighty-nine. A rating of ninety was assigned to the woman w101 by the man m1. The man m1 gave the woman w10 a rating of eighty-three. The man m1 ranked the woman w100 with a value of seven. The woman w1 ranked the man m105 with a value of sixty. The man m1 received a rating of forty-two from the woman w1. The woman w1 judged the man m10 with a result of forty-two. The woman w1 ranked the man m100 with a value of eighty-six. The man m1 has ranked the woman w102 with a score of fifty. The man m1 ranked the woman w1 with a value of seventy-five. The man m1 gave the woman w103 a score of ninety-three. The man m1 gave the woman w104 a score of forty-two. The woman w1 placed the man m101 at a level of twenty-one.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9080873301750124668", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w101 was given a rating of thirty-five by the man m1. The man m102 received a rating of fifty-three from the woman w1. The man m1 gave the woman w102 a rating of sixty-nine. The woman w104 received a rating of seventy from the man m1. The woman w105 was given a rating of seventy-one by the man m1. The man m1 gave the woman w1 a rating of sixty. The man m1 received a rating of sixty-three from the woman w1. The woman w1 rated the man m101 with a figure of fifty-one. The woman w1 assigned a value of m103 to the man seventy-nine. The woman w1 ranked the man m100 with a value of ninety-two. A rating of nine was assigned to the woman w10 by the man m1. The woman w103 received a rating of thirteen from the man m1. The woman w1 rated the man m105 with a figure of eighty-three. A rating of seventy-six was assigned to the man m10 by the woman w1. The woman w1 assigned a value of m104 to the man fifty-three. The man m1 gave the woman w100 a score of eighty-eight.", "output": "manAssignsScore(m1,w1,60). manAssignsScore(m1,w10,9). manAssignsScore(m1,w100,88). manAssignsScore(m1,w101,35). manAssignsScore(m1,w102,69). manAssignsScore(m1,w103,13). manAssignsScore(m1,w104,70). manAssignsScore(m1,w105,71). womanAssignsScore(w1,m1,63). womanAssignsScore(w1,m10,76). womanAssignsScore(w1,m100,92). womanAssignsScore(w1,m101,51). womanAssignsScore(w1,m102,53). womanAssignsScore(w1,m103,79). womanAssignsScore(w1,m104,53). womanAssignsScore(w1,m105,83).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w101 was given a rating of thirty-five by the man m1. The man m102 received a rating of fifty-three from the woman w1. The man m1 gave the woman w102 a rating of sixty-nine. The woman w104 received a rating of seventy from the man m1. The woman w105 was given a rating of seventy-one by the man m1. The man m1 gave the woman w1 a rating of sixty. The man m1 received a rating of sixty-three from the woman w1. The woman w1 rated the man m101 with a figure of fifty-one. The woman w1 assigned a value of m103 to the man seventy-nine. The woman w1 ranked the man m100 with a value of ninety-two. A rating of nine was assigned to the woman w10 by the man m1. The woman w103 received a rating of thirteen from the man m1. The woman w1 rated the man m105 with a figure of eighty-three. A rating of seventy-six was assigned to the man m10 by the woman w1. The woman w1 assigned a value of m104 to the man fifty-three. The man m1 gave the woman w100 a score of eighty-eight.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5114589702197923304", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "A rating of twenty-one was assigned to the woman w103 by the man m1. The woman w10 received a rating of ninety-seven from the man m1. A rating of thirty-four was assigned to the man m1 by the woman w1. The woman w1 ranked the man m105 with a value of forty-five. The woman w1 assigned a value of m10 to the man forty-one. The woman w100 was given a rating of one hundred by the man m1. The woman w1 judged the man m100 with a result of sixty. The man m102 received a rating of twenty-three from the woman w1. The woman w1 placed the man m104 at a level of forty-three. The woman w102 was given a rating of twenty by the man m1. The woman w1 received a rating of forty-six from the man m1. The woman w1 rated the man m101 with a figure of eighty-three. The man m1 gave the woman w101 a rating of forty-six. The man m1 has rated the woman w104 with a score of sixty-seven. The woman w1 judged the man m103 with a result of sixty-five. The man m1 gave the woman w105 a rating of sixty-six.", "output": "manAssignsScore(m1,w1,46). manAssignsScore(m1,w10,97). manAssignsScore(m1,w100,100). manAssignsScore(m1,w101,46). manAssignsScore(m1,w102,20). manAssignsScore(m1,w103,21). manAssignsScore(m1,w104,67). manAssignsScore(m1,w105,66). womanAssignsScore(w1,m1,34). womanAssignsScore(w1,m10,41). womanAssignsScore(w1,m100,60). womanAssignsScore(w1,m101,83). womanAssignsScore(w1,m102,23). womanAssignsScore(w1,m103,65). womanAssignsScore(w1,m104,43). womanAssignsScore(w1,m105,45).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```A rating of twenty-one was assigned to the woman w103 by the man m1. The woman w10 received a rating of ninety-seven from the man m1. A rating of thirty-four was assigned to the man m1 by the woman w1. The woman w1 ranked the man m105 with a value of forty-five. The woman w1 assigned a value of m10 to the man forty-one. The woman w100 was given a rating of one hundred by the man m1. The woman w1 judged the man m100 with a result of sixty. The man m102 received a rating of twenty-three from the woman w1. The woman w1 placed the man m104 at a level of forty-three. The woman w102 was given a rating of twenty by the man m1. The woman w1 received a rating of forty-six from the man m1. The woman w1 rated the man m101 with a figure of eighty-three. The man m1 gave the woman w101 a rating of forty-six. The man m1 has rated the woman w104 with a score of sixty-seven. The woman w1 judged the man m103 with a result of sixty-five. The man m1 gave the woman w105 a rating of sixty-six.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2721326310037292432", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 judged the man m100 with a result of twelve. The woman w104 was given a rating of forty-eight by the man m1. The man m103 got a rating of eighty-one from the woman w1. The man m1 gave the woman w100 a rating of eighty-one. The woman w105 was given a rating of fifty-eight by the man m1. The man m1 has ranked the woman w102 with a score of eighty-two. The man m1 got a rating of fifty-seven from the woman w1. A rating of fifty was assigned to the man m10 by the woman w1. A rating of seventy-nine was assigned to the woman w10 by the man m1. The woman w1 rated the man m104 with a figure of sixty-five. The man m1 gave the woman w1 a rating of fourteen. A rating of sixty-eight was assigned to the man m101 by the woman w1. A rating of fifty-eight was assigned to the man m102 by the woman w1. The man m105 received a rating of seven from the woman w1. A rating of eighty-one was assigned to the woman w103 by the man m1. A rating of seventy-five was assigned to the woman w101 by the man m1.", "output": "manAssignsScore(m1,w1,14). manAssignsScore(m1,w10,79). manAssignsScore(m1,w100,81). manAssignsScore(m1,w101,75). manAssignsScore(m1,w102,82). manAssignsScore(m1,w103,81). manAssignsScore(m1,w104,48). manAssignsScore(m1,w105,58). womanAssignsScore(w1,m1,57). womanAssignsScore(w1,m10,50). womanAssignsScore(w1,m100,12). womanAssignsScore(w1,m101,68). womanAssignsScore(w1,m102,58). womanAssignsScore(w1,m103,81). womanAssignsScore(w1,m104,65). womanAssignsScore(w1,m105,7).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 judged the man m100 with a result of twelve. The woman w104 was given a rating of forty-eight by the man m1. The man m103 got a rating of eighty-one from the woman w1. The man m1 gave the woman w100 a rating of eighty-one. The woman w105 was given a rating of fifty-eight by the man m1. The man m1 has ranked the woman w102 with a score of eighty-two. The man m1 got a rating of fifty-seven from the woman w1. A rating of fifty was assigned to the man m10 by the woman w1. A rating of seventy-nine was assigned to the woman w10 by the man m1. The woman w1 rated the man m104 with a figure of sixty-five. The man m1 gave the woman w1 a rating of fourteen. A rating of sixty-eight was assigned to the man m101 by the woman w1. A rating of fifty-eight was assigned to the man m102 by the woman w1. The man m105 received a rating of seven from the woman w1. A rating of eighty-one was assigned to the woman w103 by the man m1. A rating of seventy-five was assigned to the woman w101 by the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5998494662432350644", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m102 received a rating of sixty-three from the woman w1. The woman w1 ranked the man m100 with a value of twenty-seven. A rating of seventy-three was assigned to the man m103 by the woman w1. The man m1 ranked the woman w1 with a value of seventy. The woman w1 judged the man m101 with a result of nine. A rating of forty-eight was assigned to the man m10 by the woman w1. The man m1 has ranked the woman w103 with a score of forty-four. The man m1 gave the woman w104 a score of twenty-two. The man m104 got a rating of twenty-four from the woman w1. The woman w101 was given a rating of sixty by the man m1. The woman w1 rated the man m105 with a figure of seventy-five. The man m1 has ranked the woman w100 with a score of twenty-four. A rating of fifty-eight was assigned to the woman w10 by the man m1. The man m1 gave the woman w105 a rating of thirty. The man m1 received a rating of seven from the woman w1. The man m1 has rated the woman w102 with a score of sixteen.", "output": "manAssignsScore(m1,w1,70). manAssignsScore(m1,w10,58). manAssignsScore(m1,w100,24). manAssignsScore(m1,w101,60). manAssignsScore(m1,w102,16). manAssignsScore(m1,w103,44). manAssignsScore(m1,w104,22). manAssignsScore(m1,w105,30). womanAssignsScore(w1,m1,7). womanAssignsScore(w1,m10,48). womanAssignsScore(w1,m100,27). womanAssignsScore(w1,m101,9). womanAssignsScore(w1,m102,63). womanAssignsScore(w1,m103,73). womanAssignsScore(w1,m104,24). womanAssignsScore(w1,m105,75).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m102 received a rating of sixty-three from the woman w1. The woman w1 ranked the man m100 with a value of twenty-seven. A rating of seventy-three was assigned to the man m103 by the woman w1. The man m1 ranked the woman w1 with a value of seventy. The woman w1 judged the man m101 with a result of nine. A rating of forty-eight was assigned to the man m10 by the woman w1. The man m1 has ranked the woman w103 with a score of forty-four. The man m1 gave the woman w104 a score of twenty-two. The man m104 got a rating of twenty-four from the woman w1. The woman w101 was given a rating of sixty by the man m1. The woman w1 rated the man m105 with a figure of seventy-five. The man m1 has ranked the woman w100 with a score of twenty-four. A rating of fifty-eight was assigned to the woman w10 by the man m1. The man m1 gave the woman w105 a rating of thirty. The man m1 received a rating of seven from the woman w1. The man m1 has rated the woman w102 with a score of sixteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1768801586911403168", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 placed the man m104 at a level of eighty-one. The man m1 gave the woman w105 a score of forty-eight. The woman w10 was given a rating of seventy-five by the man m1. The woman w1 ranked the man m10 with a value of thirty-three. The woman w1 placed the man m1 at a level of thirty-three. The man m101 received a rating of thirty-one from the woman w1. The woman w1 assigned a value of m100 to the man nineteen. The man m1 gave the woman w101 a score of forty-eight. The woman w1 rated the man m103 with a figure of thirty-one. The man m1 ranked the woman w100 with a value of ninety-three. The man m1 has ranked the woman w104 with a score of twenty-seven. The man m102 got a rating of twenty-two from the woman w1. The man m1 has rated the woman w1 with a score of forty-six. The woman w103 was given a rating of twenty by the man m1. A rating of thirty-five was assigned to the woman w102 by the man m1. The woman w1 placed the man m105 at a level of sixteen.", "output": "manAssignsScore(m1,w1,46). manAssignsScore(m1,w10,75). manAssignsScore(m1,w100,93). manAssignsScore(m1,w101,48). manAssignsScore(m1,w102,35). manAssignsScore(m1,w103,20). manAssignsScore(m1,w104,27). manAssignsScore(m1,w105,48). womanAssignsScore(w1,m1,33). womanAssignsScore(w1,m10,33). womanAssignsScore(w1,m100,19). womanAssignsScore(w1,m101,31). womanAssignsScore(w1,m102,22). womanAssignsScore(w1,m103,31). womanAssignsScore(w1,m104,81). womanAssignsScore(w1,m105,16).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 placed the man m104 at a level of eighty-one. The man m1 gave the woman w105 a score of forty-eight. The woman w10 was given a rating of seventy-five by the man m1. The woman w1 ranked the man m10 with a value of thirty-three. The woman w1 placed the man m1 at a level of thirty-three. The man m101 received a rating of thirty-one from the woman w1. The woman w1 assigned a value of m100 to the man nineteen. The man m1 gave the woman w101 a score of forty-eight. The woman w1 rated the man m103 with a figure of thirty-one. The man m1 ranked the woman w100 with a value of ninety-three. The man m1 has ranked the woman w104 with a score of twenty-seven. The man m102 got a rating of twenty-two from the woman w1. The man m1 has rated the woman w1 with a score of forty-six. The woman w103 was given a rating of twenty by the man m1. A rating of thirty-five was assigned to the woman w102 by the man m1. The woman w1 placed the man m105 at a level of sixteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7960979894905255333", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w101 was given a rating of forty-three by the man m1. The man m10 got a rating of eighty-two from the woman w1. The man m1 has ranked the woman w105 with a score of twenty-four. The woman w10 was given a rating of thirty by the man m1. The man m100 got a rating of eleven from the woman w1. The woman w1 assigned a value of m105 to the man seventy-three. The woman w1 judged the man m1 with a result of twenty-four. The man m1 ranked the woman w1 with a value of seventy-four. The woman w1 judged the man m104 with a result of nine. The woman w1 ranked the man m102 with a value of sixty-one. A rating of seventy-eight was assigned to the woman w102 by the man m1. The man m1 has ranked the woman w103 with a score of thirty-five. The woman w1 assigned a value of m101 to the man eighty-nine. The man m103 got a rating of seventy-five from the woman w1. The man m1 gave the woman w104 a score of fifty-eight. The man m1 gave the woman w100 a score of twenty-seven.", "output": "manAssignsScore(m1,w1,74). manAssignsScore(m1,w10,30). manAssignsScore(m1,w100,27). manAssignsScore(m1,w101,43). manAssignsScore(m1,w102,78). manAssignsScore(m1,w103,35). manAssignsScore(m1,w104,58). manAssignsScore(m1,w105,24). womanAssignsScore(w1,m1,24). womanAssignsScore(w1,m10,82). womanAssignsScore(w1,m100,11). womanAssignsScore(w1,m101,89). womanAssignsScore(w1,m102,61). womanAssignsScore(w1,m103,75). womanAssignsScore(w1,m104,9). womanAssignsScore(w1,m105,73).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w101 was given a rating of forty-three by the man m1. The man m10 got a rating of eighty-two from the woman w1. The man m1 has ranked the woman w105 with a score of twenty-four. The woman w10 was given a rating of thirty by the man m1. The man m100 got a rating of eleven from the woman w1. The woman w1 assigned a value of m105 to the man seventy-three. The woman w1 judged the man m1 with a result of twenty-four. The man m1 ranked the woman w1 with a value of seventy-four. The woman w1 judged the man m104 with a result of nine. The woman w1 ranked the man m102 with a value of sixty-one. A rating of seventy-eight was assigned to the woman w102 by the man m1. The man m1 has ranked the woman w103 with a score of thirty-five. The woman w1 assigned a value of m101 to the man eighty-nine. The man m103 got a rating of seventy-five from the woman w1. The man m1 gave the woman w104 a score of fifty-eight. The man m1 gave the woman w100 a score of twenty-seven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4032623932101341444", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 gave the woman w105 a rating of sixty-seven. The woman w1 assigned a value of m10 to the man thirty. The man m1 has rated the woman w1 with a score of three. The man m102 received a rating of four from the woman w1. The man m1 gave the woman w102 a rating of ninety-six. The man m100 received a rating of sixty-seven from the woman w1. The man m1 has ranked the woman w103 with a score of thirty. The woman w1 rated the man m104 with a figure of forty-three. The woman w1 judged the man m103 with a result of forty-one. The woman w1 placed the man m105 at a level of eleven. The woman w104 received a rating of sixty from the man m1. The woman w1 placed the man m1 at a level of seventy-one. The woman w1 placed the man m101 at a level of eighty. The man m1 ranked the woman w101 with a value of twenty-four. The woman w100 received a rating of fifty-seven from the man m1. The woman w10 was given a rating of ninety-two by the man m1.", "output": "manAssignsScore(m1,w1,3). manAssignsScore(m1,w10,92). manAssignsScore(m1,w100,57). manAssignsScore(m1,w101,24). manAssignsScore(m1,w102,96). manAssignsScore(m1,w103,30). manAssignsScore(m1,w104,60). manAssignsScore(m1,w105,67). womanAssignsScore(w1,m1,71). womanAssignsScore(w1,m10,30). womanAssignsScore(w1,m100,67). womanAssignsScore(w1,m101,80). womanAssignsScore(w1,m102,4). womanAssignsScore(w1,m103,41). womanAssignsScore(w1,m104,43). womanAssignsScore(w1,m105,11).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 gave the woman w105 a rating of sixty-seven. The woman w1 assigned a value of m10 to the man thirty. The man m1 has rated the woman w1 with a score of three. The man m102 received a rating of four from the woman w1. The man m1 gave the woman w102 a rating of ninety-six. The man m100 received a rating of sixty-seven from the woman w1. The man m1 has ranked the woman w103 with a score of thirty. The woman w1 rated the man m104 with a figure of forty-three. The woman w1 judged the man m103 with a result of forty-one. The woman w1 placed the man m105 at a level of eleven. The woman w104 received a rating of sixty from the man m1. The woman w1 placed the man m1 at a level of seventy-one. The woman w1 placed the man m101 at a level of eighty. The man m1 ranked the woman w101 with a value of twenty-four. The woman w100 received a rating of fifty-seven from the man m1. The woman w10 was given a rating of ninety-two by the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2962467024452669520", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 got a rating of thirty-three from the woman w1. The man m1 ranked the woman w10 with a value of eight. The man m1 gave the woman w105 a rating of eighty-four. The woman w1 assigned a value of m103 to the man thirty. The woman w1 judged the man m10 with a result of fifty-seven. The man m1 has rated the woman w102 with a score of eighty-three. The woman w1 placed the man m102 at a level of twenty-seven. The man m101 received a rating of twenty-eight from the woman w1. The man m1 gave the woman w103 a rating of eighty-five. The man m1 has rated the woman w1 with a score of twenty-two. The man m104 received a rating of sixty-five from the woman w1. The man m1 has rated the woman w101 with a score of sixty. The man m105 received a rating of fifty-five from the woman w1. The woman w1 placed the man m100 at a level of ninety-eight. A rating of fifteen was assigned to the woman w100 by the man m1. The man m1 ranked the woman w104 with a value of seven.", "output": "manAssignsScore(m1,w1,22). manAssignsScore(m1,w10,8). manAssignsScore(m1,w100,15). manAssignsScore(m1,w101,60). manAssignsScore(m1,w102,83). manAssignsScore(m1,w103,85). manAssignsScore(m1,w104,7). manAssignsScore(m1,w105,84). womanAssignsScore(w1,m1,33). womanAssignsScore(w1,m10,57). womanAssignsScore(w1,m100,98). womanAssignsScore(w1,m101,28). womanAssignsScore(w1,m102,27). womanAssignsScore(w1,m103,30). womanAssignsScore(w1,m104,65). womanAssignsScore(w1,m105,55).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 got a rating of thirty-three from the woman w1. The man m1 ranked the woman w10 with a value of eight. The man m1 gave the woman w105 a rating of eighty-four. The woman w1 assigned a value of m103 to the man thirty. The woman w1 judged the man m10 with a result of fifty-seven. The man m1 has rated the woman w102 with a score of eighty-three. The woman w1 placed the man m102 at a level of twenty-seven. The man m101 received a rating of twenty-eight from the woman w1. The man m1 gave the woman w103 a rating of eighty-five. The man m1 has rated the woman w1 with a score of twenty-two. The man m104 received a rating of sixty-five from the woman w1. The man m1 has rated the woman w101 with a score of sixty. The man m105 received a rating of fifty-five from the woman w1. The woman w1 placed the man m100 at a level of ninety-eight. A rating of fifteen was assigned to the woman w100 by the man m1. The man m1 ranked the woman w104 with a value of seven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4971729070823259039", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 gave the woman w104 a rating of sixteen. The woman w100 received a rating of sixty-nine from the man m1. The man m1 gave the woman w102 a rating of sixty-seven. The man m1 has rated the woman w1 with a score of seventy-two. The woman w1 placed the man m104 at a level of fifty-one. The man m101 received a rating of fifty from the woman w1. The man m103 received a rating of seventy-one from the woman w1. A rating of twelve was assigned to the woman w105 by the man m1. The woman w103 was given a rating of eighty-eight by the man m1. The man m1 ranked the woman w10 with a value of thirty-four. The woman w1 placed the man m10 at a level of ninety-five. The man m105 got a rating of twenty-one from the woman w1. The man m1 gave the woman w101 a rating of sixteen. The woman w1 assigned a value of m100 to the man seventeen. The man m1 got a rating of twenty-seven from the woman w1. The woman w1 assigned a value of m102 to the man ninety-one.", "output": "manAssignsScore(m1,w1,72). manAssignsScore(m1,w10,34). manAssignsScore(m1,w100,69). manAssignsScore(m1,w101,16). manAssignsScore(m1,w102,67). manAssignsScore(m1,w103,88). manAssignsScore(m1,w104,16). manAssignsScore(m1,w105,12). womanAssignsScore(w1,m1,27). womanAssignsScore(w1,m10,95). womanAssignsScore(w1,m100,17). womanAssignsScore(w1,m101,50). womanAssignsScore(w1,m102,91). womanAssignsScore(w1,m103,71). womanAssignsScore(w1,m104,51). womanAssignsScore(w1,m105,21).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 gave the woman w104 a rating of sixteen. The woman w100 received a rating of sixty-nine from the man m1. The man m1 gave the woman w102 a rating of sixty-seven. The man m1 has rated the woman w1 with a score of seventy-two. The woman w1 placed the man m104 at a level of fifty-one. The man m101 received a rating of fifty from the woman w1. The man m103 received a rating of seventy-one from the woman w1. A rating of twelve was assigned to the woman w105 by the man m1. The woman w103 was given a rating of eighty-eight by the man m1. The man m1 ranked the woman w10 with a value of thirty-four. The woman w1 placed the man m10 at a level of ninety-five. The man m105 got a rating of twenty-one from the woman w1. The man m1 gave the woman w101 a rating of sixteen. The woman w1 assigned a value of m100 to the man seventeen. The man m1 got a rating of twenty-seven from the woman w1. The woman w1 assigned a value of m102 to the man ninety-one.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6708788432565647083", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 assigned a value of m1 to the man fifty-four. The woman w1 judged the man m10 with a result of sixty-nine. The woman w1 rated the man m105 with a figure of twenty-eight. The woman w1 placed the man m101 at a level of ninety-nine. The man m1 has ranked the woman w101 with a score of eighty-four. The woman w1 placed the man m103 at a level of sixty. The man m1 has ranked the woman w102 with a score of thirty-six. The woman w1 assigned a value of m102 to the man eighteen. The man m1 has rated the woman w1 with a score of ninety-one. The man m1 gave the woman w100 a score of sixty-four. The woman w1 ranked the man m104 with a value of fourteen. The man m1 ranked the woman w10 with a value of seventy-three. The man m1 gave the woman w105 a rating of fifty-three. A rating of sixty-one was assigned to the man m100 by the woman w1. The man m1 gave the woman w104 a score of fifty-one. The man m1 ranked the woman w103 with a value of sixty-eight.", "output": "manAssignsScore(m1,w1,91). manAssignsScore(m1,w10,73). manAssignsScore(m1,w100,64). manAssignsScore(m1,w101,84). manAssignsScore(m1,w102,36). manAssignsScore(m1,w103,68). manAssignsScore(m1,w104,51). manAssignsScore(m1,w105,53). womanAssignsScore(w1,m1,54). womanAssignsScore(w1,m10,69). womanAssignsScore(w1,m100,61). womanAssignsScore(w1,m101,99). womanAssignsScore(w1,m102,18). womanAssignsScore(w1,m103,60). womanAssignsScore(w1,m104,14). womanAssignsScore(w1,m105,28).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 assigned a value of m1 to the man fifty-four. The woman w1 judged the man m10 with a result of sixty-nine. The woman w1 rated the man m105 with a figure of twenty-eight. The woman w1 placed the man m101 at a level of ninety-nine. The man m1 has ranked the woman w101 with a score of eighty-four. The woman w1 placed the man m103 at a level of sixty. The man m1 has ranked the woman w102 with a score of thirty-six. The woman w1 assigned a value of m102 to the man eighteen. The man m1 has rated the woman w1 with a score of ninety-one. The man m1 gave the woman w100 a score of sixty-four. The woman w1 ranked the man m104 with a value of fourteen. The man m1 ranked the woman w10 with a value of seventy-three. The man m1 gave the woman w105 a rating of fifty-three. A rating of sixty-one was assigned to the man m100 by the woman w1. The man m1 gave the woman w104 a score of fifty-one. The man m1 ranked the woman w103 with a value of sixty-eight.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "284497282183903869", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 gave the woman w105 a score of seventy-eight. The man m101 got a rating of forty-six from the woman w1. The man m1 ranked the woman w104 with a value of thirty-three. The man m1 has rated the woman w100 with a score of thirteen. The woman w1 rated the man m1 with a figure of ninety. The man m1 has ranked the woman w10 with a score of forty-five. The woman w1 assigned a value of m103 to the man twenty-nine. The woman w1 assigned a value of m105 to the man eighty-five. The man m104 received a rating of thirty from the woman w1. The woman w1 assigned a value of m102 to the man sixteen. The man m1 has rated the woman w103 with a score of forty-eight. The woman w101 was given a rating of fifty-five by the man m1. The man m1 ranked the woman w1 with a value of ninety-nine. The man m1 gave the woman w102 a score of seven. The woman w1 judged the man m10 with a result of ninety-one. The woman w1 assigned a value of m100 to the man fifty-six.", "output": "manAssignsScore(m1,w1,99). manAssignsScore(m1,w10,45). manAssignsScore(m1,w100,13). manAssignsScore(m1,w101,55). manAssignsScore(m1,w102,7). manAssignsScore(m1,w103,48). manAssignsScore(m1,w104,33). manAssignsScore(m1,w105,78). womanAssignsScore(w1,m1,90). womanAssignsScore(w1,m10,91). womanAssignsScore(w1,m100,56). womanAssignsScore(w1,m101,46). womanAssignsScore(w1,m102,16). womanAssignsScore(w1,m103,29). womanAssignsScore(w1,m104,30). womanAssignsScore(w1,m105,85).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 gave the woman w105 a score of seventy-eight. The man m101 got a rating of forty-six from the woman w1. The man m1 ranked the woman w104 with a value of thirty-three. The man m1 has rated the woman w100 with a score of thirteen. The woman w1 rated the man m1 with a figure of ninety. The man m1 has ranked the woman w10 with a score of forty-five. The woman w1 assigned a value of m103 to the man twenty-nine. The woman w1 assigned a value of m105 to the man eighty-five. The man m104 received a rating of thirty from the woman w1. The woman w1 assigned a value of m102 to the man sixteen. The man m1 has rated the woman w103 with a score of forty-eight. The woman w101 was given a rating of fifty-five by the man m1. The man m1 ranked the woman w1 with a value of ninety-nine. The man m1 gave the woman w102 a score of seven. The woman w1 judged the man m10 with a result of ninety-one. The woman w1 assigned a value of m100 to the man fifty-six.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7632990437528071807", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 judged the man m100 with a result of twenty-eight. A rating of twenty-nine was assigned to the woman w103 by the man m1. The man m1 has rated the woman w1 with a score of seventy-eight. The man m1 has rated the woman w102 with a score of twenty-two. A rating of fifty-five was assigned to the man m1 by the woman w1. The man m1 gave the woman w104 a score of one hundred. The woman w1 judged the man m105 with a result of ninety-five. The man m1 gave the woman w100 a rating of twenty-seven. A rating of thirty-seven was assigned to the man m103 by the woman w1. The woman w1 ranked the man m101 with a value of thirty-eight. The woman w1 rated the man m104 with a figure of forty-seven. The woman w1 ranked the man m10 with a value of fifty-seven. The man m1 has ranked the woman w105 with a score of forty-eight. The woman w1 ranked the man m102 with a value of nineteen. The woman w101 was given a rating of ninety-seven by the man m1. A rating of seventy-six was assigned to the woman w10 by the man m1.", "output": "manAssignsScore(m1,w1,78). manAssignsScore(m1,w10,76). manAssignsScore(m1,w100,27). manAssignsScore(m1,w101,97). manAssignsScore(m1,w102,22). manAssignsScore(m1,w103,29). manAssignsScore(m1,w104,100). manAssignsScore(m1,w105,48). womanAssignsScore(w1,m1,55). womanAssignsScore(w1,m10,57). womanAssignsScore(w1,m100,28). womanAssignsScore(w1,m101,38). womanAssignsScore(w1,m102,19). womanAssignsScore(w1,m103,37). womanAssignsScore(w1,m104,47). womanAssignsScore(w1,m105,95).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 judged the man m100 with a result of twenty-eight. A rating of twenty-nine was assigned to the woman w103 by the man m1. The man m1 has rated the woman w1 with a score of seventy-eight. The man m1 has rated the woman w102 with a score of twenty-two. A rating of fifty-five was assigned to the man m1 by the woman w1. The man m1 gave the woman w104 a score of one hundred. The woman w1 judged the man m105 with a result of ninety-five. The man m1 gave the woman w100 a rating of twenty-seven. A rating of thirty-seven was assigned to the man m103 by the woman w1. The woman w1 ranked the man m101 with a value of thirty-eight. The woman w1 rated the man m104 with a figure of forty-seven. The woman w1 ranked the man m10 with a value of fifty-seven. The man m1 has ranked the woman w105 with a score of forty-eight. The woman w1 ranked the man m102 with a value of nineteen. The woman w101 was given a rating of ninety-seven by the man m1. A rating of seventy-six was assigned to the woman w10 by the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6973241383252909883", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "A rating of fifty-eight was assigned to the man m101 by the woman w1. The woman w1 ranked the man m104 with a value of twenty-five. The woman w1 judged the man m100 with a result of eighty-six. The man m1 has rated the woman w103 with a score of ninety. The man m1 ranked the woman w100 with a value of eighteen. The woman w1 rated the man m103 with a figure of forty. The man m1 ranked the woman w104 with a value of eighty-five. The man m1 has rated the woman w101 with a score of twenty. The man m1 has ranked the woman w105 with a score of forty-three. The man m1 has ranked the woman w102 with a score of twelve. The woman w10 was given a rating of twenty-six by the man m1. The woman w1 judged the man m10 with a result of eighteen. The woman w1 judged the man m105 with a result of twenty-eight. The man m1 ranked the woman w1 with a value of seven. The woman w1 assigned a value of m102 to the man seventy-one. The woman w1 ranked the man m1 with a value of eighteen.", "output": "manAssignsScore(m1,w1,7). manAssignsScore(m1,w10,26). manAssignsScore(m1,w100,18). manAssignsScore(m1,w101,20). manAssignsScore(m1,w102,12). manAssignsScore(m1,w103,90). manAssignsScore(m1,w104,85). manAssignsScore(m1,w105,43). womanAssignsScore(w1,m1,18). womanAssignsScore(w1,m10,18). womanAssignsScore(w1,m100,86). womanAssignsScore(w1,m101,58). womanAssignsScore(w1,m102,71). womanAssignsScore(w1,m103,40). womanAssignsScore(w1,m104,25). womanAssignsScore(w1,m105,28).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```A rating of fifty-eight was assigned to the man m101 by the woman w1. The woman w1 ranked the man m104 with a value of twenty-five. The woman w1 judged the man m100 with a result of eighty-six. The man m1 has rated the woman w103 with a score of ninety. The man m1 ranked the woman w100 with a value of eighteen. The woman w1 rated the man m103 with a figure of forty. The man m1 ranked the woman w104 with a value of eighty-five. The man m1 has rated the woman w101 with a score of twenty. The man m1 has ranked the woman w105 with a score of forty-three. The man m1 has ranked the woman w102 with a score of twelve. The woman w10 was given a rating of twenty-six by the man m1. The woman w1 judged the man m10 with a result of eighteen. The woman w1 judged the man m105 with a result of twenty-eight. The man m1 ranked the woman w1 with a value of seven. The woman w1 assigned a value of m102 to the man seventy-one. The woman w1 ranked the man m1 with a value of eighteen.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3720850134842517713", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 ranked the woman w10 with a value of ninety-two. The man m1 gave the woman w103 a rating of eighty-seven. The woman w1 placed the man m101 at a level of fifty-four. The woman w1 placed the man m10 at a level of seventy-six. The woman w1 placed the man m105 at a level of thirty-eight. The man m1 has ranked the woman w102 with a score of ten. The man m1 ranked the woman w105 with a value of sixty-two. The man m1 gave the woman w100 a score of sixty-six. The woman w1 placed the man m104 at a level of fifteen. The man m102 received a rating of ninety-nine from the woman w1. The man m1 gave the woman w1 a score of eight. The man m100 got a rating of sixty-three from the woman w1. A rating of fifty-nine was assigned to the man m1 by the woman w1. The woman w1 rated the man m103 with a figure of twenty-eight. A rating of sixty-eight was assigned to the woman w101 by the man m1. The woman w104 received a rating of eighty-two from the man m1.", "output": "manAssignsScore(m1,w1,8). manAssignsScore(m1,w10,92). manAssignsScore(m1,w100,66). manAssignsScore(m1,w101,68). manAssignsScore(m1,w102,10). manAssignsScore(m1,w103,87). manAssignsScore(m1,w104,82). manAssignsScore(m1,w105,62). womanAssignsScore(w1,m1,59). womanAssignsScore(w1,m10,76). womanAssignsScore(w1,m100,63). womanAssignsScore(w1,m101,54). womanAssignsScore(w1,m102,99). womanAssignsScore(w1,m103,28). womanAssignsScore(w1,m104,15). womanAssignsScore(w1,m105,38).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 ranked the woman w10 with a value of ninety-two. The man m1 gave the woman w103 a rating of eighty-seven. The woman w1 placed the man m101 at a level of fifty-four. The woman w1 placed the man m10 at a level of seventy-six. The woman w1 placed the man m105 at a level of thirty-eight. The man m1 has ranked the woman w102 with a score of ten. The man m1 ranked the woman w105 with a value of sixty-two. The man m1 gave the woman w100 a score of sixty-six. The woman w1 placed the man m104 at a level of fifteen. The man m102 received a rating of ninety-nine from the woman w1. The man m1 gave the woman w1 a score of eight. The man m100 got a rating of sixty-three from the woman w1. A rating of fifty-nine was assigned to the man m1 by the woman w1. The woman w1 rated the man m103 with a figure of twenty-eight. A rating of sixty-eight was assigned to the woman w101 by the man m1. The woman w104 received a rating of eighty-two from the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1826125926513330460", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 assigned a value of m101 to the man sixty-eight. The man m1 gave the woman w105 a rating of eight. The man m1 ranked the woman w101 with a value of eight. The man m1 gave the woman w1 a score of forty. The woman w10 received a rating of forty-nine from the man m1. The man m1 gave the woman w102 a score of thirty-one. A rating of seventy-four was assigned to the woman w103 by the man m1. The man m103 got a rating of twenty-five from the woman w1. The woman w1 ranked the man m105 with a value of forty-eight. The woman w1 ranked the man m1 with a value of sixteen. The woman w1 rated the man m10 with a figure of forty-eight. The man m1 gave the woman w100 a score of thirty-four. The woman w1 judged the man m100 with a result of seventy-three. The man m1 gave the woman w104 a rating of sixty-one. The man m104 got a rating of seventy from the woman w1. The woman w1 judged the man m102 with a result of eight.", "output": "manAssignsScore(m1,w1,40). manAssignsScore(m1,w10,49). manAssignsScore(m1,w100,34). manAssignsScore(m1,w101,8). manAssignsScore(m1,w102,31). manAssignsScore(m1,w103,74). manAssignsScore(m1,w104,61). manAssignsScore(m1,w105,8). womanAssignsScore(w1,m1,16). womanAssignsScore(w1,m10,48). womanAssignsScore(w1,m100,73). womanAssignsScore(w1,m101,68). womanAssignsScore(w1,m102,8). womanAssignsScore(w1,m103,25). womanAssignsScore(w1,m104,70). womanAssignsScore(w1,m105,48).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 assigned a value of m101 to the man sixty-eight. The man m1 gave the woman w105 a rating of eight. The man m1 ranked the woman w101 with a value of eight. The man m1 gave the woman w1 a score of forty. The woman w10 received a rating of forty-nine from the man m1. The man m1 gave the woman w102 a score of thirty-one. A rating of seventy-four was assigned to the woman w103 by the man m1. The man m103 got a rating of twenty-five from the woman w1. The woman w1 ranked the man m105 with a value of forty-eight. The woman w1 ranked the man m1 with a value of sixteen. The woman w1 rated the man m10 with a figure of forty-eight. The man m1 gave the woman w100 a score of thirty-four. The woman w1 judged the man m100 with a result of seventy-three. The man m1 gave the woman w104 a rating of sixty-one. The man m104 got a rating of seventy from the woman w1. The woman w1 judged the man m102 with a result of eight.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4158796356429765244", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "A rating of sixty-nine was assigned to the man m105 by the woman w1. The man m1 has rated the woman w100 with a score of twenty-one. The woman w1 judged the man m103 with a result of twenty-six. The man m1 gave the woman w104 a score of eighty-three. The woman w101 was given a rating of fourteen by the man m1. The woman w105 received a rating of twenty-seven from the man m1. The woman w1 assigned a value of m10 to the man eighteen. The man m1 has rated the woman w10 with a score of ten. The woman w1 judged the man m104 with a result of sixty-seven. The man m1 has rated the woman w103 with a score of thirty-seven. The woman w1 placed the man m100 at a level of fifty-nine. The man m101 got a rating of thirty-nine from the woman w1. The man m1 has rated the woman w1 with a score of thirty-five. A rating of twenty-six was assigned to the man m1 by the woman w1. The man m102 received a rating of forty-six from the woman w1. The man m1 has rated the woman w102 with a score of fifty-nine.", "output": "manAssignsScore(m1,w1,35). manAssignsScore(m1,w10,10). manAssignsScore(m1,w100,21). manAssignsScore(m1,w101,14). manAssignsScore(m1,w102,59). manAssignsScore(m1,w103,37). manAssignsScore(m1,w104,83). manAssignsScore(m1,w105,27). womanAssignsScore(w1,m1,26). womanAssignsScore(w1,m10,18). womanAssignsScore(w1,m100,59). womanAssignsScore(w1,m101,39). womanAssignsScore(w1,m102,46). womanAssignsScore(w1,m103,26). womanAssignsScore(w1,m104,67). womanAssignsScore(w1,m105,69).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```A rating of sixty-nine was assigned to the man m105 by the woman w1. The man m1 has rated the woman w100 with a score of twenty-one. The woman w1 judged the man m103 with a result of twenty-six. The man m1 gave the woman w104 a score of eighty-three. The woman w101 was given a rating of fourteen by the man m1. The woman w105 received a rating of twenty-seven from the man m1. The woman w1 assigned a value of m10 to the man eighteen. The man m1 has rated the woman w10 with a score of ten. The woman w1 judged the man m104 with a result of sixty-seven. The man m1 has rated the woman w103 with a score of thirty-seven. The woman w1 placed the man m100 at a level of fifty-nine. The man m101 got a rating of thirty-nine from the woman w1. The man m1 has rated the woman w1 with a score of thirty-five. A rating of twenty-six was assigned to the man m1 by the woman w1. The man m102 received a rating of forty-six from the woman w1. The man m1 has rated the woman w102 with a score of fifty-nine.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8749238994940595497", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 has rated the woman w101 with a score of sixty-nine. A rating of sixty-nine was assigned to the man m101 by the woman w1. The man m1 has ranked the woman w10 with a score of fifty-two. The man m1 has ranked the woman w104 with a score of eighty-one. The woman w1 judged the man m10 with a result of fifty-six. The woman w1 ranked the man m104 with a value of ten. The man m103 got a rating of forty-eight from the woman w1. The woman w100 received a rating of seventy-four from the man m1. The woman w103 received a rating of eighty-six from the man m1. The man m1 got a rating of thirty-two from the woman w1. The man m100 received a rating of eighty-six from the woman w1. The man m1 ranked the woman w102 with a value of seventy-four. The woman w1 judged the man m105 with a result of thirty-nine. The man m1 gave the woman w105 a rating of twelve. The man m1 gave the woman w1 a score of fourteen. A rating of thirty-seven was assigned to the man m102 by the woman w1.", "output": "manAssignsScore(m1,w1,14). manAssignsScore(m1,w10,52). manAssignsScore(m1,w100,74). manAssignsScore(m1,w101,69). manAssignsScore(m1,w102,74). manAssignsScore(m1,w103,86). manAssignsScore(m1,w104,81). manAssignsScore(m1,w105,12). womanAssignsScore(w1,m1,32). womanAssignsScore(w1,m10,56). womanAssignsScore(w1,m100,86). womanAssignsScore(w1,m101,69). womanAssignsScore(w1,m102,37). womanAssignsScore(w1,m103,48). womanAssignsScore(w1,m104,10). womanAssignsScore(w1,m105,39).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 has rated the woman w101 with a score of sixty-nine. A rating of sixty-nine was assigned to the man m101 by the woman w1. The man m1 has ranked the woman w10 with a score of fifty-two. The man m1 has ranked the woman w104 with a score of eighty-one. The woman w1 judged the man m10 with a result of fifty-six. The woman w1 ranked the man m104 with a value of ten. The man m103 got a rating of forty-eight from the woman w1. The woman w100 received a rating of seventy-four from the man m1. The woman w103 received a rating of eighty-six from the man m1. The man m1 got a rating of thirty-two from the woman w1. The man m100 received a rating of eighty-six from the woman w1. The man m1 ranked the woman w102 with a value of seventy-four. The woman w1 judged the man m105 with a result of thirty-nine. The man m1 gave the woman w105 a rating of twelve. The man m1 gave the woman w1 a score of fourteen. A rating of thirty-seven was assigned to the man m102 by the woman w1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5749275664232974189", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 ranked the woman w1 with a value of thirty-six. The man m1 gave the woman w103 a score of seventy-eight. The woman w105 was given a rating of fifty by the man m1. The woman w1 placed the man m102 at a level of seventy-one. The woman w1 placed the man m103 at a level of sixty-nine. The woman w1 placed the man m105 at a level of sixty-nine. The man m1 has ranked the woman w102 with a score of twelve. The woman w1 ranked the man m100 with a value of forty-two. The man m1 has rated the woman w100 with a score of eighty-three. The woman w1 judged the man m10 with a result of two. The woman w1 ranked the man m101 with a value of twenty-two. The woman w1 rated the man m104 with a figure of fifty-four. The man m1 ranked the woman w104 with a value of nine. The woman w10 was given a rating of eighty-six by the man m1. The man m1 has ranked the woman w101 with a score of twenty-eight. The man m1 got a rating of thirteen from the woman w1.", "output": "manAssignsScore(m1,w1,36). manAssignsScore(m1,w10,86). manAssignsScore(m1,w100,83). manAssignsScore(m1,w101,28). manAssignsScore(m1,w102,12). manAssignsScore(m1,w103,78). manAssignsScore(m1,w104,9). manAssignsScore(m1,w105,50). womanAssignsScore(w1,m1,13). womanAssignsScore(w1,m10,2). womanAssignsScore(w1,m100,42). womanAssignsScore(w1,m101,22). womanAssignsScore(w1,m102,71). womanAssignsScore(w1,m103,69). womanAssignsScore(w1,m104,54). womanAssignsScore(w1,m105,69).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 ranked the woman w1 with a value of thirty-six. The man m1 gave the woman w103 a score of seventy-eight. The woman w105 was given a rating of fifty by the man m1. The woman w1 placed the man m102 at a level of seventy-one. The woman w1 placed the man m103 at a level of sixty-nine. The woman w1 placed the man m105 at a level of sixty-nine. The man m1 has ranked the woman w102 with a score of twelve. The woman w1 ranked the man m100 with a value of forty-two. The man m1 has rated the woman w100 with a score of eighty-three. The woman w1 judged the man m10 with a result of two. The woman w1 ranked the man m101 with a value of twenty-two. The woman w1 rated the man m104 with a figure of fifty-four. The man m1 ranked the woman w104 with a value of nine. The woman w10 was given a rating of eighty-six by the man m1. The man m1 has ranked the woman w101 with a score of twenty-eight. The man m1 got a rating of thirteen from the woman w1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5406167716387214030", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 rated the man m10 with a figure of ninety-two. A rating of thirty-nine was assigned to the man m102 by the woman w1. The woman w1 ranked the man m100 with a value of twelve. The man m1 gave the woman w104 a score of fifty-one. The man m1 has rated the woman w105 with a score of twenty-one. A rating of eighty-three was assigned to the woman w1 by the man m1. The woman w1 judged the man m101 with a result of eighty-three. The man m1 gave the woman w103 a rating of thirty-one. The woman w1 judged the man m103 with a result of eighty-seven. The man m1 got a rating of thirty-two from the woman w1. The man m1 gave the woman w101 a rating of thirty-one. A rating of sixty-four was assigned to the woman w102 by the man m1. The woman w1 assigned a value of m105 to the man sixty-two. The man m1 has ranked the woman w100 with a score of seventy-nine. The woman w1 ranked the man m104 with a value of forty-nine. The man m1 has ranked the woman w10 with a score of twenty-six.", "output": "manAssignsScore(m1,w1,83). manAssignsScore(m1,w10,26). manAssignsScore(m1,w100,79). manAssignsScore(m1,w101,31). manAssignsScore(m1,w102,64). manAssignsScore(m1,w103,31). manAssignsScore(m1,w104,51). manAssignsScore(m1,w105,21). womanAssignsScore(w1,m1,32). womanAssignsScore(w1,m10,92). womanAssignsScore(w1,m100,12). womanAssignsScore(w1,m101,83). womanAssignsScore(w1,m102,39). womanAssignsScore(w1,m103,87). womanAssignsScore(w1,m104,49). womanAssignsScore(w1,m105,62).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 rated the man m10 with a figure of ninety-two. A rating of thirty-nine was assigned to the man m102 by the woman w1. The woman w1 ranked the man m100 with a value of twelve. The man m1 gave the woman w104 a score of fifty-one. The man m1 has rated the woman w105 with a score of twenty-one. A rating of eighty-three was assigned to the woman w1 by the man m1. The woman w1 judged the man m101 with a result of eighty-three. The man m1 gave the woman w103 a rating of thirty-one. The woman w1 judged the man m103 with a result of eighty-seven. The man m1 got a rating of thirty-two from the woman w1. The man m1 gave the woman w101 a rating of thirty-one. A rating of sixty-four was assigned to the woman w102 by the man m1. The woman w1 assigned a value of m105 to the man sixty-two. The man m1 has ranked the woman w100 with a score of seventy-nine. The woman w1 ranked the man m104 with a value of forty-nine. The man m1 has ranked the woman w10 with a score of twenty-six.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3854271665747279577", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 assigned a value of m1 to the man thirty-four. The man m1 has rated the woman w100 with a score of three. The man m101 got a rating of forty-three from the woman w1. The woman w1 placed the man m102 at a level of sixteen. The man m1 has rated the woman w104 with a score of sixty-three. The man m1 gave the woman w101 a score of nine. The man m1 has rated the woman w102 with a score of eighteen. The woman w1 rated the man m100 with a figure of two. The man m1 gave the woman w1 a score of fifty. The woman w105 received a rating of two from the man m1. The man m104 got a rating of forty-nine from the woman w1. The man m1 gave the woman w10 a score of ten. A rating of fifty-four was assigned to the man m10 by the woman w1. The man m1 has ranked the woman w103 with a score of eleven. The man m105 received a rating of twenty-two from the woman w1. The woman w1 rated the man m103 with a figure of sixty-five.", "output": "manAssignsScore(m1,w1,50). manAssignsScore(m1,w10,10). manAssignsScore(m1,w100,3). manAssignsScore(m1,w101,9). manAssignsScore(m1,w102,18). manAssignsScore(m1,w103,11). manAssignsScore(m1,w104,63). manAssignsScore(m1,w105,2). womanAssignsScore(w1,m1,34). womanAssignsScore(w1,m10,54). womanAssignsScore(w1,m100,2). womanAssignsScore(w1,m101,43). womanAssignsScore(w1,m102,16). womanAssignsScore(w1,m103,65). womanAssignsScore(w1,m104,49). womanAssignsScore(w1,m105,22).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 assigned a value of m1 to the man thirty-four. The man m1 has rated the woman w100 with a score of three. The man m101 got a rating of forty-three from the woman w1. The woman w1 placed the man m102 at a level of sixteen. The man m1 has rated the woman w104 with a score of sixty-three. The man m1 gave the woman w101 a score of nine. The man m1 has rated the woman w102 with a score of eighteen. The woman w1 rated the man m100 with a figure of two. The man m1 gave the woman w1 a score of fifty. The woman w105 received a rating of two from the man m1. The man m104 got a rating of forty-nine from the woman w1. The man m1 gave the woman w10 a score of ten. A rating of fifty-four was assigned to the man m10 by the woman w1. The man m1 has ranked the woman w103 with a score of eleven. The man m105 received a rating of twenty-two from the woman w1. The woman w1 rated the man m103 with a figure of sixty-five.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2239480060704472263", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w103 was given a rating of eighty-three by the man m1. The man m1 has ranked the woman w105 with a score of thirty-three. The woman w1 assigned a value of m1 to the man two. The woman w1 rated the man m104 with a figure of twenty-six. The woman w1 judged the man m100 with a result of nine. The man m1 has rated the woman w10 with a score of sixty-nine. The woman w100 received a rating of sixty-nine from the man m1. The woman w102 was given a rating of eleven by the man m1. A rating of twenty-three was assigned to the man m10 by the woman w1. A rating of ninety-three was assigned to the man m105 by the woman w1. The woman w1 rated the man m102 with a figure of fifty-five. The woman w104 was given a rating of two by the man m1. A rating of ninety-two was assigned to the man m103 by the woman w1. A rating of sixty-seven was assigned to the woman w1 by the man m1. The woman w1 rated the man m101 with a figure of thirty-five. The man m1 has ranked the woman w101 with a score of thirty-seven.", "output": "manAssignsScore(m1,w1,67). manAssignsScore(m1,w10,69). manAssignsScore(m1,w100,69). manAssignsScore(m1,w101,37). manAssignsScore(m1,w102,11). manAssignsScore(m1,w103,83). manAssignsScore(m1,w104,2). manAssignsScore(m1,w105,33). womanAssignsScore(w1,m1,2). womanAssignsScore(w1,m10,23). womanAssignsScore(w1,m100,9). womanAssignsScore(w1,m101,35). womanAssignsScore(w1,m102,55). womanAssignsScore(w1,m103,92). womanAssignsScore(w1,m104,26). womanAssignsScore(w1,m105,93).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w103 was given a rating of eighty-three by the man m1. The man m1 has ranked the woman w105 with a score of thirty-three. The woman w1 assigned a value of m1 to the man two. The woman w1 rated the man m104 with a figure of twenty-six. The woman w1 judged the man m100 with a result of nine. The man m1 has rated the woman w10 with a score of sixty-nine. The woman w100 received a rating of sixty-nine from the man m1. The woman w102 was given a rating of eleven by the man m1. A rating of twenty-three was assigned to the man m10 by the woman w1. A rating of ninety-three was assigned to the man m105 by the woman w1. The woman w1 rated the man m102 with a figure of fifty-five. The woman w104 was given a rating of two by the man m1. A rating of ninety-two was assigned to the man m103 by the woman w1. A rating of sixty-seven was assigned to the woman w1 by the man m1. The woman w1 rated the man m101 with a figure of thirty-five. The man m1 has ranked the woman w101 with a score of thirty-seven.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7828915222558683391", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m1 has rated the woman w15 with a score of eight. The woman w1 judged the man m12 with a result of seven. The man m1 got a rating of four from the woman w1. The woman w1 rated the man m11 with a figure of one. The woman w1 judged the man m13 with a result of seventeen. The man m1 gave the woman w11 a rating of six. The woman w1 judged the man m10 with a result of thirteen. The man m1 ranked the woman w16 with a value of thirteen. The man m1 has ranked the woman w13 with a score of ten. The man m1 gave the woman w14 a score of eleven. The man m1 has ranked the woman w10 with a score of fifteen. The man m14 received a rating of five from the woman w1. The man m1 ranked the woman w1 with a value of three. The woman w1 judged the man m16 with a result of six. A rating of sixteen was assigned to the woman w12 by the man m1. The woman w1 ranked the man m15 with a value of six.", "output": "manAssignsScore(m1,w1,3). manAssignsScore(m1,w10,15). manAssignsScore(m1,w11,6). manAssignsScore(m1,w12,16). manAssignsScore(m1,w13,10). manAssignsScore(m1,w14,11). manAssignsScore(m1,w15,8). manAssignsScore(m1,w16,13). womanAssignsScore(w1,m1,4). womanAssignsScore(w1,m10,13). womanAssignsScore(w1,m11,1). womanAssignsScore(w1,m12,7). womanAssignsScore(w1,m13,17). womanAssignsScore(w1,m14,5). womanAssignsScore(w1,m15,6). womanAssignsScore(w1,m16,6).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m1 has rated the woman w15 with a score of eight. The woman w1 judged the man m12 with a result of seven. The man m1 got a rating of four from the woman w1. The woman w1 rated the man m11 with a figure of one. The woman w1 judged the man m13 with a result of seventeen. The man m1 gave the woman w11 a rating of six. The woman w1 judged the man m10 with a result of thirteen. The man m1 ranked the woman w16 with a value of thirteen. The man m1 has ranked the woman w13 with a score of ten. The man m1 gave the woman w14 a score of eleven. The man m1 has ranked the woman w10 with a score of fifteen. The man m14 received a rating of five from the woman w1. The man m1 ranked the woman w1 with a value of three. The woman w1 judged the man m16 with a result of six. A rating of sixteen was assigned to the woman w12 by the man m1. The woman w1 ranked the man m15 with a value of six.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8903763194377439477", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 assigned a value of m101 to the man twenty-five. The man m1 ranked the woman w100 with a value of twenty-seven. The woman w1 placed the man m103 at a level of nineteen. A rating of thirty-one was assigned to the man m10 by the woman w1. The woman w101 received a rating of eighteen from the man m1. The man m1 has rated the woman w103 with a score of thirty-two. The woman w1 rated the man m1 with a figure of thirty. The man m1 has rated the woman w1 with a score of forty-seven. The man m104 got a rating of twenty-eight from the woman w1. A rating of forty-two was assigned to the man m102 by the woman w1. The man m1 has ranked the woman w105 with a score of forty-two. The man m1 has rated the woman w10 with a score of forty-eight. The man m1 gave the woman w104 a score of twenty-two. The woman w1 assigned a value of m105 to the man seventeen. The woman w1 assigned a value of m100 to the man thirty-two. The man m1 ranked the woman w102 with a value of fifty-eight.", "output": "manAssignsScore(m1,w1,47). manAssignsScore(m1,w10,48). manAssignsScore(m1,w100,27). manAssignsScore(m1,w101,18). manAssignsScore(m1,w102,58). manAssignsScore(m1,w103,32). manAssignsScore(m1,w104,22). manAssignsScore(m1,w105,42). womanAssignsScore(w1,m1,30). womanAssignsScore(w1,m10,31). womanAssignsScore(w1,m100,32). womanAssignsScore(w1,m101,25). womanAssignsScore(w1,m102,42). womanAssignsScore(w1,m103,19). womanAssignsScore(w1,m104,28). womanAssignsScore(w1,m105,17).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 assigned a value of m101 to the man twenty-five. The man m1 ranked the woman w100 with a value of twenty-seven. The woman w1 placed the man m103 at a level of nineteen. A rating of thirty-one was assigned to the man m10 by the woman w1. The woman w101 received a rating of eighteen from the man m1. The man m1 has rated the woman w103 with a score of thirty-two. The woman w1 rated the man m1 with a figure of thirty. The man m1 has rated the woman w1 with a score of forty-seven. The man m104 got a rating of twenty-eight from the woman w1. A rating of forty-two was assigned to the man m102 by the woman w1. The man m1 has ranked the woman w105 with a score of forty-two. The man m1 has rated the woman w10 with a score of forty-eight. The man m1 gave the woman w104 a score of twenty-two. The woman w1 assigned a value of m105 to the man seventeen. The woman w1 assigned a value of m100 to the man thirty-two. The man m1 ranked the woman w102 with a value of fifty-eight.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1306658089068377569", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The man m101 got a rating of twenty from the woman w1. The man m1 ranked the woman w103 with a value of seventy-six. The man m1 has rated the woman w100 with a score of twenty. The woman w1 placed the man m102 at a level of eighty-one. A rating of twenty-nine was assigned to the man m105 by the woman w1. The man m1 gave the woman w105 a rating of four. The man m103 got a rating of sixty-five from the woman w1. The man m1 received a rating of sixty-two from the woman w1. The man m1 gave the woman w10 a rating of ninety-four. The woman w1 rated the man m100 with a figure of sixty. The man m10 got a rating of eighty-seven from the woman w1. The man m104 received a rating of fifty-four from the woman w1. The man m1 has ranked the woman w104 with a score of five. The man m1 ranked the woman w101 with a value of ninety-two. The woman w1 received a rating of fifty-six from the man m1. A rating of eighty-two was assigned to the woman w102 by the man m1.", "output": "manAssignsScore(m1,w1,56). manAssignsScore(m1,w10,94). manAssignsScore(m1,w100,20). manAssignsScore(m1,w101,92). manAssignsScore(m1,w102,82). manAssignsScore(m1,w103,76). manAssignsScore(m1,w104,5). manAssignsScore(m1,w105,4). womanAssignsScore(w1,m1,62). womanAssignsScore(w1,m10,87). womanAssignsScore(w1,m100,60). womanAssignsScore(w1,m101,20). womanAssignsScore(w1,m102,81). womanAssignsScore(w1,m103,65). womanAssignsScore(w1,m104,54). womanAssignsScore(w1,m105,29).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The man m101 got a rating of twenty from the woman w1. The man m1 ranked the woman w103 with a value of seventy-six. The man m1 has rated the woman w100 with a score of twenty. The woman w1 placed the man m102 at a level of eighty-one. A rating of twenty-nine was assigned to the man m105 by the woman w1. The man m1 gave the woman w105 a rating of four. The man m103 got a rating of sixty-five from the woman w1. The man m1 received a rating of sixty-two from the woman w1. The man m1 gave the woman w10 a rating of ninety-four. The woman w1 rated the man m100 with a figure of sixty. The man m10 got a rating of eighty-seven from the woman w1. The man m104 received a rating of fifty-four from the woman w1. The man m1 has ranked the woman w104 with a score of five. The man m1 ranked the woman w101 with a value of ninety-two. The woman w1 received a rating of fifty-six from the man m1. A rating of eighty-two was assigned to the woman w102 by the man m1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7050889222415700054", "problem_id": "30", "problem_name": "Stable Marriage", "description": "Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.", "format": "Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.", "text": "The woman w1 rated the man m103 with a figure of twelve. The woman w1 rated the man m101 with a figure of twenty-two. The woman w1 placed the man m10 at a level of five. The man m105 received a rating of thirty-eight from the woman w1. The man m1 has rated the woman w10 with a score of fifty-eight. The man m102 received a rating of forty-two from the woman w1. The woman w103 was given a rating of sixty-seven by the man m1. A rating of sixty-six was assigned to the woman w100 by the man m1. A rating of ten was assigned to the woman w102 by the man m1. The woman w1 rated the man m104 with a figure of twenty-one. The woman w1 was given a rating of seventy-nine by the man m1. The woman w1 placed the man m1 at a level of eighty-three. The man m1 has ranked the woman w101 with a score of fourteen. A rating of sixty-two was assigned to the woman w105 by the man m1. The woman w1 placed the man m100 at a level of eighty-eight. The man m1 gave the woman w104 a rating of thirty-nine.", "output": "manAssignsScore(m1,w1,79). manAssignsScore(m1,w10,58). manAssignsScore(m1,w100,66). manAssignsScore(m1,w101,14). manAssignsScore(m1,w102,10). manAssignsScore(m1,w103,67). manAssignsScore(m1,w104,39). manAssignsScore(m1,w105,62). womanAssignsScore(w1,m1,83). womanAssignsScore(w1,m10,5). womanAssignsScore(w1,m100,88). womanAssignsScore(w1,m101,22). womanAssignsScore(w1,m102,42). womanAssignsScore(w1,m103,12). womanAssignsScore(w1,m104,21). womanAssignsScore(w1,m105,38).", "prompt": "Given the following problem description between triple backtips: \n ```Given n men and n women, where each person has ranked all members of the opposite sex with a unique number between 1 and n in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \"stable\".\nInstances comprise n men and n women. Each person has ranked all members of the opposite sex with a number between 1 and n in order of preference. Note that ties are permitted in this setting, i.e., one person can equally prefer two or more members of opposite sex. The stable matching problem has several practical applications, as well as several variants (some of which are hard to solve). The variant proposed in the following is known to be polynomially solvable.\nThe (strong) stable marriage problem is the problem of finding a (strong) stable matching mapping men to women. A matching is strong stable if and only if there is no pair m,w such that both the following conditions are satisfied:\n1. Man m is matched with a woman w' different from w and such that m prefers w over w';\n2. Woman w is matched with a man m' different from m and such that w prefers m over m', or m and m' are equally preferred by w.\nThere are instances that have no strongly stable matching when ties are permitted.```\nGiven the following specification for the predicates format: \n```Let w1,...,wn and m1,...,mn be n women and men, respectively.\n- womanAssignsScore(w,m,s) when a woman w assigns a score s to a man m\n- manAssignsScore(m,w,s) when a man m assigns a score s to a woman w\n\nRelations womanAssignsScore and manAssignsScore are complete specifications of preferences, i.e., womanAssignsScore (resp. manAssignsScore) is defined for each pair WOMAN,MAN (resp. MAN,WOMAN).\nA score is a positive integer ranging from 1 to n. The higher the score is, the higher the preference is. Ties in scores are admitted, that is, a woman can assign the same score to several men, and vice versa.```\nExtract the datalog facts from this text: \n```The woman w1 rated the man m103 with a figure of twelve. The woman w1 rated the man m101 with a figure of twenty-two. The woman w1 placed the man m10 at a level of five. The man m105 received a rating of thirty-eight from the woman w1. The man m1 has rated the woman w10 with a score of fifty-eight. The man m102 received a rating of forty-two from the woman w1. The woman w103 was given a rating of sixty-seven by the man m1. A rating of sixty-six was assigned to the woman w100 by the man m1. A rating of ten was assigned to the woman w102 by the man m1. The woman w1 rated the man m104 with a figure of twenty-one. The woman w1 was given a rating of seventy-nine by the man m1. The woman w1 placed the man m1 at a level of eighty-three. The man m1 has ranked the woman w101 with a score of fourteen. A rating of sixty-two was assigned to the woman w105 by the man m1. The woman w1 placed the man m100 at a level of eighty-eight. The man m1 gave the woman w104 a rating of thirty-nine.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1474692299917729359", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The junctions 12 and 17 are connected by the pipe, with a water demand of 94. The junctions 11 and 18 are connected by the pipe. Junctions 1 and 15 are joined by the pipe. A pipe connects junctions 12 and 13. Junctions 11 and 12 are joined by the pipe. The junctions 12 and 19 are connected by the pipe, with a water demand of 61. A pipe establishes a link between junctions 12 and 17. A pipe connects junctions 12 and 19. Each pipe can have only one valve(s). The pipe connecting 1 and 15 carries an associated weight of 142. The junctions 10 and 11 are connected by the pipe. The pipe connecting 11 and 12 has a water demand of 64. There is a tank in the junction node 1. A pipe connects junctions 12 and 13 with an associated weight of 48. The pipe between 1 and 2 serves a water demand of 116. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The valves that can be used are sixteen. The pipe connecting 11 and 18 has a water demand of 64. There is a water demand of 42 in the pipe connecting junctions 10 and 11. Junctions 1 and 2 are joined by the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,15,142). dem(1,2,116). dem(10,11,42). dem(11,12,64). dem(11,18,64). dem(12,13,48). dem(12,17,94). dem(12,19,61). pipe(1,15). pipe(1,2). pipe(10,11). pipe(11,12). pipe(11,18). pipe(12,13). pipe(12,17). pipe(12,19). tank(1). valves_number(16). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The junctions 12 and 17 are connected by the pipe, with a water demand of 94. The junctions 11 and 18 are connected by the pipe. Junctions 1 and 15 are joined by the pipe. A pipe connects junctions 12 and 13. Junctions 11 and 12 are joined by the pipe. The junctions 12 and 19 are connected by the pipe, with a water demand of 61. A pipe establishes a link between junctions 12 and 17. A pipe connects junctions 12 and 19. Each pipe can have only one valve(s). The pipe connecting 1 and 15 carries an associated weight of 142. The junctions 10 and 11 are connected by the pipe. The pipe connecting 11 and 12 has a water demand of 64. There is a tank in the junction node 1. A pipe connects junctions 12 and 13 with an associated weight of 48. The pipe between 1 and 2 serves a water demand of 116. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The valves that can be used are sixteen. The pipe connecting 11 and 18 has a water demand of 64. There is a water demand of 42 in the pipe connecting junctions 10 and 11. Junctions 1 and 2 are joined by the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1044701941066995355", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Between junctions 101 and 102, the pipe carries a water demand of 163. Only one valve(s) per pipe is permitted. Between junctions 1 and 95, the pipe carries a water demand of 89. Junctions 1 and 96 are joined by the pipe. Between junctions 101 and 103, the pipe carries a water demand of 122. A water demand of 60 exists in the pipe between junctions 1 and 96. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The valves that can be used are twenty. A pipe connects junctions 1 and 95. Junctions 100 and 104 are connected through the pipe. At the junction node 1, there is a tank. A pipe establishes a link between junctions 101 and 102. A pipe establishes a link between junctions 102 and 103. The pipe connecting 102 and 103 carries an associated weight of 125. A pipe establishes a link between junctions 1 and 92. There is a water demand of 96 in the pipe connecting junctions 100 and 104. The associated weight of the pipe between 1 and 92 is 108. Junctions 101 and 103 are connected through the pipe. A water demand of 133 flows through the pipe between junctions 100 and 101. The junctions 100 and 101 are connected by the pipe.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(20). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Between junctions 101 and 102, the pipe carries a water demand of 163. Only one valve(s) per pipe is permitted. Between junctions 1 and 95, the pipe carries a water demand of 89. Junctions 1 and 96 are joined by the pipe. Between junctions 101 and 103, the pipe carries a water demand of 122. A water demand of 60 exists in the pipe between junctions 1 and 96. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The valves that can be used are twenty. A pipe connects junctions 1 and 95. Junctions 100 and 104 are connected through the pipe. At the junction node 1, there is a tank. A pipe establishes a link between junctions 101 and 102. A pipe establishes a link between junctions 102 and 103. The pipe connecting 102 and 103 carries an associated weight of 125. A pipe establishes a link between junctions 1 and 92. There is a water demand of 96 in the pipe connecting junctions 100 and 104. The associated weight of the pipe between 1 and 92 is 108. Junctions 101 and 103 are connected through the pipe. A water demand of 133 flows through the pipe between junctions 100 and 101. The junctions 100 and 101 are connected by the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7361780066191853354", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A pipe establishes a link between junctions 1 and 92. A pipe establishes a link between junctions 1 and 95. Between junctions 1 and 96, the pipe carries a water demand of 60. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The valves that can be used are twenty-two. Between junctions 101 and 102, the pipe carries a water demand of 163. The pipe between 1 and 92 has an associated weight of 108. The pipe linking junctions 1 and 95 has a water requirement of 89. At the junction node 1, there is a tank. No more than two valve(s) per pipe is allowed. Junctions 100 and 104 are joined by the pipe. The pipe which runs between 100 and 104 carry a water demand of 96. A water demand of 122 flows through the pipe between junctions 101 and 103. Junctions 100 and 101 are connected through a pipe with a delivered water demand of 133. Junctions 100 and 101 are connected through the pipe. A pipe connects junctions 101 and 103. Junctions 102 and 103 are joined by the pipe. A pipe connects junctions 1 and 96. The associated weight of the pipe between 102 and 103 is 125. Junctions 101 and 102 are connected through the pipe.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(22). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A pipe establishes a link between junctions 1 and 92. A pipe establishes a link between junctions 1 and 95. Between junctions 1 and 96, the pipe carries a water demand of 60. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The valves that can be used are twenty-two. Between junctions 101 and 102, the pipe carries a water demand of 163. The pipe between 1 and 92 has an associated weight of 108. The pipe linking junctions 1 and 95 has a water requirement of 89. At the junction node 1, there is a tank. No more than two valve(s) per pipe is allowed. Junctions 100 and 104 are joined by the pipe. The pipe which runs between 100 and 104 carry a water demand of 96. A water demand of 122 flows through the pipe between junctions 101 and 103. Junctions 100 and 101 are connected through a pipe with a delivered water demand of 133. Junctions 100 and 101 are connected through the pipe. A pipe connects junctions 101 and 103. Junctions 102 and 103 are joined by the pipe. A pipe connects junctions 1 and 96. The associated weight of the pipe between 102 and 103 is 125. Junctions 101 and 102 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1804605708510304618", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Junctions 12 and 15 are connected through the pipe. Junctions 1 and 11 are connected through the pipe. A pipe connects junctions 11 and 24. The available valves are twenty-seven. Only two valve/s per pipe is/are allowed. A pipe establishes a link between junctions 1 and 2. A pipe connects junctions 12 and 13 with an associated weight of 53. The pipe between 1 and 12 serves a water demand of 56. The associated weight of the pipe between 1 and 11 is 59. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe connecting 12 and 15 carries an associated weight of 56. At the junction node 1, there is a tank. A water demand of 39 flows through the pipe between junctions 13 and 14. A pipe connects junctions 10 and 11 with an associated weight of 73. At the junction node 7, there is a tank. The pipe which runs between 11 and 24 carry a water demand of 48. The junctions 1 and 12 are connected by the pipe. The pipe linking junctions 1 and 2 has a water requirement of 39. Junctions 13 and 14 are joined by the pipe. Junctions 10 and 11 are joined by the pipe. There is a tank in the junction node 9. The junctions 12 and 13 are connected by the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,11,59). dem(1,12,56). dem(1,2,39). dem(10,11,73). dem(11,24,48). dem(12,13,53). dem(12,15,56). dem(13,14,39). pipe(1,11). pipe(1,12). pipe(1,2). pipe(10,11). pipe(11,24). pipe(12,13). pipe(12,15). pipe(13,14). tank(1). tank(7). tank(9). valves_number(27). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Junctions 12 and 15 are connected through the pipe. Junctions 1 and 11 are connected through the pipe. A pipe connects junctions 11 and 24. The available valves are twenty-seven. Only two valve/s per pipe is/are allowed. A pipe establishes a link between junctions 1 and 2. A pipe connects junctions 12 and 13 with an associated weight of 53. The pipe between 1 and 12 serves a water demand of 56. The associated weight of the pipe between 1 and 11 is 59. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe connecting 12 and 15 carries an associated weight of 56. At the junction node 1, there is a tank. A water demand of 39 flows through the pipe between junctions 13 and 14. A pipe connects junctions 10 and 11 with an associated weight of 73. At the junction node 7, there is a tank. The pipe which runs between 11 and 24 carry a water demand of 48. The junctions 1 and 12 are connected by the pipe. The pipe linking junctions 1 and 2 has a water requirement of 39. Junctions 13 and 14 are joined by the pipe. Junctions 10 and 11 are joined by the pipe. There is a tank in the junction node 9. The junctions 12 and 13 are connected by the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5840683294315418112", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The junctions 12 and 15 are connected by the pipe. The associated weight of the pipe between 11 and 24 is 48. Only two valve(s) per pipe is permitted. There is a water demand of 56 in the pipe connecting junctions 12 and 15. A pipe establishes a link between junctions 11 and 24. You will find a tank at junction node 9. The valves that can be used are twenty. The pipe which runs between 1 and 11 carry a water demand of 59. At the junction node 7, there is a tank. Junctions 10 and 11 are connected through a pipe with a delivered water demand of 73. A tank exists at the junction node 1. Junctions 1 and 12 are connected through a pipe with a delivered water demand of 56. There is a water demand of 39 in the pipe connecting junctions 13 and 14. A water demand of 39 exists in the pipe between junctions 1 and 2. A pipe connects junctions 10 and 11. Junctions 13 and 14 are connected through the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A pipe connects junctions 12 and 13 with an associated weight of 53. The junctions 1 and 11 are connected by the pipe. Junctions 1 and 2 are connected through the pipe. A pipe connects junctions 12 and 13. Junctions 1 and 12 are connected through the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,11,59). dem(1,12,56). dem(1,2,39). dem(10,11,73). dem(11,24,48). dem(12,13,53). dem(12,15,56). dem(13,14,39). pipe(1,11). pipe(1,12). pipe(1,2). pipe(10,11). pipe(11,24). pipe(12,13). pipe(12,15). pipe(13,14). tank(1). tank(7). tank(9). valves_number(20). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The junctions 12 and 15 are connected by the pipe. The associated weight of the pipe between 11 and 24 is 48. Only two valve(s) per pipe is permitted. There is a water demand of 56 in the pipe connecting junctions 12 and 15. A pipe establishes a link between junctions 11 and 24. You will find a tank at junction node 9. The valves that can be used are twenty. The pipe which runs between 1 and 11 carry a water demand of 59. At the junction node 7, there is a tank. Junctions 10 and 11 are connected through a pipe with a delivered water demand of 73. A tank exists at the junction node 1. Junctions 1 and 12 are connected through a pipe with a delivered water demand of 56. There is a water demand of 39 in the pipe connecting junctions 13 and 14. A water demand of 39 exists in the pipe between junctions 1 and 2. A pipe connects junctions 10 and 11. Junctions 13 and 14 are connected through the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A pipe connects junctions 12 and 13 with an associated weight of 53. The junctions 1 and 11 are connected by the pipe. Junctions 1 and 2 are connected through the pipe. A pipe connects junctions 12 and 13. Junctions 1 and 12 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5667002127979501469", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The available valves are two. A pipe connects junctions 1 and 2 with an associated weight of 205. A pipe connects junctions 13 and 17 with an associated weight of 90. Junctions 11 and 12 are joined by the pipe. A pipe connects junctions 13 and 17. The pipe which runs between 11 and 14 carry a water demand of 82. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Junctions 1 and 2 are connected through the pipe. The pipe between 10 and 11 has an associated weight of 55. Junctions 13 and 14 are connected through the pipe. Junctions 12 and 13 are joined by the pipe. The junctions 11 and 14 are connected by the pipe. The pipe linking junctions 11 and 12 has a water requirement of 55. Only two valve(s) per pipe is permitted. The junctions 12 and 13 are connected by the pipe, with a water demand of 49. A water demand of 47 flows through the pipe between junctions 1 and 9. Junctions 1 and 9 are connected through the pipe. There is a tank in the junction node 1. The pipe connecting 13 and 14 carries an associated weight of 76. Junctions 10 and 11 are connected through the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,205). dem(1,9,47). dem(10,11,55). dem(11,12,55). dem(11,14,82). dem(12,13,49). dem(13,14,76). dem(13,17,90). pipe(1,2). pipe(1,9). pipe(10,11). pipe(11,12). pipe(11,14). pipe(12,13). pipe(13,14). pipe(13,17). tank(1). valves_number(2). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The available valves are two. A pipe connects junctions 1 and 2 with an associated weight of 205. A pipe connects junctions 13 and 17 with an associated weight of 90. Junctions 11 and 12 are joined by the pipe. A pipe connects junctions 13 and 17. The pipe which runs between 11 and 14 carry a water demand of 82. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Junctions 1 and 2 are connected through the pipe. The pipe between 10 and 11 has an associated weight of 55. Junctions 13 and 14 are connected through the pipe. Junctions 12 and 13 are joined by the pipe. The junctions 11 and 14 are connected by the pipe. The pipe linking junctions 11 and 12 has a water requirement of 55. Only two valve(s) per pipe is permitted. The junctions 12 and 13 are connected by the pipe, with a water demand of 49. A water demand of 47 flows through the pipe between junctions 1 and 9. Junctions 1 and 9 are connected through the pipe. There is a tank in the junction node 1. The pipe connecting 13 and 14 carries an associated weight of 76. Junctions 10 and 11 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "461180858872577180", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "There is a water demand of 246 in the pipe connecting junctions 11 and 12. The junctions 10 and 11 are connected by the pipe. The junctions 1 and 8 are connected by the pipe. The valves that can be used are twenty. The junctions 1 and 6 are connected by the pipe. A pipe connects junctions 10 and 16. A pipe connects junctions 1 and 2 with an associated weight of 40. The pipe connecting 1 and 8 carries an associated weight of 125. A pipe connects junctions 12 and 13. A tank is located at the junction node 1. There is a water demand of 157 in the pipe connecting junctions 10 and 16. The pipe connecting 12 and 13 has a water demand of 299. Junctions 1 and 2 are connected through the pipe. Junctions 11 and 16 are joined by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe between 1 and 6 has an associated weight of 100. The pipe connecting 11 and 16 carries an associated weight of 137. Junctions 11 and 12 are joined by the pipe. The associated weight of the pipe between 10 and 11 is 180. Each pipe can have only one valve(s).", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,40). dem(1,6,100). dem(1,8,125). dem(10,11,180). dem(10,16,157). dem(11,12,246). dem(11,16,137). dem(12,13,299). pipe(1,2). pipe(1,6). pipe(1,8). pipe(10,11). pipe(10,16). pipe(11,12). pipe(11,16). pipe(12,13). tank(1). valves_number(20). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```There is a water demand of 246 in the pipe connecting junctions 11 and 12. The junctions 10 and 11 are connected by the pipe. The junctions 1 and 8 are connected by the pipe. The valves that can be used are twenty. The junctions 1 and 6 are connected by the pipe. A pipe connects junctions 10 and 16. A pipe connects junctions 1 and 2 with an associated weight of 40. The pipe connecting 1 and 8 carries an associated weight of 125. A pipe connects junctions 12 and 13. A tank is located at the junction node 1. There is a water demand of 157 in the pipe connecting junctions 10 and 16. The pipe connecting 12 and 13 has a water demand of 299. Junctions 1 and 2 are connected through the pipe. Junctions 11 and 16 are joined by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe between 1 and 6 has an associated weight of 100. The pipe connecting 11 and 16 carries an associated weight of 137. Junctions 11 and 12 are joined by the pipe. The associated weight of the pipe between 10 and 11 is 180. Each pipe can have only one valve(s).```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5555618136934026757", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Only one valve(s) per pipe is permitted. A pipe connects junctions 10 and 17. A tank exists at the junction node 1. A pipe connects junctions 1 and 19. Between junctions 11 and 15, the pipe carries a water demand of 410. The associated weight of the pipe between 1 and 19 is 416. The associated weight of the pipe between 10 and 15 is 200. The associated weight of the pipe between 1 and 33 is 396. Junctions 10 and 16 are joined by the pipe. Junctions 10 and 17 are connected through a pipe with a delivered water demand of 75. The junctions 11 and 15 are connected by the pipe. The junctions 1 and 31 are connected by the pipe. The junctions 12 and 23 are connected by the pipe. Junctions 10 and 16 are connected through a pipe with a delivered water demand of 176. The available valves are nine. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe between 1 and 31 has an associated weight of 436. The junctions 1 and 33 are connected by the pipe. A pipe establishes a link between junctions 10 and 15. The associated weight of the pipe between 12 and 23 is 375. A tank is located at the junction node 2.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,416). dem(1,31,436). dem(1,33,396). dem(10,15,200). dem(10,16,176). dem(10,17,75). dem(11,15,410). dem(12,23,375). pipe(1,19). pipe(1,31). pipe(1,33). pipe(10,15). pipe(10,16). pipe(10,17). pipe(11,15). pipe(12,23). tank(1). tank(2). valves_number(9). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Only one valve(s) per pipe is permitted. A pipe connects junctions 10 and 17. A tank exists at the junction node 1. A pipe connects junctions 1 and 19. Between junctions 11 and 15, the pipe carries a water demand of 410. The associated weight of the pipe between 1 and 19 is 416. The associated weight of the pipe between 10 and 15 is 200. The associated weight of the pipe between 1 and 33 is 396. Junctions 10 and 16 are joined by the pipe. Junctions 10 and 17 are connected through a pipe with a delivered water demand of 75. The junctions 11 and 15 are connected by the pipe. The junctions 1 and 31 are connected by the pipe. The junctions 12 and 23 are connected by the pipe. Junctions 10 and 16 are connected through a pipe with a delivered water demand of 176. The available valves are nine. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe between 1 and 31 has an associated weight of 436. The junctions 1 and 33 are connected by the pipe. A pipe establishes a link between junctions 10 and 15. The associated weight of the pipe between 12 and 23 is 375. A tank is located at the junction node 2.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4488262643221506544", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The junctions 12 and 13 are connected by the pipe. No more than two valve(s) per pipe is allowed. You will find a tank at junction node 1. The junctions 1 and 6 are connected by the pipe, with a water demand of 100. The pipe connecting 12 and 13 carries an associated weight of 299. A pipe establishes a link between junctions 10 and 16. The junctions 1 and 2 are connected by the pipe, with a water demand of 40. Junctions 1 and 6 are joined by the pipe. Junctions 10 and 11 are connected through the pipe. There is a water demand of 180 in the pipe connecting junctions 10 and 11. The pipe between 11 and 16 has an associated weight of 137. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Between junctions 1 and 8, the pipe carries a water demand of 125. The available valves are eight. The pipe between 10 and 16 has an associated weight of 157. Junctions 11 and 12 are joined by the pipe. Junctions 1 and 2 are connected through the pipe. Junctions 11 and 12 are connected through a pipe with a delivered water demand of 246. A pipe establishes a link between junctions 11 and 16. Junctions 1 and 8 are connected through the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,40). dem(1,6,100). dem(1,8,125). dem(10,11,180). dem(10,16,157). dem(11,12,246). dem(11,16,137). dem(12,13,299). pipe(1,2). pipe(1,6). pipe(1,8). pipe(10,11). pipe(10,16). pipe(11,12). pipe(11,16). pipe(12,13). tank(1). valves_number(8). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The junctions 12 and 13 are connected by the pipe. No more than two valve(s) per pipe is allowed. You will find a tank at junction node 1. The junctions 1 and 6 are connected by the pipe, with a water demand of 100. The pipe connecting 12 and 13 carries an associated weight of 299. A pipe establishes a link between junctions 10 and 16. The junctions 1 and 2 are connected by the pipe, with a water demand of 40. Junctions 1 and 6 are joined by the pipe. Junctions 10 and 11 are connected through the pipe. There is a water demand of 180 in the pipe connecting junctions 10 and 11. The pipe between 11 and 16 has an associated weight of 137. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Between junctions 1 and 8, the pipe carries a water demand of 125. The available valves are eight. The pipe between 10 and 16 has an associated weight of 157. Junctions 11 and 12 are joined by the pipe. Junctions 1 and 2 are connected through the pipe. Junctions 11 and 12 are connected through a pipe with a delivered water demand of 246. A pipe establishes a link between junctions 11 and 16. Junctions 1 and 8 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7598365461208239899", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The junctions 10 and 15 are connected by the pipe, with a water demand of 200. Junctions 11 and 15 are connected through a pipe with a delivered water demand of 410. No more than one valve(s) per pipe is allowed. Junctions 11 and 15 are connected through the pipe. Junctions 12 and 23 are connected through the pipe. You will find a tank at junction node 1. A pipe connects junctions 1 and 31. Junctions 10 and 17 are connected through the pipe. There is a water demand of 396 in the pipe connecting junctions 1 and 33. Junctions 10 and 16 are connected through the pipe. The junctions 10 and 16 are connected by the pipe, with a water demand of 176. A pipe connects junctions 1 and 33. A water demand of 436 flows through the pipe between junctions 1 and 31. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. There is a water demand of 416 in the pipe connecting junctions 1 and 19. At the junction node 2, there is a tank. The pipe which runs between 10 and 17 carry a water demand of 75. The junctions 1 and 19 are connected by the pipe. The available valves are fifteen. Junctions 10 and 15 are connected through the pipe. The pipe between 12 and 23 serves a water demand of 375.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,416). dem(1,31,436). dem(1,33,396). dem(10,15,200). dem(10,16,176). dem(10,17,75). dem(11,15,410). dem(12,23,375). pipe(1,19). pipe(1,31). pipe(1,33). pipe(10,15). pipe(10,16). pipe(10,17). pipe(11,15). pipe(12,23). tank(1). tank(2). valves_number(15). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The junctions 10 and 15 are connected by the pipe, with a water demand of 200. Junctions 11 and 15 are connected through a pipe with a delivered water demand of 410. No more than one valve(s) per pipe is allowed. Junctions 11 and 15 are connected through the pipe. Junctions 12 and 23 are connected through the pipe. You will find a tank at junction node 1. A pipe connects junctions 1 and 31. Junctions 10 and 17 are connected through the pipe. There is a water demand of 396 in the pipe connecting junctions 1 and 33. Junctions 10 and 16 are connected through the pipe. The junctions 10 and 16 are connected by the pipe, with a water demand of 176. A pipe connects junctions 1 and 33. A water demand of 436 flows through the pipe between junctions 1 and 31. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. There is a water demand of 416 in the pipe connecting junctions 1 and 19. At the junction node 2, there is a tank. The pipe which runs between 10 and 17 carry a water demand of 75. The junctions 1 and 19 are connected by the pipe. The available valves are fifteen. Junctions 10 and 15 are connected through the pipe. The pipe between 12 and 23 serves a water demand of 375.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6075126805286074944", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Junctions 100 and 104 are joined by the pipe. Junctions 1 and 96 are connected through a pipe with a delivered water demand of 60. There is a water demand of 122 in the pipe connecting junctions 101 and 103. Junctions 101 and 103 are connected through the pipe. A pipe establishes a link between junctions 102 and 103. The junctions 1 and 95 are connected by the pipe. A pipe connects junctions 101 and 102. Between junctions 101 and 102, the pipe carries a water demand of 163. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. Between junctions 100 and 104, the pipe carries a water demand of 96. There is a water demand of 125 in the pipe connecting junctions 102 and 103. The junctions 1 and 96 are connected by the pipe. The associated weight of the pipe between 1 and 95 is 89. At the junction node 1, there is a tank. A pipe connects junctions 1 and 92 with an associated weight of 108. The valves that can be used are sixteen. Junctions 1 and 92 are joined by the pipe. The pipe which runs between 100 and 101 carry a water demand of 133. Only two valve/s per pipe is/are allowed. The junctions 100 and 101 are connected by the pipe.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(16). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Junctions 100 and 104 are joined by the pipe. Junctions 1 and 96 are connected through a pipe with a delivered water demand of 60. There is a water demand of 122 in the pipe connecting junctions 101 and 103. Junctions 101 and 103 are connected through the pipe. A pipe establishes a link between junctions 102 and 103. The junctions 1 and 95 are connected by the pipe. A pipe connects junctions 101 and 102. Between junctions 101 and 102, the pipe carries a water demand of 163. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. Between junctions 100 and 104, the pipe carries a water demand of 96. There is a water demand of 125 in the pipe connecting junctions 102 and 103. The junctions 1 and 96 are connected by the pipe. The associated weight of the pipe between 1 and 95 is 89. At the junction node 1, there is a tank. A pipe connects junctions 1 and 92 with an associated weight of 108. The valves that can be used are sixteen. Junctions 1 and 92 are joined by the pipe. The pipe which runs between 100 and 101 carry a water demand of 133. Only two valve/s per pipe is/are allowed. The junctions 100 and 101 are connected by the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3014763944428284327", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "At the junction node 1, there is a tank. A water demand of 416 exists in the pipe between junctions 1 and 19. The pipe connecting 11 and 15 has a water demand of 410. Between junctions 1 and 31, the pipe carries a water demand of 436. Junctions 10 and 17 are connected through the pipe. Junctions 10 and 17 are connected through a pipe with a delivered water demand of 75. At the junction node 2, there is a tank. The valves that can be used are sixteen. The junctions 1 and 31 are connected by the pipe. Junctions 11 and 15 are connected through the pipe. A water demand of 375 exists in the pipe between junctions 12 and 23. A pipe connects junctions 1 and 33. The pipe between 1 and 33 serves a water demand of 396. Junctions 10 and 16 are connected through the pipe. Each pipe can have only two valve(s). The junctions 10 and 15 are connected by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The associated weight of the pipe between 10 and 15 is 200. The pipe which runs between 10 and 16 carry a water demand of 176. Junctions 12 and 23 are joined by the pipe. Junctions 1 and 19 are connected through the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,416). dem(1,31,436). dem(1,33,396). dem(10,15,200). dem(10,16,176). dem(10,17,75). dem(11,15,410). dem(12,23,375). pipe(1,19). pipe(1,31). pipe(1,33). pipe(10,15). pipe(10,16). pipe(10,17). pipe(11,15). pipe(12,23). tank(1). tank(2). valves_number(16). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```At the junction node 1, there is a tank. A water demand of 416 exists in the pipe between junctions 1 and 19. The pipe connecting 11 and 15 has a water demand of 410. Between junctions 1 and 31, the pipe carries a water demand of 436. Junctions 10 and 17 are connected through the pipe. Junctions 10 and 17 are connected through a pipe with a delivered water demand of 75. At the junction node 2, there is a tank. The valves that can be used are sixteen. The junctions 1 and 31 are connected by the pipe. Junctions 11 and 15 are connected through the pipe. A water demand of 375 exists in the pipe between junctions 12 and 23. A pipe connects junctions 1 and 33. The pipe between 1 and 33 serves a water demand of 396. Junctions 10 and 16 are connected through the pipe. Each pipe can have only two valve(s). The junctions 10 and 15 are connected by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The associated weight of the pipe between 10 and 15 is 200. The pipe which runs between 10 and 16 carry a water demand of 176. Junctions 12 and 23 are joined by the pipe. Junctions 1 and 19 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "429201025260350090", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A pipe establishes a link between junctions 1 and 33. The pipe connecting 1 and 31 carries an associated weight of 436. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The available valves are twenty-two. The pipe which runs between 1 and 19 carry a water demand of 416. You will find a tank at junction node 1. The junctions 1 and 31 are connected by the pipe. Junctions 1 and 19 are joined by the pipe. No more than two valve(s) per pipe is allowed. Between junctions 11 and 15, the pipe carries a water demand of 410. Junctions 12 and 23 are joined by the pipe. A pipe establishes a link between junctions 10 and 16. Junctions 10 and 15 are connected through a pipe with a delivered water demand of 200. Junctions 10 and 15 are connected through the pipe. A pipe establishes a link between junctions 11 and 15. Between junctions 12 and 23, the pipe carries a water demand of 375. Junctions 10 and 16 are connected through a pipe with a delivered water demand of 176. The pipe between 10 and 17 has an associated weight of 75. A tank exists at the junction node 2. Junctions 10 and 17 are joined by the pipe. There is a water demand of 396 in the pipe connecting junctions 1 and 33.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,416). dem(1,31,436). dem(1,33,396). dem(10,15,200). dem(10,16,176). dem(10,17,75). dem(11,15,410). dem(12,23,375). pipe(1,19). pipe(1,31). pipe(1,33). pipe(10,15). pipe(10,16). pipe(10,17). pipe(11,15). pipe(12,23). tank(1). tank(2). valves_number(22). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A pipe establishes a link between junctions 1 and 33. The pipe connecting 1 and 31 carries an associated weight of 436. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The available valves are twenty-two. The pipe which runs between 1 and 19 carry a water demand of 416. You will find a tank at junction node 1. The junctions 1 and 31 are connected by the pipe. Junctions 1 and 19 are joined by the pipe. No more than two valve(s) per pipe is allowed. Between junctions 11 and 15, the pipe carries a water demand of 410. Junctions 12 and 23 are joined by the pipe. A pipe establishes a link between junctions 10 and 16. Junctions 10 and 15 are connected through a pipe with a delivered water demand of 200. Junctions 10 and 15 are connected through the pipe. A pipe establishes a link between junctions 11 and 15. Between junctions 12 and 23, the pipe carries a water demand of 375. Junctions 10 and 16 are connected through a pipe with a delivered water demand of 176. The pipe between 10 and 17 has an associated weight of 75. A tank exists at the junction node 2. Junctions 10 and 17 are joined by the pipe. There is a water demand of 396 in the pipe connecting junctions 1 and 33.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2763000009836624220", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A pipe establishes a link between junctions 104 and 105. The pipe connecting 102 and 109 has a water demand of 6. The pipe which runs between 1 and 4 carry a water demand of 200. The junctions 102 and 109 are connected by the pipe. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The associated weight of the pipe between 103 and 104 is 3. The junctions 101 and 110 are connected by the pipe. The available valves are eleven. The junctions 103 and 104 are connected by the pipe. Junctions 101 and 102 are connected through the pipe. The pipe linking junctions 1 and 6 has a water requirement of 300. Junctions 1 and 6 are joined by the pipe. The pipe which runs between 104 and 105 carry a water demand of 6. The associated weight of the pipe between 104 and 106 is 6. The pipe which runs between 101 and 102 carry a water demand of 6. The pipe which runs between 101 and 110 carry a water demand of 6. Only two valve(s) per pipe is permitted. Junctions 104 and 106 are connected through the pipe. A pipe connects junctions 1 and 4. You will find a tank at junction node 1.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,4,200). dem(1,6,300). dem(101,102,6). dem(101,110,6). dem(102,109,6). dem(103,104,3). dem(104,105,6). dem(104,106,6). pipe(1,4). pipe(1,6). pipe(101,102). pipe(101,110). pipe(102,109). pipe(103,104). pipe(104,105). pipe(104,106). tank(1). valves_number(11). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A pipe establishes a link between junctions 104 and 105. The pipe connecting 102 and 109 has a water demand of 6. The pipe which runs between 1 and 4 carry a water demand of 200. The junctions 102 and 109 are connected by the pipe. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The associated weight of the pipe between 103 and 104 is 3. The junctions 101 and 110 are connected by the pipe. The available valves are eleven. The junctions 103 and 104 are connected by the pipe. Junctions 101 and 102 are connected through the pipe. The pipe linking junctions 1 and 6 has a water requirement of 300. Junctions 1 and 6 are joined by the pipe. The pipe which runs between 104 and 105 carry a water demand of 6. The associated weight of the pipe between 104 and 106 is 6. The pipe which runs between 101 and 102 carry a water demand of 6. The pipe which runs between 101 and 110 carry a water demand of 6. Only two valve(s) per pipe is permitted. Junctions 104 and 106 are connected through the pipe. A pipe connects junctions 1 and 4. You will find a tank at junction node 1.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6557333278749447533", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "At the junction node 1, there is a tank. A pipe establishes a link between junctions 11 and 12. The valves that can be used are nine. A pipe connects junctions 1 and 6 with an associated weight of 100. A pipe establishes a link between junctions 1 and 6. A pipe establishes a link between junctions 10 and 16. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The junctions 1 and 8 are connected by the pipe. The pipe linking junctions 1 and 8 has a water requirement of 125. Only two valve(s) can be used per pipe. Junctions 11 and 16 are connected through the pipe. The associated weight of the pipe between 1 and 2 is 40. A pipe connects junctions 10 and 11. A water demand of 157 exists in the pipe between junctions 10 and 16. The pipe connecting 11 and 12 has a water demand of 246. Junctions 12 and 13 are joined by the pipe. The pipe between 12 and 13 has an associated weight of 299. There is a water demand of 180 in the pipe connecting junctions 10 and 11. The junctions 1 and 2 are connected by the pipe. The pipe connecting 11 and 16 carries an associated weight of 137.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,40). dem(1,6,100). dem(1,8,125). dem(10,11,180). dem(10,16,157). dem(11,12,246). dem(11,16,137). dem(12,13,299). pipe(1,2). pipe(1,6). pipe(1,8). pipe(10,11). pipe(10,16). pipe(11,12). pipe(11,16). pipe(12,13). tank(1). valves_number(9). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```At the junction node 1, there is a tank. A pipe establishes a link between junctions 11 and 12. The valves that can be used are nine. A pipe connects junctions 1 and 6 with an associated weight of 100. A pipe establishes a link between junctions 1 and 6. A pipe establishes a link between junctions 10 and 16. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The junctions 1 and 8 are connected by the pipe. The pipe linking junctions 1 and 8 has a water requirement of 125. Only two valve(s) can be used per pipe. Junctions 11 and 16 are connected through the pipe. The associated weight of the pipe between 1 and 2 is 40. A pipe connects junctions 10 and 11. A water demand of 157 exists in the pipe between junctions 10 and 16. The pipe connecting 11 and 12 has a water demand of 246. Junctions 12 and 13 are joined by the pipe. The pipe between 12 and 13 has an associated weight of 299. There is a water demand of 180 in the pipe connecting junctions 10 and 11. The junctions 1 and 2 are connected by the pipe. The pipe connecting 11 and 16 carries an associated weight of 137.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8509691830639684352", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A pipe connects junctions 100 and 101. Junctions 1 and 95 are joined by the pipe. The junctions 101 and 102 are connected by the pipe. A pipe establishes a link between junctions 101 and 103. The pipe connecting 102 and 103 has a water demand of 125. The associated weight of the pipe between 100 and 101 is 133. The junctions 100 and 104 are connected by the pipe. The junctions 1 and 96 are connected by the pipe. Only two valve/s per pipe is/are allowed. Junctions 102 and 103 are connected through the pipe. A tank is located at the junction node 1. Between junctions 101 and 102, the pipe carries a water demand of 163. The junctions 1 and 92 are connected by the pipe. The available valves are seven. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. Between junctions 101 and 103, the pipe carries a water demand of 122. Junctions 1 and 95 are connected through a pipe with a delivered water demand of 89. There is a water demand of 108 in the pipe connecting junctions 1 and 92. A pipe connects junctions 1 and 96 with an associated weight of 60. A water demand of 96 exists in the pipe between junctions 100 and 104.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(7). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A pipe connects junctions 100 and 101. Junctions 1 and 95 are joined by the pipe. The junctions 101 and 102 are connected by the pipe. A pipe establishes a link between junctions 101 and 103. The pipe connecting 102 and 103 has a water demand of 125. The associated weight of the pipe between 100 and 101 is 133. The junctions 100 and 104 are connected by the pipe. The junctions 1 and 96 are connected by the pipe. Only two valve/s per pipe is/are allowed. Junctions 102 and 103 are connected through the pipe. A tank is located at the junction node 1. Between junctions 101 and 102, the pipe carries a water demand of 163. The junctions 1 and 92 are connected by the pipe. The available valves are seven. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. Between junctions 101 and 103, the pipe carries a water demand of 122. Junctions 1 and 95 are connected through a pipe with a delivered water demand of 89. There is a water demand of 108 in the pipe connecting junctions 1 and 92. A pipe connects junctions 1 and 96 with an associated weight of 60. A water demand of 96 exists in the pipe between junctions 100 and 104.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6643416775036868890", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The junctions 11 and 12 are connected by the pipe. A pipe connects junctions 13 and 17. The valves that can be used are twenty. The pipe connecting 1 and 9 carries an associated weight of 47. The pipe linking junctions 13 and 17 has a water requirement of 90. The pipe between 13 and 14 serves a water demand of 76. Each pipe can have only two valve(s). A pipe connects junctions 11 and 14. A pipe connects junctions 10 and 11. Junctions 1 and 2 are connected through the pipe. The pipe linking junctions 12 and 13 has a water requirement of 49. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The junctions 1 and 9 are connected by the pipe. Junctions 13 and 14 are joined by the pipe. The junctions 12 and 13 are connected by the pipe. The pipe connecting 11 and 12 has a water demand of 55. The junctions 10 and 11 are connected by the pipe, with a water demand of 55. At the junction node 1, there is a tank. A pipe connects junctions 1 and 2 with an associated weight of 205. The pipe connecting 11 and 14 has a water demand of 82.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,205). dem(1,9,47). dem(10,11,55). dem(11,12,55). dem(11,14,82). dem(12,13,49). dem(13,14,76). dem(13,17,90). pipe(1,2). pipe(1,9). pipe(10,11). pipe(11,12). pipe(11,14). pipe(12,13). pipe(13,14). pipe(13,17). tank(1). valves_number(20). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The junctions 11 and 12 are connected by the pipe. A pipe connects junctions 13 and 17. The valves that can be used are twenty. The pipe connecting 1 and 9 carries an associated weight of 47. The pipe linking junctions 13 and 17 has a water requirement of 90. The pipe between 13 and 14 serves a water demand of 76. Each pipe can have only two valve(s). A pipe connects junctions 11 and 14. A pipe connects junctions 10 and 11. Junctions 1 and 2 are connected through the pipe. The pipe linking junctions 12 and 13 has a water requirement of 49. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The junctions 1 and 9 are connected by the pipe. Junctions 13 and 14 are joined by the pipe. The junctions 12 and 13 are connected by the pipe. The pipe connecting 11 and 12 has a water demand of 55. The junctions 10 and 11 are connected by the pipe, with a water demand of 55. At the junction node 1, there is a tank. A pipe connects junctions 1 and 2 with an associated weight of 205. The pipe connecting 11 and 14 has a water demand of 82.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8903888449875684134", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A water demand of 396 exists in the pipe between junctions 1 and 33. A water demand of 176 exists in the pipe between junctions 10 and 16. You will find a tank at junction node 1. The pipe between 10 and 15 has an associated weight of 200. The pipe between 12 and 23 has an associated weight of 375. The junctions 10 and 15 are connected by the pipe. Only two valve/s per pipe is/are allowed. A pipe establishes a link between junctions 11 and 15. A pipe connects junctions 1 and 31. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A water demand of 436 flows through the pipe between junctions 1 and 31. The available valves are five. A pipe establishes a link between junctions 1 and 19. The pipe connecting 11 and 15 carries an associated weight of 410. The pipe connecting 1 and 19 has a water demand of 416. Junctions 10 and 17 are joined by the pipe. There is a tank in the junction node 2. Junctions 10 and 16 are connected through the pipe. The junctions 12 and 23 are connected by the pipe. Junctions 1 and 33 are joined by the pipe. A pipe connects junctions 10 and 17 with an associated weight of 75.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,416). dem(1,31,436). dem(1,33,396). dem(10,15,200). dem(10,16,176). dem(10,17,75). dem(11,15,410). dem(12,23,375). pipe(1,19). pipe(1,31). pipe(1,33). pipe(10,15). pipe(10,16). pipe(10,17). pipe(11,15). pipe(12,23). tank(1). tank(2). valves_number(5). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A water demand of 396 exists in the pipe between junctions 1 and 33. A water demand of 176 exists in the pipe between junctions 10 and 16. You will find a tank at junction node 1. The pipe between 10 and 15 has an associated weight of 200. The pipe between 12 and 23 has an associated weight of 375. The junctions 10 and 15 are connected by the pipe. Only two valve/s per pipe is/are allowed. A pipe establishes a link between junctions 11 and 15. A pipe connects junctions 1 and 31. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A water demand of 436 flows through the pipe between junctions 1 and 31. The available valves are five. A pipe establishes a link between junctions 1 and 19. The pipe connecting 11 and 15 carries an associated weight of 410. The pipe connecting 1 and 19 has a water demand of 416. Junctions 10 and 17 are joined by the pipe. There is a tank in the junction node 2. Junctions 10 and 16 are connected through the pipe. The junctions 12 and 23 are connected by the pipe. Junctions 1 and 33 are joined by the pipe. A pipe connects junctions 10 and 17 with an associated weight of 75.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4965386438739650868", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Junctions 10 and 16 are connected through the pipe. At the junction node 1, there is a tank. There is a water demand of 375 in the pipe connecting junctions 12 and 23. Junctions 1 and 31 are joined by the pipe. The valves that can be used are sixteen. Each pipe can have only one valve(s). The pipe connecting 10 and 15 has a water demand of 200. You will find a tank at junction node 2. A pipe connects junctions 10 and 16 with an associated weight of 176. A pipe establishes a link between junctions 11 and 15. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The associated weight of the pipe between 1 and 31 is 436. A water demand of 396 exists in the pipe between junctions 1 and 33. There is a water demand of 416 in the pipe connecting junctions 1 and 19. Junctions 12 and 23 are joined by the pipe. The junctions 10 and 15 are connected by the pipe. The pipe which runs between 10 and 17 carry a water demand of 75. Junctions 10 and 17 are connected through the pipe. Junctions 1 and 19 are connected through the pipe. The pipe connecting 11 and 15 carries an associated weight of 410. The junctions 1 and 33 are connected by the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,416). dem(1,31,436). dem(1,33,396). dem(10,15,200). dem(10,16,176). dem(10,17,75). dem(11,15,410). dem(12,23,375). pipe(1,19). pipe(1,31). pipe(1,33). pipe(10,15). pipe(10,16). pipe(10,17). pipe(11,15). pipe(12,23). tank(1). tank(2). valves_number(16). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Junctions 10 and 16 are connected through the pipe. At the junction node 1, there is a tank. There is a water demand of 375 in the pipe connecting junctions 12 and 23. Junctions 1 and 31 are joined by the pipe. The valves that can be used are sixteen. Each pipe can have only one valve(s). The pipe connecting 10 and 15 has a water demand of 200. You will find a tank at junction node 2. A pipe connects junctions 10 and 16 with an associated weight of 176. A pipe establishes a link between junctions 11 and 15. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The associated weight of the pipe between 1 and 31 is 436. A water demand of 396 exists in the pipe between junctions 1 and 33. There is a water demand of 416 in the pipe connecting junctions 1 and 19. Junctions 12 and 23 are joined by the pipe. The junctions 10 and 15 are connected by the pipe. The pipe which runs between 10 and 17 carry a water demand of 75. Junctions 10 and 17 are connected through the pipe. Junctions 1 and 19 are connected through the pipe. The pipe connecting 11 and 15 carries an associated weight of 410. The junctions 1 and 33 are connected by the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3707411709347196383", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The junctions 1 and 8 are connected by the pipe. The pipe which runs between 12 and 13 carry a water demand of 299. The junctions 10 and 11 are connected by the pipe. Only two valve(s) per pipe is permitted. Junctions 10 and 16 are connected through the pipe. The pipe connecting 10 and 16 carries an associated weight of 157. Junctions 1 and 6 are connected through the pipe. Between junctions 1 and 2, the pipe carries a water demand of 40. Junctions 12 and 13 are connected through the pipe. You will find a tank at junction node 1. A water demand of 180 exists in the pipe between junctions 10 and 11. The pipe between 11 and 12 has an associated weight of 246. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe linking junctions 1 and 8 has a water requirement of 125. A water demand of 100 exists in the pipe between junctions 1 and 6. A pipe establishes a link between junctions 11 and 12. The valves that can be used are nineteen. A pipe connects junctions 1 and 2. The pipe between 11 and 16 has an associated weight of 137. Junctions 11 and 16 are connected through the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,40). dem(1,6,100). dem(1,8,125). dem(10,11,180). dem(10,16,157). dem(11,12,246). dem(11,16,137). dem(12,13,299). pipe(1,2). pipe(1,6). pipe(1,8). pipe(10,11). pipe(10,16). pipe(11,12). pipe(11,16). pipe(12,13). tank(1). valves_number(19). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The junctions 1 and 8 are connected by the pipe. The pipe which runs between 12 and 13 carry a water demand of 299. The junctions 10 and 11 are connected by the pipe. Only two valve(s) per pipe is permitted. Junctions 10 and 16 are connected through the pipe. The pipe connecting 10 and 16 carries an associated weight of 157. Junctions 1 and 6 are connected through the pipe. Between junctions 1 and 2, the pipe carries a water demand of 40. Junctions 12 and 13 are connected through the pipe. You will find a tank at junction node 1. A water demand of 180 exists in the pipe between junctions 10 and 11. The pipe between 11 and 12 has an associated weight of 246. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe linking junctions 1 and 8 has a water requirement of 125. A water demand of 100 exists in the pipe between junctions 1 and 6. A pipe establishes a link between junctions 11 and 12. The valves that can be used are nineteen. A pipe connects junctions 1 and 2. The pipe between 11 and 16 has an associated weight of 137. Junctions 11 and 16 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "171346434066795401", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Junctions 1 and 9 are joined by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. You will find a tank at junction node 1. The junctions 13 and 14 are connected by the pipe. Junctions 11 and 14 are joined by the pipe. The pipe which runs between 1 and 2 carry a water demand of 205. Junctions 13 and 17 are joined by the pipe. A pipe connects junctions 12 and 13. Junctions 1 and 2 are connected through the pipe. A water demand of 55 flows through the pipe between junctions 10 and 11. The pipe connecting 1 and 9 has a water demand of 47. The pipe which runs between 11 and 12 carry a water demand of 55. The pipe which runs between 13 and 14 carry a water demand of 76. Only one valve(s) per pipe is permitted. A water demand of 82 exists in the pipe between junctions 11 and 14. A pipe connects junctions 10 and 11. The junctions 11 and 12 are connected by the pipe. The valves that can be used are twenty-one. A water demand of 90 flows through the pipe between junctions 13 and 17. The pipe connecting 12 and 13 has a water demand of 49.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,205). dem(1,9,47). dem(10,11,55). dem(11,12,55). dem(11,14,82). dem(12,13,49). dem(13,14,76). dem(13,17,90). pipe(1,2). pipe(1,9). pipe(10,11). pipe(11,12). pipe(11,14). pipe(12,13). pipe(13,14). pipe(13,17). tank(1). valves_number(21). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Junctions 1 and 9 are joined by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. You will find a tank at junction node 1. The junctions 13 and 14 are connected by the pipe. Junctions 11 and 14 are joined by the pipe. The pipe which runs between 1 and 2 carry a water demand of 205. Junctions 13 and 17 are joined by the pipe. A pipe connects junctions 12 and 13. Junctions 1 and 2 are connected through the pipe. A water demand of 55 flows through the pipe between junctions 10 and 11. The pipe connecting 1 and 9 has a water demand of 47. The pipe which runs between 11 and 12 carry a water demand of 55. The pipe which runs between 13 and 14 carry a water demand of 76. Only one valve(s) per pipe is permitted. A water demand of 82 exists in the pipe between junctions 11 and 14. A pipe connects junctions 10 and 11. The junctions 11 and 12 are connected by the pipe. The valves that can be used are twenty-one. A water demand of 90 flows through the pipe between junctions 13 and 17. The pipe connecting 12 and 13 has a water demand of 49.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6745939202177139853", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The pipe linking junctions 11 and 24 has a water requirement of 48. The pipe connecting 1 and 11 has a water demand of 59. A pipe connects junctions 11 and 24. Only two valve(s) can be used per pipe. The valves that can be used are ten. A water demand of 56 flows through the pipe between junctions 1 and 12. A pipe establishes a link between junctions 1 and 12. A pipe establishes a link between junctions 1 and 11. The junctions 12 and 13 are connected by the pipe. A pipe establishes a link between junctions 1 and 2. A tank exists at the junction node 1. Junctions 13 and 14 are connected through a pipe with a delivered water demand of 39. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A tank is located at the junction node 9. The pipe which runs between 12 and 13 carry a water demand of 53. The pipe connecting 12 and 15 has a water demand of 56. Junctions 13 and 14 are joined by the pipe. The pipe connecting 1 and 2 has a water demand of 39. A pipe establishes a link between junctions 10 and 11. The pipe between 10 and 11 serves a water demand of 73. Junctions 12 and 15 are connected through the pipe. There is a tank in the junction node 7.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,11,59). dem(1,12,56). dem(1,2,39). dem(10,11,73). dem(11,24,48). dem(12,13,53). dem(12,15,56). dem(13,14,39). pipe(1,11). pipe(1,12). pipe(1,2). pipe(10,11). pipe(11,24). pipe(12,13). pipe(12,15). pipe(13,14). tank(1). tank(7). tank(9). valves_number(10). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The pipe linking junctions 11 and 24 has a water requirement of 48. The pipe connecting 1 and 11 has a water demand of 59. A pipe connects junctions 11 and 24. Only two valve(s) can be used per pipe. The valves that can be used are ten. A water demand of 56 flows through the pipe between junctions 1 and 12. A pipe establishes a link between junctions 1 and 12. A pipe establishes a link between junctions 1 and 11. The junctions 12 and 13 are connected by the pipe. A pipe establishes a link between junctions 1 and 2. A tank exists at the junction node 1. Junctions 13 and 14 are connected through a pipe with a delivered water demand of 39. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A tank is located at the junction node 9. The pipe which runs between 12 and 13 carry a water demand of 53. The pipe connecting 12 and 15 has a water demand of 56. Junctions 13 and 14 are joined by the pipe. The pipe connecting 1 and 2 has a water demand of 39. A pipe establishes a link between junctions 10 and 11. The pipe between 10 and 11 serves a water demand of 73. Junctions 12 and 15 are connected through the pipe. There is a tank in the junction node 7.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3579842240634315635", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "There is a tank in the junction node 1. The junctions 13 and 17 are connected by the pipe. A water demand of 82 exists in the pipe between junctions 11 and 14. The junctions 13 and 14 are connected by the pipe. The junctions 1 and 2 are connected by the pipe. A water demand of 55 exists in the pipe between junctions 11 and 12. Only one valve/s per pipe is/are allowed. The pipe between 1 and 2 serves a water demand of 205. There is a water demand of 76 in the pipe connecting junctions 13 and 14. The valves that can be used are nine. Between junctions 13 and 17, the pipe carries a water demand of 90. A pipe connects junctions 12 and 13. A pipe connects junctions 11 and 12. The associated weight of the pipe between 10 and 11 is 55. The junctions 1 and 9 are connected by the pipe, with a water demand of 47. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A pipe connects junctions 10 and 11. The junctions 11 and 14 are connected by the pipe. There is a water demand of 49 in the pipe connecting junctions 12 and 13. A pipe establishes a link between junctions 1 and 9.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,205). dem(1,9,47). dem(10,11,55). dem(11,12,55). dem(11,14,82). dem(12,13,49). dem(13,14,76). dem(13,17,90). pipe(1,2). pipe(1,9). pipe(10,11). pipe(11,12). pipe(11,14). pipe(12,13). pipe(13,14). pipe(13,17). tank(1). valves_number(9). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```There is a tank in the junction node 1. The junctions 13 and 17 are connected by the pipe. A water demand of 82 exists in the pipe between junctions 11 and 14. The junctions 13 and 14 are connected by the pipe. The junctions 1 and 2 are connected by the pipe. A water demand of 55 exists in the pipe between junctions 11 and 12. Only one valve/s per pipe is/are allowed. The pipe between 1 and 2 serves a water demand of 205. There is a water demand of 76 in the pipe connecting junctions 13 and 14. The valves that can be used are nine. Between junctions 13 and 17, the pipe carries a water demand of 90. A pipe connects junctions 12 and 13. A pipe connects junctions 11 and 12. The associated weight of the pipe between 10 and 11 is 55. The junctions 1 and 9 are connected by the pipe, with a water demand of 47. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A pipe connects junctions 10 and 11. The junctions 11 and 14 are connected by the pipe. There is a water demand of 49 in the pipe connecting junctions 12 and 13. A pipe establishes a link between junctions 1 and 9.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6926800131572751260", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Only one valve(s) can be used per pipe. Junctions 13 and 22 are connected through a pipe with a delivered water demand of 166. Junctions 11 and 12 are joined by the pipe. The junctions 10 and 11 are connected by the pipe. A pipe establishes a link between junctions 12 and 13. The junctions 1 and 2 are connected by the pipe. The valves that can be used are twelve. The junctions 12 and 13 are connected by the pipe, with a water demand of 68. At the junction node 1, there is a tank. The pipe connecting 1 and 5 carries an associated weight of 66. A water demand of 95 exists in the pipe between junctions 1 and 19. The pipe connecting 11 and 12 has a water demand of 83. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe connecting 10 and 13 has a water demand of 70. The pipe connecting 10 and 11 has a water demand of 70. Junctions 10 and 13 are connected through the pipe. A pipe establishes a link between junctions 1 and 5. A pipe connects junctions 13 and 22. A pipe connects junctions 1 and 2 with an associated weight of 57. A pipe connects junctions 1 and 19.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,95). dem(1,2,57). dem(1,5,66). dem(10,11,70). dem(10,13,70). dem(11,12,83). dem(12,13,68). dem(13,22,166). pipe(1,19). pipe(1,2). pipe(1,5). pipe(10,11). pipe(10,13). pipe(11,12). pipe(12,13). pipe(13,22). tank(1). valves_number(12). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Only one valve(s) can be used per pipe. Junctions 13 and 22 are connected through a pipe with a delivered water demand of 166. Junctions 11 and 12 are joined by the pipe. The junctions 10 and 11 are connected by the pipe. A pipe establishes a link between junctions 12 and 13. The junctions 1 and 2 are connected by the pipe. The valves that can be used are twelve. The junctions 12 and 13 are connected by the pipe, with a water demand of 68. At the junction node 1, there is a tank. The pipe connecting 1 and 5 carries an associated weight of 66. A water demand of 95 exists in the pipe between junctions 1 and 19. The pipe connecting 11 and 12 has a water demand of 83. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. The pipe connecting 10 and 13 has a water demand of 70. The pipe connecting 10 and 11 has a water demand of 70. Junctions 10 and 13 are connected through the pipe. A pipe establishes a link between junctions 1 and 5. A pipe connects junctions 13 and 22. A pipe connects junctions 1 and 2 with an associated weight of 57. A pipe connects junctions 1 and 19.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "9048414033545935635", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The pipe between 101 and 103 serves a water demand of 122. A water demand of 89 flows through the pipe between junctions 1 and 95. The available valves are twelve. The pipe linking junctions 102 and 103 has a water requirement of 125. Junctions 1 and 92 are connected through the pipe. Junctions 1 and 95 are connected through the pipe. At the junction node 1, there is a tank. A pipe establishes a link between junctions 101 and 102. The pipe between 100 and 101 has an associated weight of 133. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The pipe connecting 100 and 104 has a water demand of 96. A pipe connects junctions 102 and 103. Junctions 101 and 103 are connected through the pipe. Junctions 100 and 101 are joined by the pipe. No more than two valve(s) per pipe is allowed. The associated weight of the pipe between 101 and 102 is 163. A water demand of 60 exists in the pipe between junctions 1 and 96. Junctions 1 and 96 are joined by the pipe. Junctions 100 and 104 are connected through the pipe. The pipe connecting 1 and 92 has a water demand of 108.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(12). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The pipe between 101 and 103 serves a water demand of 122. A water demand of 89 flows through the pipe between junctions 1 and 95. The available valves are twelve. The pipe linking junctions 102 and 103 has a water requirement of 125. Junctions 1 and 92 are connected through the pipe. Junctions 1 and 95 are connected through the pipe. At the junction node 1, there is a tank. A pipe establishes a link between junctions 101 and 102. The pipe between 100 and 101 has an associated weight of 133. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The pipe connecting 100 and 104 has a water demand of 96. A pipe connects junctions 102 and 103. Junctions 101 and 103 are connected through the pipe. Junctions 100 and 101 are joined by the pipe. No more than two valve(s) per pipe is allowed. The associated weight of the pipe between 101 and 102 is 163. A water demand of 60 exists in the pipe between junctions 1 and 96. Junctions 1 and 96 are joined by the pipe. Junctions 100 and 104 are connected through the pipe. The pipe connecting 1 and 92 has a water demand of 108.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5432176184542800798", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Junctions 1 and 2 are joined by the pipe. You will find a tank at junction node 7. Between junctions 10 and 11, the pipe carries a water demand of 73. The junctions 12 and 13 are connected by the pipe. The pipe linking junctions 12 and 13 has a water requirement of 53. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A pipe establishes a link between junctions 11 and 24. There is a tank in the junction node 9. At the junction node 1, there is a tank. Junctions 12 and 15 are connected through a pipe with a delivered water demand of 56. The available valves are thirteen. Junctions 13 and 14 are joined by the pipe. The pipe connecting 1 and 12 has a water demand of 56. The pipe which runs between 1 and 2 carry a water demand of 39. The junctions 12 and 15 are connected by the pipe. A pipe establishes a link between junctions 1 and 11. The pipe between 1 and 11 has an associated weight of 59. The pipe which runs between 11 and 24 carry a water demand of 48. The pipe which runs between 13 and 14 carry a water demand of 39. No more than two valve(s) per pipe is allowed. A pipe connects junctions 1 and 12. Junctions 10 and 11 are connected through the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,11,59). dem(1,12,56). dem(1,2,39). dem(10,11,73). dem(11,24,48). dem(12,13,53). dem(12,15,56). dem(13,14,39). pipe(1,11). pipe(1,12). pipe(1,2). pipe(10,11). pipe(11,24). pipe(12,13). pipe(12,15). pipe(13,14). tank(1). tank(7). tank(9). valves_number(13). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Junctions 1 and 2 are joined by the pipe. You will find a tank at junction node 7. Between junctions 10 and 11, the pipe carries a water demand of 73. The junctions 12 and 13 are connected by the pipe. The pipe linking junctions 12 and 13 has a water requirement of 53. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A pipe establishes a link between junctions 11 and 24. There is a tank in the junction node 9. At the junction node 1, there is a tank. Junctions 12 and 15 are connected through a pipe with a delivered water demand of 56. The available valves are thirteen. Junctions 13 and 14 are joined by the pipe. The pipe connecting 1 and 12 has a water demand of 56. The pipe which runs between 1 and 2 carry a water demand of 39. The junctions 12 and 15 are connected by the pipe. A pipe establishes a link between junctions 1 and 11. The pipe between 1 and 11 has an associated weight of 59. The pipe which runs between 11 and 24 carry a water demand of 48. The pipe which runs between 13 and 14 carry a water demand of 39. No more than two valve(s) per pipe is allowed. A pipe connects junctions 1 and 12. Junctions 10 and 11 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8180696859180894865", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A tank is located at the junction node 1. The pipe linking junctions 1 and 96 has a water requirement of 60. A pipe connects junctions 100 and 101. The pipe connecting 100 and 104 has a water demand of 96. A water demand of 125 flows through the pipe between junctions 102 and 103. A pipe establishes a link between junctions 100 and 104. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. Only two valve(s) per pipe is permitted. A pipe establishes a link between junctions 1 and 96. The junctions 100 and 101 are connected by the pipe, with a water demand of 133. A pipe connects junctions 1 and 92. Junctions 1 and 95 are joined by the pipe. The pipe between 1 and 92 has an associated weight of 108. The pipe which runs between 101 and 102 carry a water demand of 163. A water demand of 89 flows through the pipe between junctions 1 and 95. The pipe between 101 and 103 has an associated weight of 122. The available valves are fourteen. Junctions 101 and 102 are joined by the pipe. A pipe connects junctions 102 and 103. A pipe establishes a link between junctions 101 and 103.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(14). valves_per_pipe(2).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A tank is located at the junction node 1. The pipe linking junctions 1 and 96 has a water requirement of 60. A pipe connects junctions 100 and 101. The pipe connecting 100 and 104 has a water demand of 96. A water demand of 125 flows through the pipe between junctions 102 and 103. A pipe establishes a link between junctions 100 and 104. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. Only two valve(s) per pipe is permitted. A pipe establishes a link between junctions 1 and 96. The junctions 100 and 101 are connected by the pipe, with a water demand of 133. A pipe connects junctions 1 and 92. Junctions 1 and 95 are joined by the pipe. The pipe between 1 and 92 has an associated weight of 108. The pipe which runs between 101 and 102 carry a water demand of 163. A water demand of 89 flows through the pipe between junctions 1 and 95. The pipe between 101 and 103 has an associated weight of 122. The available valves are fourteen. Junctions 101 and 102 are joined by the pipe. A pipe connects junctions 102 and 103. A pipe establishes a link between junctions 101 and 103.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5110007605602265196", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "The associated weight of the pipe between 101 and 103 is 122. You will find a tank at junction node 1. Junctions 1 and 95 are joined by the pipe. The pipe between 100 and 101 serves a water demand of 133. Between junctions 1 and 96, the pipe carries a water demand of 60. The associated weight of the pipe between 101 and 102 is 163. A pipe connects junctions 101 and 103. Each pipe can have only one valve(s). A pipe establishes a link between junctions 102 and 103. A pipe connects junctions 100 and 104. A pipe connects junctions 1 and 92. Junctions 1 and 96 are joined by the pipe. A water demand of 96 exists in the pipe between junctions 100 and 104. The associated weight of the pipe between 1 and 95 is 89. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The pipe linking junctions 1 and 92 has a water requirement of 108. A pipe connects junctions 100 and 101. Between junctions 102 and 103, the pipe carries a water demand of 125. The available valves are eighteen. Junctions 101 and 102 are connected through the pipe.", "output": "junction(1). junction(10). junction(100). junction(101). junction(102). junction(103). junction(104). junction(105). dem(1,92,108). dem(1,95,89). dem(1,96,60). dem(100,101,133). dem(100,104,96). dem(101,102,163). dem(101,103,122). dem(102,103,125). pipe(1,92). pipe(1,95). pipe(1,96). pipe(100,101). pipe(100,104). pipe(101,102). pipe(101,103). pipe(102,103). tank(1). valves_number(18). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```The associated weight of the pipe between 101 and 103 is 122. You will find a tank at junction node 1. Junctions 1 and 95 are joined by the pipe. The pipe between 100 and 101 serves a water demand of 133. Between junctions 1 and 96, the pipe carries a water demand of 60. The associated weight of the pipe between 101 and 102 is 163. A pipe connects junctions 101 and 103. Each pipe can have only one valve(s). A pipe establishes a link between junctions 102 and 103. A pipe connects junctions 100 and 104. A pipe connects junctions 1 and 92. Junctions 1 and 96 are joined by the pipe. A water demand of 96 exists in the pipe between junctions 100 and 104. The associated weight of the pipe between 1 and 95 is 89. The following are the junctions of the hydraulic network: 1, 10, 100, 101, 102, 103, 104, 105. The pipe linking junctions 1 and 92 has a water requirement of 108. A pipe connects junctions 100 and 101. Between junctions 102 and 103, the pipe carries a water demand of 125. The available valves are eighteen. Junctions 101 and 102 are connected through the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8088724067236504593", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A water demand of 100 exists in the pipe between junctions 1 and 6. The pipe which runs between 11 and 16 carry a water demand of 137. A pipe connects junctions 1 and 2. The available valves are nine. The junctions 10 and 11 are connected by the pipe. A tank is located at the junction node 1. The pipe which runs between 12 and 13 carry a water demand of 299. A pipe connects junctions 11 and 12. There is a water demand of 157 in the pipe connecting junctions 10 and 16. The pipe connecting 1 and 8 carries an associated weight of 125. The junctions 1 and 6 are connected by the pipe. The junctions 1 and 8 are connected by the pipe. The associated weight of the pipe between 11 and 12 is 246. Between junctions 1 and 2, the pipe carries a water demand of 40. A pipe connects junctions 10 and 16. Junctions 12 and 13 are connected through the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Junctions 11 and 16 are connected through the pipe. No more than one valve(s) per pipe is allowed. A pipe connects junctions 10 and 11 with an associated weight of 180.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,2,40). dem(1,6,100). dem(1,8,125). dem(10,11,180). dem(10,16,157). dem(11,12,246). dem(11,16,137). dem(12,13,299). pipe(1,2). pipe(1,6). pipe(1,8). pipe(10,11). pipe(10,16). pipe(11,12). pipe(11,16). pipe(12,13). tank(1). valves_number(9). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A water demand of 100 exists in the pipe between junctions 1 and 6. The pipe which runs between 11 and 16 carry a water demand of 137. A pipe connects junctions 1 and 2. The available valves are nine. The junctions 10 and 11 are connected by the pipe. A tank is located at the junction node 1. The pipe which runs between 12 and 13 carry a water demand of 299. A pipe connects junctions 11 and 12. There is a water demand of 157 in the pipe connecting junctions 10 and 16. The pipe connecting 1 and 8 carries an associated weight of 125. The junctions 1 and 6 are connected by the pipe. The junctions 1 and 8 are connected by the pipe. The associated weight of the pipe between 11 and 12 is 246. Between junctions 1 and 2, the pipe carries a water demand of 40. A pipe connects junctions 10 and 16. Junctions 12 and 13 are connected through the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Junctions 11 and 16 are connected through the pipe. No more than one valve(s) per pipe is allowed. A pipe connects junctions 10 and 11 with an associated weight of 180.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6548755566169247748", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "At the junction node 1, there is a tank. Junctions 12 and 13 are joined by the pipe. The valves that can be used are seven. Junctions 13 and 22 are joined by the pipe. A pipe connects junctions 1 and 19. The junctions 10 and 13 are connected by the pipe. The pipe connecting 12 and 13 has a water demand of 68. A pipe establishes a link between junctions 11 and 12. A water demand of 166 exists in the pipe between junctions 13 and 22. Junctions 10 and 13 are connected through a pipe with a delivered water demand of 70. There is a water demand of 66 in the pipe connecting junctions 1 and 5. A pipe connects junctions 10 and 11 with an associated weight of 70. A pipe connects junctions 10 and 11. A pipe connects junctions 1 and 2. The pipe which runs between 11 and 12 carry a water demand of 83. A pipe connects junctions 1 and 19 with an associated weight of 95. No more than one valve(s) per pipe is allowed. The junctions 1 and 5 are connected by the pipe. The pipe between 1 and 2 has an associated weight of 57. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,19,95). dem(1,2,57). dem(1,5,66). dem(10,11,70). dem(10,13,70). dem(11,12,83). dem(12,13,68). dem(13,22,166). pipe(1,19). pipe(1,2). pipe(1,5). pipe(10,11). pipe(10,13). pipe(11,12). pipe(12,13). pipe(13,22). tank(1). valves_number(7). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```At the junction node 1, there is a tank. Junctions 12 and 13 are joined by the pipe. The valves that can be used are seven. Junctions 13 and 22 are joined by the pipe. A pipe connects junctions 1 and 19. The junctions 10 and 13 are connected by the pipe. The pipe connecting 12 and 13 has a water demand of 68. A pipe establishes a link between junctions 11 and 12. A water demand of 166 exists in the pipe between junctions 13 and 22. Junctions 10 and 13 are connected through a pipe with a delivered water demand of 70. There is a water demand of 66 in the pipe connecting junctions 1 and 5. A pipe connects junctions 10 and 11 with an associated weight of 70. A pipe connects junctions 10 and 11. A pipe connects junctions 1 and 2. The pipe which runs between 11 and 12 carry a water demand of 83. A pipe connects junctions 1 and 19 with an associated weight of 95. No more than one valve(s) per pipe is allowed. The junctions 1 and 5 are connected by the pipe. The pipe between 1 and 2 has an associated weight of 57. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5970169882867877150", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "A pipe connects junctions 10 and 11. The pipe connecting 10 and 11 has a water demand of 73. A pipe establishes a link between junctions 12 and 15. Junctions 12 and 13 are connected through the pipe. A pipe connects junctions 1 and 12. No more than one valve(s) per pipe is allowed. Junctions 13 and 14 are connected through the pipe. The junctions 1 and 2 are connected by the pipe, with a water demand of 39. The pipe which runs between 1 and 12 carry a water demand of 56. The pipe connecting 13 and 14 has a water demand of 39. Junctions 1 and 2 are joined by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Between junctions 12 and 15, the pipe carries a water demand of 56. You will find a tank at junction node 1. Between junctions 12 and 13, the pipe carries a water demand of 53. The pipe between 11 and 24 serves a water demand of 48. The pipe between 1 and 11 has an associated weight of 59. Junctions 1 and 11 are connected through the pipe. Junctions 11 and 24 are connected through the pipe. The available valves are sixteen. You will find a tank at junction node 7. At the junction node 9, there is a tank.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,11,59). dem(1,12,56). dem(1,2,39). dem(10,11,73). dem(11,24,48). dem(12,13,53). dem(12,15,56). dem(13,14,39). pipe(1,11). pipe(1,12). pipe(1,2). pipe(10,11). pipe(11,24). pipe(12,13). pipe(12,15). pipe(13,14). tank(1). tank(7). tank(9). valves_number(16). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```A pipe connects junctions 10 and 11. The pipe connecting 10 and 11 has a water demand of 73. A pipe establishes a link between junctions 12 and 15. Junctions 12 and 13 are connected through the pipe. A pipe connects junctions 1 and 12. No more than one valve(s) per pipe is allowed. Junctions 13 and 14 are connected through the pipe. The junctions 1 and 2 are connected by the pipe, with a water demand of 39. The pipe which runs between 1 and 12 carry a water demand of 56. The pipe connecting 13 and 14 has a water demand of 39. Junctions 1 and 2 are joined by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. Between junctions 12 and 15, the pipe carries a water demand of 56. You will find a tank at junction node 1. Between junctions 12 and 13, the pipe carries a water demand of 53. The pipe between 11 and 24 serves a water demand of 48. The pipe between 1 and 11 has an associated weight of 59. Junctions 1 and 11 are connected through the pipe. Junctions 11 and 24 are connected through the pipe. The available valves are sixteen. You will find a tank at junction node 7. At the junction node 9, there is a tank.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1869758621692080515", "problem_id": "44", "problem_name": "Valves Location Problem", "description": "The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.", "format": "The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves", "text": "Between junctions 1 and 15, the pipe carries a water demand of 142. No more than one valve(s) per pipe is allowed. A pipe establishes a link between junctions 1 and 15. Junctions 10 and 11 are connected through a pipe with a delivered water demand of 42. The available valves are five. Junctions 11 and 18 are connected through the pipe. The junctions 10 and 11 are connected by the pipe. A pipe connects junctions 12 and 19. The junctions 11 and 12 are connected by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A water demand of 116 flows through the pipe between junctions 1 and 2. The pipe between 11 and 12 has an associated weight of 64. The associated weight of the pipe between 12 and 17 is 94. The pipe between 12 and 13 serves a water demand of 48. The pipe connecting 11 and 18 carries an associated weight of 64. Junctions 12 and 17 are joined by the pipe. A tank exists at the junction node 1. A pipe connects junctions 1 and 2. A pipe connects junctions 12 and 19 with an associated weight of 61. The junctions 12 and 13 are connected by the pipe.", "output": "junction(1). junction(10). junction(11). junction(12). junction(13). junction(14). junction(15). junction(16). dem(1,15,142). dem(1,2,116). dem(10,11,42). dem(11,12,64). dem(11,18,64). dem(12,13,48). dem(12,17,94). dem(12,19,61). pipe(1,15). pipe(1,2). pipe(10,11). pipe(11,12). pipe(11,18). pipe(12,13). pipe(12,17). pipe(12,19). tank(1). valves_number(5). valves_per_pipe(1).", "prompt": "Given the following problem description between triple backtips: \n ```The Valves Location problem is a typical design issue of Urban Hydraulic Networks. A generic Urban Hydraulic Network can be modelled as an indirect and weighted graph: the nodes represent the junctions of the pipes (junction/1), and the edges represent the pipes. The two arguments of predicate pipe/2 are the two junctions connected by the pipe. The third argument of dem/3 is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe (i.e., the average water demand, in litres/seconds, of the houses that take water from that pipe). One or more tanks feed the network; the tanks are located on the junction nodes given by predicate tank/1.\n\nIn order to permit the maintenance of any pipe, each pipe must be isolable. The isolation of a pipe can be performed by closing a set of \"isolation valves\". In any solution, for every pipe there must exist a set of valves that, when closed, disconnects that pipe from all the tanks.\n\nValves can only be located on the pipes near one extreme (i.e., near a junction), thus in general there can be at most two valves in a pipe. However, in some instances, the number of valves per pipe can be at most 1. The maximum number of valves in a pipe is given by predicate valves_per_pipe/1 (as said, it can be either 1 or 2).\n\nDue to the limited number of available valves, when a pipe is isolated for maintenance, other pipes become isolated as well: all those pipes that are no longer reachable from one of the tanks. This gives a disruption in the service of water delivery. The measure of disruption (given some isolation) is the total amount of water that is not delivered, given as the sum of the weights on the edges that are unreachable from all tanks. The general measure of disruption is the disruption in the worst case, and the aim is to minimize such a quantity.```\nGiven the following specification for the predicates format: \n```The input predicates are explained as follows:\n\njunction/1: the nodes represent the junctions of the pipes\npipe/2: The two arguments are the two junctions connected by the pipe\ndem/3: The third argument is the weight associated to the pipe defined by the first two arguments, and represents the water demand delivered by the pipe\ntank/1: Represent a tank, the tanks are located on the junction nodes given by the first parameter\nvalves_per_pipe/1: Represents the maximum number of valves in a pipe\nvalves_number/1: Represents the number of valves```\nExtract the datalog facts from this text: \n```Between junctions 1 and 15, the pipe carries a water demand of 142. No more than one valve(s) per pipe is allowed. A pipe establishes a link between junctions 1 and 15. Junctions 10 and 11 are connected through a pipe with a delivered water demand of 42. The available valves are five. Junctions 11 and 18 are connected through the pipe. The junctions 10 and 11 are connected by the pipe. A pipe connects junctions 12 and 19. The junctions 11 and 12 are connected by the pipe. The following are the junctions of the hydraulic network: 1, 10, 11, 12, 13, 14, 15, 16. A water demand of 116 flows through the pipe between junctions 1 and 2. The pipe between 11 and 12 has an associated weight of 64. The associated weight of the pipe between 12 and 17 is 94. The pipe between 12 and 13 serves a water demand of 48. The pipe connecting 11 and 18 carries an associated weight of 64. Junctions 12 and 17 are joined by the pipe. A tank exists at the junction node 1. A pipe connects junctions 1 and 2. A pipe connects junctions 12 and 19 with an associated weight of 61. The junctions 12 and 13 are connected by the pipe.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4766233089127865779", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6157700647623986297", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8304190361237665165", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4908668379063004327", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6761103482318178333", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7169783554408659698", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3171841604219849463", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8335169929516994065", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5921328291498441877", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4190530944659957158", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "294212572647941848", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4609248886061761353", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1488284683052034282", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "3097942258636975704", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6242676823658529433", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5538135217066873671", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "2874854513018111900", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8395945144854300699", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "730292998036564552", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "947241459847225285", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4002527120941584312", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "7408617871747360192", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1370669186674294356", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4546593654023320645", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "754611469109079851", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "6754527930730677134", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5404262652055917353", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5870959673627376792", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "5484988668576867276", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "1596665572611721227", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "8978075818654195110", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}, {"id": "4694869551782282519", "problem_id": "43", "problem_name": "VisitAll", "description": "This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.", "format": "The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.", "text": "The are a total amount of eight step(s), from 1 to 8.", "output": "step(1). step(2). step(3). step(4). step(5). step(6). step(7). step(8).", "prompt": "Given the following problem description between triple backtips: \n ```This domain was created by Nir Lipovetzky and H\u00e9ctor Geffner for the IPC 2011, to evaluate the performance of planners in problems with multiple conflicting goals. It is somehow inspired by the Dispose domain created by H\u00e9ctor Palacios and H\u00e9ctor Geffner for the conformant subtrack of the uncertainty part of the International Planning Competition celebrated in 2008 [1]. In the Visitall domain a robot in the middle of a $n\\times n$ square grid must visit all the cells in the grid. There is only one action in this domain, which moves the robot from one cell to another one. From a planning community perspective, in this kind of problem, progress toward one goal means moving away from other goals. Such problems typically produce large plateaus in planners based on delete-relaxation heuristics, where this heuristic is almost useless. Similarly, the specific features of this domain cause ASP solvers to visit a large search tree with few or no possibility of early pruning. In the ASP Comp 2013 version, some unreachable grid cells were added in the grid, while the original problem was defined over plain square grids.\nThe objective is to minimize the number of moves. The number of goals is the number of cells, except for the sequential optimal subtrack where there are problems where only half of the cells have to be visited. In addition to be challenging to the delete-relaxation heuristics, this domain has a high number of goals, up to 2,500 in the most complex problem.```\nGiven the following specification for the predicates format: \n```The grid consists of a square matrix of NxN locations. While most of them can be occupied by a robot, a few are unreachable. Thus, to describe the geometry of the grid, the predicate connected/2 explicitly describes what positions are reachable from the other (so that unreachable locations are just ignored):\nconnected(l1,l2): l2 is reachable from l1 (i.e. the robot can step from l1 to l2).\nThere is a single robot. The original position of the robot is described with:\nat(l): the robot is located at location l\nThe goal of this problem is to find the optimal path that takes the robot from its current location to a number of given cells. The goal locations are identified with the predicate visit/1:\nvisit(l): l is a goal location\nOn the other hand, since the solution consists of a sequence of steps, these are identified by the following input predicate:\nstep(s): s is a step, for s a positive integer.```\nExtract the datalog facts from this text: \n```The are a total amount of eight step(s), from 1 to 8.```\nOutput the result in datalog with no comments, no space between facts and only one fact per line."}]
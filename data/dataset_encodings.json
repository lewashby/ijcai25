{
    "Connected Maximum-density Still Life": {
        "problem_id": "36",
        "encoding": "% possible coordinates\nvalue(0).\nvalue(V+1) :- value(V), size(N), V <= N.\n\nstep(-1).\nstep(1).\ndiff(X,0) :- step(X).\ndiff(0,Y) :- step(Y).\ndiff(X,Y) :- step(X), step(Y).\n\ncell(X,Y) :- value(X), value(Y), size(N), 0 < X, 0 < Y, X <= N, Y <= N.\nnear(X,Y,X+DX,Y+DY) :- value(X), value(Y), diff(DX,DY), cell(X+DX,Y+DY).\n\n% a cell may live\n{ lives(X,Y) } :- cell(X,Y), not hole(X,Y).\n:- fill(X,Y), not lives(X,Y).\n\nactive(X,Y,X,Y)   :- lives(X,Y).\nactive(X,Y,XX,YY) :- near(X,Y,XX,YY), lives(XX,YY).\n\nupper(X,Y) :- cell(X,Y), 4 <= #count{ XX,YY : active(X,Y,XX,YY), near(X,Y,XX,YY) }.\nlower(X,Y) :- value(X), value(Y), 3 <= #count{ XX,YY : active(X,Y,XX,YY) }.\n\n% living cells must have at most 3 living neighbours\n:- lives(X,Y), upper(X,Y).\n\n% living cells must have at least 2 living neighbours\n:- lives(X,Y), not lower(X,Y).\n\n% cells with exactly 3 neighbours must live\n:- lower(X,Y), not upper(X,Y), not lives(X,Y).\n\n% connectedness\nconnect(X,Y,XX,YY) :- near(X,Y,XX,YY), lives(X,Y).\nconnect(X,Y,XX,YY) :- near(X,Y,XX,YY), cell(X,Y), not lives(XX,YY).\n\ninitial(1,1)   :- cell(1,1).\ninitial(X+1,Y) :- initial(X,Y), cell(X+1,Y), not lives(X,Y).\ninitial(1,Y+1) :- initial(X,Y), size(X), not size(Y), not lives(X,Y).\n\nreached(X,Y)   :- initial(X,Y).\nreached(XX,YY) :- reached(X,Y), connect(X,Y,XX,YY).\n:- cell(X,Y), not reached(X,Y).\n\n% maximise living cells\n:~ cell(X,Y), not lives(X,Y). [1,X,Y]"
    },
    "Crossing Minimization": {
        "problem_id": "0",
        "encoding": "pvalue(L,1)   :- width(L,T), 0 < T.\npvalue(L,X+1) :- pvalue(L,X), width(L,T), X < T.\n\n{ gt(L,N,P) } :- in_layer(L,N), pvalue(L,P), not width(L,P).\n:- pvalue(L,P), gt(L,N,P+1), not gt(L,N,P).\n\nposition(N,1) :- in_layer(L,N), width(L,T), 0 < T, not gt(L,N,1).\nposition(N,Q) :- gt(L,N,P), Q = P+1, not gt(L,N,Q).\n:- pvalue(L,P), 2 <= #count{ N : in_layer(L,N), position(N,P) }.\n\nedge_layer(L1,L2,N1,N2) :- edge(N1,N2), in_layer(L1,N1), in_layer(L2,N2), L1 < L2.\nedge_layer(L1,L2,N1,N2) :- edge(N2,N1), in_layer(L1,N1), in_layer(L2,N2), L1 < L2.\n\nedge_pair(N1,N2,N3,N4) :- edge_layer(L1,L2,N1,N2), edge_layer(L1,L2,N3,N4), N1 < N3, N2 != N4.\nedge_paired(N2,N4)     :- edge_pair(N1,N2,N3,N4).\n\ncompare(N1,N3) :- edge_pair(N1,N2,N3,N4).\ncompare(N2,N4) :- edge_paired(N2,N4), N2 < N4.\ncompare(N4,N2) :- edge_paired(N2,N4), N4 < N2.\n\ninorder(N1,N2) :- compare(N1,N2), gt(L,N2,P), not gt(L,N1,P).\n\ncrossing(N1,N2,N3,N4) :- edge_pair(N1,N2,N3,N4), not edge_pair(N1,N4,N3,N2), compare(N2,N4), inorder(N1,N3), not inorder(N2,N4).\ncrossing(N1,N2,N3,N4) :- edge_pair(N1,N2,N3,N4), not edge_pair(N1,N4,N3,N2), compare(N2,N4), inorder(N2,N4), not inorder(N1,N3).\ncrossing(N1,N4,N3,N2) :- edge_pair(N1,N4,N3,N2), not edge_pair(N1,N2,N3,N4), compare(N2,N4), inorder(N1,N3), inorder(N2,N4).\ncrossing(N1,N4,N3,N2) :- edge_pair(N1,N4,N3,N2), not edge_pair(N1,N2,N3,N4), compare(N2,N4), not inorder(N1,N3), not inorder(N2,N4).\n\n:~ crossing(N1,N2,N3,N4). [1,N1,N2,N3,N4]\n"
    },
    "Graceful Graphs": {
        "problem_id": "37",
        "encoding": "% nodes and values\nnode(X) :- edge(X,Y).\nnode(Y) :- edge(X,Y).\n\n%num_edges(N) :- N = #sum { 1,X,Y : edge(X,Y) }.\n% Updated March 25th, 2013\nnum_edges(N) :- N = #count { X,Y : edge(X,Y) }.\nnum(0).\nnum(N) :- num(N1), N=N1+1, num_edges(E), N<=E.\n\n% assignment to nodes\n{ value(X,N) : num(N) } = 1 :- node(X).\n\n% assignment to edges\n{ edge_value(edge(X,Y),N) : num(N), N>0 } = 1 :- edge(X,Y).\n\n% relates node values with edge values\n:- not edge_value(edge(X,Y),M-N), edge(X,Y), value(X,M), value(Y,N), N < M.\n:- not edge_value(edge(X,Y),N-M), edge(X,Y), value(X,M), value(Y,N), N > M.\n\n% alldifferent values\n:- value(X,N), value(Y,N), num(N), X<Y.\n:- edge_value(X,N), edge_value(Y,N), num(N), X<Y.\n"
    },
    "Graph Colouring": {
        "problem_id": "24",
        "encoding": "% Guess colours.\nchosenColour(N,C) | notChosenColour(N,C) :- node(N), colour(C).\n\n% At least one color per node.\n:- node(X), not colored(X).\ncolored(X) :- chosenColour(X,Fv1).\n\n% Only one color per node.\n:- chosenColour(N,C1), chosenColour(N,C2), C1!=C2. \n\n% No two adjacent nodes have the same colour. \n:- link(X,Y),  X<Y, chosenColour(X,C), chosenColour(Y,C)."
    },
    "Incremental Scheduling": {
        "problem_id": "33",
        "encoding": "time(S)   :- curr_time(S), max_value(T), S <= T.\ntime(S+1) :- time(S), max_value(T), S < T.\n\ninstance_of(D,I)   :- device(D), instances(D,I), 0 < I.\ninstance_of(D,I-1) :- instance_of(D,I), 1 < I.\n\nclosure(J1,J2) :- job(J1), job(J2), precedes(J1,J2).\nclosure(J1,J2) :- job(J1), precedes(J1,J), closure(J,J2).\ninconsistent   :- closure(J,J), job_len(J,L), 0 < L.\n\n%----------------------\n% - current schedule\n%----------------------\n\nalready_started(J)   :- job(J), curr_job_start(J,S), curr_time(T), T > S.\nalready_finished(J)  :- job(J), curr_job_start(J,S), job_len(J,L), curr_time(T), T >= S+L.\nrescheduled(J)       :- already_started(J), not already_finished(J), job_device(J,D), curr_on_instance(J,I), offline_instance(D,I).\nmust_not_schedule(J) :- already_started(J), not rescheduled(J).\nmust_schedule(J)     :- job(J), not must_not_schedule(J).\n\ninconsistent :- precedes(J1,J2), must_schedule(J1), must_not_schedule(J2).\ninconsistent :- precedes(J1,J2), must_not_schedule(J1), must_not_schedule(J2), curr_job_start(J1,S), job_len(J1,L), curr_job_start(J2,T), T < S+L.\ninconsistent :- must_not_schedule(J1), must_not_schedule(J2), job_device(J1,D), curr_on_instance(J1,I), job_device(J2,D), curr_on_instance(J2,I), curr_job_start(J1,S), job_len(J1,L), curr_job_start(J2,T), S <= T, T < S+L, J1 != J2.\n\n%----------------------\n% - device instances\n%----------------------\n\ndelay(D,I,S+L) :- must_not_schedule(J), job_device(J,D), curr_on_instance(J,I), curr_job_start(J,S), job_len(J,L), not already_finished(J).\ndelayed(D,I)   :- delay(D,I,S).\n\navailable(D,I,S) :- delay(D,I,S), time(S).\navailable(D,I,S) :- instance_of(D,I), curr_time(S), time(S), not delayed(D,I), not offline_instance(D,I).\n\navail(D,S) :- available(D,I,S).\nlater(D,T) :- avail(D,S), avail(D,T), S < T.\nearly(D,S) :- avail(D,S), not later(D,S).\nsched(D)   :- early(D,S).\n\ninconsistent :- must_schedule(J), job_device(J,D), not sched(D).\n\n%----------------------\n% - penalty factors\n%----------------------\n\nimport(J) :- job(J), deadline(J,D), importance(J,I).\n\nfactor(J,I) :- job(J), deadline(J,D), importance(J,I), 0 < I.\nfactor(J,1) :- job(J), deadline(J,D), not import(J).\n\n%----------------------\n% - minimal start times\n%----------------------\n\nlower(J1,S)   :- must_not_schedule(J1), curr_job_start(J1,S).\nlower(J1,S)   :- must_schedule(J1), job_device(J1,D), early(D,S).\nlower(J2,S+L) :- must_not_schedule(J1), must_schedule(J2), precedes(J1,J2), lower(J1,S), job_len(J1,L), not already_finished(J1).\nlower(J2,S+L) :- must_schedule(J1), must_schedule(J2), precedes(J1,J2), lower(J1,S), job_len(J1,L), time(S).\nunlow(J,S)    :- lower(J,S), lower(J,T), S < T.\nfirst(J,S)    :- lower(J,S), not unlow(J,S).\n\ninconsistent :- must_schedule(J), first(J,S), not time(S).\n\n%----------------------\n% - static penalties\n%----------------------\n\nfree(J,D-L) :- factor(J,I), deadline(J,D), job_len(J,L).\n\nstatic(J,0)   :- free(J,F), first(J,S), S <= F.\nstatic(J,I*D) :- free(J,F), first(J,S), factor(J,I), F < S, D = S-F.\n\nstat(Q) :- #sum{ P,J : static(J,P) } = Q.\n\nremain(P-Q) :- max_total_penalty(P), stat(Q), Q <= P.\n\npen(P)   :- remain(P).\npen(P-1) :- pen(P), 0 < P.\n\ninconsistent :- max_total_penalty(P), stat(Q), P < Q.\n\n%----------------------\n% - maximal start times\n%----------------------\n\nbudget(J,F+B) :- must_schedule(J), free(J,F), static(J,S), factor(J,I), remain(P), A = S+P, B = A/I.\nbudg(J)       :- budget(J,S), time(S+1).\n\ndecrease(J1) :- precedes(J1,J2), must_schedule(J1).\n\nupper(J2,S)   :- budget(J2,S), budg(J2).\nupper(J2,M)   :- must_schedule(J2), max_value(M), not decrease(J2), not budg(J2).\nupper(J1,S-L) :- must_schedule(J1), precedes(J1,J2), upper(J2,S), job_len(J1,L), first(J2,F), F <= S.\nunupp(J,T)    :- upper(J,S), upper(J,T), S < T.\nfinal(J,S)    :- upper(J,S), not unupp(J,S).\n\ninconsistent :- first(J,S), final(J,T), T < S.\n\n%----------------------\n% - start ranges\n%----------------------\n\nrange(J,T)   :- final(J,T), not inconsistent.\nrange(J,T-1) :- range(J,T), first(J,S), S < T.\n\n%----------------------\n% - guess if not statically inconsistent\n%----------------------\n\n:- inconsistent.\n\n{ gt(J,S) } :- range(J,S), not final(J,S).\n:- gt(J,S+1), range(J,S), not gt(J,S).\n\nstart(J,S)   :- first(J,S), not gt(J,S).\nstart(J,S+1) :- gt(J,S), not gt(J,S+1).\n\non_instance(J,I) :- must_not_schedule(J), curr_on_instance(J,I).\n1 <= { on_instance(J,I) : available(D,I,S), final(J,T), S <= T } <= 1 :- must_schedule(J), job_device(J,D), not inconsistent.\n:- must_schedule(J), job_device(J,D), on_instance(J,I), available(D,I,S), T = S-1, range(J,T), not gt(J,T).\n\n%----------------------\n%     - order\n%----------------------\n\nexclude(J2,T) :- precedes(J1,J2), must_schedule(J1), gt(J1,S), job_len(J1,L), T = S+L, range(J2,T).\n:- exclude(J2,T), not gt(J2,T).\n\n%----------------------\n% - overlap\n%----------------------\n\npair(J1,J2) :- must_schedule(J1), must_schedule(J2), job_device(J1,D), job_device(J2,D), J1 < J2, not closure(J1,J2), not closure(J2,J1).\n\nsymm(J1,J2,J1,J2) :- pair(J1,J2).\nsymm(J1,J2,J2,J1) :- pair(J1,J2).\n\ncompare(J,JJ) :- symm(J,JJ,J1,J2), job_len(J1,L), first(J1,S1), final(J1,T1), first(J2,S2), final(J2,T2), S1 <= T2, S2 < T1+L.\n\nunord(J1,J2) :- compare(J,JJ), symm(J,JJ,J1,J2), first(J1,S), job_len(J1,L), first(J2,F), T = S+L, F < T, not gt(J2,T-1).\nunord(J1,J2) :- compare(J,JJ), symm(J,JJ,J1,J2), gt(J1,S), job_len(J1,L), first(J2,F), T = S+L, F <= T, range(J2,T), not gt(J2,T).\n\nsame(J1,J2) :- compare(J1,J2), on_instance(J1,I), on_instance(J2,I).\n\n:- same(J1,J2), unord(J1,J2), unord(J2,J1).\n\n%----------------------\n% - reasonable start times\n%----------------------\n\nfinish(D,I,T) :- available(D,I,T), not early(D,T).\nfinish(D,I,T) :- must_schedule(J), job_device(J,D), on_instance(J,I), job_len(J,L), start(J,S), T = S+L, time(T).\nenable(J,S)   :- must_schedule(J), job_device(J,D), on_instance(J,I), finish(D,I,S), range(J,S), not first(J,S).\n:- start(J,S), not first(J,S), not enable(J,S), not exclude(J,S-1).\n\n%-------------------------------------\n%     - completion -- penalty\n%-------------------------------------\n\npenal(J,T,1)     :- free(J,S), first(J,T), S < T, range(J,T+1).\npenal(J,T,1)     :- free(J,T), S = T+1, range(J,S), not first(J,S).\npenal(J,T+1,N+1) :- penal(J,T,N), range(J,T+2).\n\ntd(J,T,N) :- penal(J,T,N), gt(J,T).\n\npenalty(J,0)   :- job(J), deadline(J,D), importance(J,0).\npenalty(J,P)   :- static(J,P), free(J,S), first(J,T), not td(J,S,1), not td(J,T,1).\npenalty(J,P+A) :- static(J,P), factor(J,I), td(J,T,N), not td(J,T+1,N+1), A = I*N.\n\n:- remain(P), #sum{ I,J,N : td(J,T,N), factor(J,I) } > P.\n\nhas(P) :- pen(P), #sum{ I,J,N : td(J,T,N), factor(J,I) } >= P.\n\ntot_penalty(P+Q) :- stat(Q), has(P), not has(P+1)."
    },
    "Knight Tour": {
        "problem_id": "11",
        "encoding": "% Knight Tour\n\n% Input:\n% - size(N), if the chessboard is NxN\n% - givemove(X1,Y1,X2,Y2), if the knight must move from X1,Y1 to X2,Y2.\n\n% Output:\n% - move(X1,Y1,X2,Y2), if the knight moves from X1,Y1 to X2,Y2.\n\nsize(8). givemove(7,5,8,7). givemove(1,7,3,6). \n\nnumber(X) :- size(X).\nnumber(X) :- number(Y), X=Y-1, X>0.\n\n% There is no tour for a NxN chessboard where N is odd.\neven :- size(N), number(X), N = X+X.\n:- not even.\n\n% There is no tour for a NxN chessboard where N is lesser than 6.\n:- size(N), N < 6.\n\n% Compute the cells of the chessboard.\nrow_col(X) :- number(X), X >= 1, X <= N, size(N), even.\ncell(X,Y) :- row_col(X), row_col(Y).\n\n% Given moves must be done.\nmove(X1,Y1,X2,Y2) :- givemove(X1,Y1,X2,Y2).\n\n% Guess the other moves.\nmove(X1,Y1,X2,Y2) | non_move(X1,Y1,X2,Y2):- valid(X1,Y1,X2,Y2).\n\n% Compute the valid moves from each cell.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X1 = X2+2, Y1 = Y2+1.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X1 = X2+2, Y2 = Y1+1.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X2 = X1+2, Y1 = Y2+1.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X2 = X1+2, Y2 = Y1+1.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X1 = X2+1, Y1 = Y2+2.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X1 = X2+1, Y2 = Y1+2.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X2 = X1+1, Y1 = Y2+2.\nvalid(X1,Y1,X2,Y2) :- cell(X1,Y1), cell(X2,Y2), X2 = X1+1, Y2 = Y1+2.\n\n% Exactly one move entering to each cell.\n:- cell(X,Y), not exactlyOneMoveEntering(X,Y).\nexactlyOneMoveEntering(X,Y) :- move(X,Y,X1,Y1), not atLeastTwoMovesEntering(X,Y).\natLeastTwoMovesEntering(X,Y) :- move(X,Y,X1,Y1), move(X,Y,X2,Y2), X1 != X2.\natLeastTwoMovesEntering(X,Y) :- move(X,Y,X1,Y1), move(X,Y,X2,Y2), Y1 != Y2.\n\n% Exactly one move leaving each cell.\n:- cell(X,Y), not exactlyOneMoveLeaving(X,Y).\nexactlyOneMoveLeaving(X,Y) :- move(X1,Y1,X,Y), not atLeastTwoMovesLeaving(X,Y).\natLeastTwoMovesLeaving(X,Y) :- move(X1,Y1,X,Y), move(X2,Y2,X,Y), X1 != X2.\natLeastTwoMovesLeaving(X,Y) :- move(X1,Y1,X,Y), move(X2,Y2,X,Y), Y1 != Y2.\n\n\n% Each cell must be reached by the knight.\nreached(X,Y) :- move(1,1,X,Y).\nreached(X2,Y2) :- reached(X1,Y1), move(X1,Y1,X2,Y2).\n:- cell(X,Y), not reached(X,Y)."
    },
    "Knight Tour With Holes": {
        "problem_id": "46",
        "encoding": "number(X)   :- size(X).\nnumber(X-1) :- number(X), 1 < X.\ncell(X,Y)   :- number(X), number(Y), not forbidden(X,Y).\n\nhasx(X) :- cell(X,Y).\ndomx(X) :- hasx(X), hasx(XX), XX < X.\nminx(X) :- hasx(X), not domx(X).\n\nhasy(Y) :- cell(X,Y), hasx(X).\ndomy(Y) :- hasy(Y), hasy(YY), YY < Y.\nminy(Y) :- hasy(Y), not domy(Y).\n\ndelta(1,2). delta(1,-2). delta(2,1). delta(2,-1).\n\nconn(X,Y,X+DX,Y+DY) :- cell(X,Y), delta(DX,DY), cell(X+DX,Y+DY).\n\nvalid(X,Y,XX,YY) :- conn(X,Y,XX,YY).\nvalid(XX,YY,X,Y) :- conn(X,Y,XX,YY).\n\nother(X,Y,XX,YY) :- valid(X,Y,XX,YY), move(A,B,XX,YY), X != A.\nother(X,Y,XX,YY) :- valid(X,Y,XX,YY), move(X,B,XX,YY), Y != B.\nother(X,Y,XX,YY) :- valid(X,Y,XX,YY), move(X,Y,A,BB), XX != A.\nother(X,Y,XX,YY) :- valid(X,Y,XX,YY), move(X,Y,XX,B), YY != B.\n\nmove(X,Y,XX,YY) :- valid(X,Y,XX,YY), not other(X,Y,XX,YY).\n\nfrom(X,Y) :- move(X,Y,XX,YY).\n:- cell(X,Y), not from(X,Y).\n\nreach(X,Y)   :- minx(X), miny(Y).\nreach(XX,YY) :- move(X,Y,XX,YY), reach(X,Y).\n\n:- cell(X,Y), not reach(X,Y).\n"
    },
    "Labyrinth": {
        "problem_id": "18",
        "encoding": "dir(e). dir(w). dir(n). dir(s).\ninverse(e,w). inverse(w,e).\ninverse(n,s). inverse(s,n).\n\nrow(X) :- field(X,Y).\ncol(Y) :- field(X,Y).\n\nnum_rows(X) :- row(X), not row(XX), XX = X+1.\nnum_cols(Y) :- col(Y), not col(YY), YY = Y+1.\n\ngoal(X,Y,0)   :- goal_on(X,Y).\nreach(X,Y,0)  :- init_on(X,Y).\nconn(X,Y,D,0) :- connect(X,Y,D).\n\nstep(S) :- max_steps(S),     0 < S.\nstep(T) :- step(S), T = S-1, 1 < S.\n\n%%  Direct neighbors\n\ndneighbor(n,X,Y,XX,Y) :- field(X,Y), field(XX,Y), XX = X+1.\ndneighbor(s,X,Y,XX,Y) :- field(X,Y), field(XX,Y), XX = X-1.\ndneighbor(e,X,Y,X,YY) :- field(X,Y), field(X,YY), YY = Y+1.\ndneighbor(w,X,Y,X,YY) :- field(X,Y), field(X,YY), YY = Y-1.\n\n%%  All neighboring fields\n\nneighbor(D,X,Y,XX,YY) :- dneighbor(D,X,Y,XX,YY).\nneighbor(n,X,Y, 1, Y) :- field(X,Y), num_rows(X).\nneighbor(s,1,Y, X, Y) :- field(X,Y), num_rows(X).\nneighbor(e,X,Y, X, 1) :- field(X,Y), num_cols(Y).\nneighbor(w,X,1, X, Y) :- field(X,Y), num_cols(Y).\n\n%%  Select a row or column to push\n\nneg_goal(T) :- goal(X,Y,T), not reach(X,Y,T).\n\nrrpush(T)   :- step(T), neg_goal(S), S = T-1, not ccpush(T).\nccpush(T)   :- step(T), neg_goal(S), S = T-1, not rrpush(T).\n\norpush(X,T) :- row(X), row(XX), rpush(XX,T), X != XX.\nocpush(Y,T) :- col(Y), col(YY), cpush(YY,T), Y != YY.\n\nrpush(X,T)  :- row(X), rrpush(T), not orpush(X,T).\ncpush(Y,T)  :- col(Y), ccpush(T), not ocpush(Y,T).\n\npush(X,e,T) :- rpush(X,T), not push(X,w,T).\npush(X,w,T) :- rpush(X,T), not push(X,e,T).\npush(Y,n,T) :- cpush(Y,T), not push(Y,s,T).\npush(Y,s,T) :- cpush(Y,T), not push(Y,n,T).\n\n%%  Determine new position of a (pushed) field\n\nshift(XX,YY,X,Y,T) :- neighbor(e,XX,YY,X,Y), push(XX,e,T), step(T).\nshift(XX,YY,X,Y,T) :- neighbor(w,XX,YY,X,Y), push(XX,w,T), step(T).\nshift(XX,YY,X,Y,T) :- neighbor(n,XX,YY,X,Y), push(YY,n,T), step(T).\nshift(XX,YY,X,Y,T) :- neighbor(s,XX,YY,X,Y), push(YY,s,T), step(T).\nshift( X, Y,X,Y,T) :- field(X,Y), not push(X,e,T), not push(X,w,T), not push(Y,n,T), not push(Y,s,T), step(T).\n\n%%  Move connections around\n\nconn(X,Y,D,T) :- conn(XX,YY,D,S), S = T-1, dir(D), shift(XX,YY,X,Y,T), step(T).\n\n%%  Location of goal after pushing\n\ngoal(X,Y,T) :- goal(XX,YY,S), S = T-1, shift(XX,YY,X,Y,T), step(T).\n\n%%  Locations reachable from new position\n\nreach(X,Y,T) :- reach(XX,YY,S), S = T-1, shift(XX,YY,X,Y,T), step(T).\nreach(X,Y,T) :- reach(XX,YY,T), dneighbor(D,XX,YY,X,Y), conn(XX,YY,D,T), conn(X,Y,E,T), inverse(D,E), step(T).\n\n%%  Goal must be reached\n\n:- neg_goal(S), max_steps(S).\n\n%% Project output\n\n% #hide.\n% #show push(Z,D,T)."
    },
    "Maximal Clique Problem": {
        "problem_id": "17",
        "encoding": "clique(X) :- node(X), not nonClique(X).\nnonClique(X) :- node(X), not clique(X).\n\n:- clique(X), clique(Y), X < Y, not edge(X,Y), not edge(Y,X).\n\n:~ nonClique(X). [1,X]\n\n#show clique/1."
    },
    "Nomystery": {
        "problem_id": "38",
        "encoding": "truck(T) :- fuel(T,_).\npackage(P) :- at(P,L), not truck(P).\nlocation(L) :- fuelcost(_,L,_).\nlocation(L) :- fuelcost(_,_,L).\nlocatable(O) :- at(O,L).\n%\nat(O,L,0) :- at(O,L).\nfuel(T,F,0) :- fuel(T,F).\n%\n\naction(unload(P,T,L))  :- package( P ), truck( T ), location( L ).\naction(load(P,T,L))    :- package( P ), truck( T ), location( L ).\naction(drive(T,L1,L2)) :- fuelcost( Fueldelta,L1,L2 ) , truck( T ).\n\n%\n% GENERATE  >>>>>\n{ do(A,S) : action(A) } <= 1 :- step(S), 0 < S.\n\ndone(S) :- do(A,S).\n:- done(S), step(S-1), not done(S-1), 1 < S.\n\nunload( P,T,L,S )  :- do(unload(P,T,L),S).\nload( P,T,L,S )    :- do(load(P,T,L),S).\ndrive( T,L1,L2,S ) :- do(drive(T,L1,L2),S).\n% <<<<<  GENERATE\n\n% unload/4, effects\nat( P,L,S ) :- unload( P,T,L,S ).\ndel( in( P,T ),S ) :- unload( P,T,L,S ).\n\n% load/4, effects\ndel( at( P,L ),S ) :- load( P,T,L,S ).\nin( P,T,S ) :- load( P,T,L,S ).\n\n% drive/4, effects\ndel( at( T,L1 ), S ) :- drive( T,L1,L2,S ).\nat( T,L2,S ) :- drive( T,L1,L2,S).\ndel( fuel( T,Fuelpre ),S ) :- drive( T,L1,L2,S ), fuel(T, Fuelpre,S-1).\nfuel( T,Fuelpre - Fueldelta,S ) :- drive( T,L1,L2,S ), fuelcost(Fueldelta,L1,L2), fuel(T,Fuelpre,S-1), Fuelpre >= Fueldelta.\n% <<<<<  EFFECTS APPLY\n%\n% INERTIA  >>>>>\nat( O,L,S ) :- at( O,L,S-1 ), not del( at( O,L ),S  ), step(S).\nin( P,T,S ) :- in( P,T,S-1 ), not del( in( P,T ),S  ), step(S).\nfuel( T,Level,S ) :- fuel( T,Level,S-1 ), not del( fuel( T,Level) ,S ), truck( T ), step(S).\n% <<<<<  INERTIA\n%\n\n%\n%\n% PRECONDITIONS CHECK  >>>>>\n\n% unload/4, preconditions\n :- unload( P,T,L,S ), not preconditions_u( P,T,L,S ).\npreconditions_u( P,T,L,S ) :- step(S), at( T,L,S-1 ), in( P,T,S-1 ), package( P ), truck( T ).\n\n% load/4, preconditions\n :- load( P,T,L,S ), not preconditions_l( P,T,L,S ).\npreconditions_l( P,T,L,S ) :- step(S), at( T,L,S-1 ), at( P,L,S-1 ).\n\n% drive/5, preconditions\n :- drive( T,L1,L2,S ), not preconditions_d( T,L1,L2,S ).\npreconditions_d( T,L1,L2,S ) :- step(S), at( T,L1,S-1 ), fuel( T, Fuelpre, S-1), fuelcost(Fueldelta,L1,L2), Fuelpre >= Fueldelta.\n% <<<<<  PRECONDITIONS HOLD\n%\n\n% GOAL CHECK\n\n:- goal(P,L), step(S), not step(S+1), not at(P,L,S).\n\n% goalreached :- step(S),  N = #count{ P,L : at(P,L,S) , goal(P,L) }, N = #count{ P1,L1 : goal(P1,L1) }.\n% :- not goalreached.\n\n% Gringo directives to show / hide particular literals\n%#hide.\n%#show unload/4.\n%#show load/4.\n%#show drive/4.\n%#show at/2.\n%#show at/3."
    },
    "Partner Units": {
        "problem_id": "26",
        "encoding": "elem(z,Z) :- zone2sensor(Z,D).\nelem(d,D) :- zone2sensor(Z,D).\n\nnumb(A,N) :- elem(A,N), not elem(A,N+1).\n\nzone :- numb(z,N), numb(d,M), N > M.\n\nrule(z) :- zone.\nrule(d) :- not zone.\n\n{ gt(A,X,U) } :- elem(A,X), comUnit(U), comUnit(U1), U1=U+1, rule(A), U < X.\n{ gt(A,X,U) } :- elem(A,X), comUnit(U), comUnit(U1), U1=U+1, not rule(A).\n\n:- gt(A,X,U), 1 < U, not gt(A,X,U-1).\n\nunit2zone(1,Z)   :- elem(z,Z), comUnit(1), not gt(z,Z,1).\nunit2zone(U+1,Z) :- gt(z,Z,U), not gt(z,Z,U+1).\n\n:- comUnit(U), #count{ Z : unit2zone(U,Z) } > 2.\n\nunit2sensor(1,D)   :- elem(d,D), comUnit(1), not gt(d,D,1).\nunit2sensor(U+1,D) :- gt(d,D,U), not gt(d,D,U+1).\n\n:- comUnit(U), #count{ D : unit2sensor(U,D) } > 2.\n\npartner(d,D,U) :- unit2zone(U,Z), rule(d), zone2sensor(Z,D).\npartner(z,Z,U) :- unit2sensor(U,D), rule(z), zone2sensor(Z,D).\n\npartnerunits(U,P) :- partner(d,D,U), unit2sensor(P,D), U < P.\npartnerunits(P,U) :- partner(d,D,U), unit2sensor(P,D), P < U.\npartnerunits(U,P) :- partner(z,Z,U), unit2zone(P,Z), U < P.\npartnerunits(P,U) :- partner(z,Z,U), unit2zone(P,Z), P < U.\npartnerunits(U,P) :- partnerunits(P,U), P < U.\n\n:- comUnit(U), maxPU(M), #count{ P : partnerunits(U,P) } > M.\n\n% gtd(X+1,U) :- gt(A,X,U), comUnit(U+2), rule(A), elem(A,X+1).\n% gtd(X+1,U) :- gtd(X,U), rule(A), elem(A,X+1).\n\n% :- gt(A,X,U), 1 < U, rule(A), not gtd(X,U-1).\n"
    },
    "Permutation Pattern Matching": {
        "problem_id": "35",
        "encoding": "kval(K) :- p(K,P), patternlength(L), K <= L.\npair(K1,K2) :- kval(K1), kval(K2), p(K1,P1), p(K2,P2), P1 <= P2.\n\n{ geq(K,I) } :- kval(K), t(I,E).\n:- kval(K), t(I,E), geq(K,I+1), not geq(K,I).\n:- kval(K), t(I,E), geq(K-1,I), not geq(K,I+1).\n:- kval(K), not geq(K,K).\n\nsolution(K,E) :- kval(K), t(I,E), geq(K,I), not geq(K,I+1).\n:- pair(K1,K2), solution(K1,E1), solution(K2,E2), E2 < E1."
    },
    "Ricochet Robots": {
        "problem_id": "39",
        "encoding": "%#const row =  1.\n%#const col = -1.\n\ndir(west, -1, 0).\ndir(east,  1, 0).\ndir(north, 0,-1).\ndir(south, 0, 1).\n\ndl(west, -1).\ndl(north,-1).\ndl(east,  1).\ndl(south, 1).\n\ndir(west, 1).   %dir(west, row).\ndir(east, 1).   %dir(east, row).\ndir(north, -1). %dir(north,col).\ndir(south, -1). %dir(south,col).\n\ndir(D) :- dir(D,_).\n\nrobot(R) :- pos(R,_,_).\n\npos(R,1,I,0) :- pos(R,I,_).  %pos(R,row,I,0) :- pos(R,I,_).\npos(R,-1,J,0) :- pos(R,_,J). %pos(R,col,J,0) :- pos(R,_,J).\n\nbarrier(I+1,J,west ) :- barrier(I,J,east ), dim(I), dim(J), dim(I+1).\nbarrier(I,J+1,north) :- barrier(I,J,south), dim(I), dim(J), dim(J+1).\nbarrier(I-1,J,east ) :- barrier(I,J,west ), dim(I), dim(J), dim(I-1).\nbarrier(I,J-1,south) :- barrier(I,J,north), dim(I), dim(J), dim(I-1).\n\nconn(D,I,J) :- dir(D,-1), dir(D,_,DJ), not barrier(I,J,D), dim(I), dim(J), dim(J+DJ). %conn(D,I,J) :- dir(D,col), dir(D,_,DJ), not barrier(I,J,D), dim(I), dim(J), dim(J+DJ).\nconn(D,J,I) :- dir(D,1), dir(D,DI,_), not barrier(I,J,D), dim(I), dim(J), dim(I+DI).  %conn(D,J,I) :- dir(D,row), dir(D,DI,_), not barrier(I,J,D), dim(I), dim(J), dim(I+DI).\n\n%step(1..X) :- length(X).\nstep(1).\nstep(X+1) :- step(X), length(L), X < L. \n\n1 <= { selectRobot(R,T) : robot(R) } <= 1 :- step(T).\n1 <= { selectDir(D,O,T) : dir(D,O) } <= 1 :- step(T).\n\ngo(R,D,O,T) :- selectRobot(R,T), selectDir(D,O,T).\ngo_(R,O,T)   :- go(R,_,O,T).\ngo(R,D,T) :- go(R,D,_,T).\n\nsameLine(R,D,O,RR,T)  :- go(R,D,O,T), pos(R,-O,L,T-1), pos(RR,-O,L,T-1), R != RR.\nblocked(R,D,O,I+DI,T) :- go(R,D,O,T), pos(R,-O,L,T-1), not conn(D,L,I), dl(D,DI), dim(I), dim(I+DI).\nblocked(R,D,O,L,T)    :- sameLine(R,D,O,RR,T), pos(RR,O,L,T-1).\n\nreachable(R,D,O,I,   T) :- go(R,D,O,T), pos(R,O,I,T-1).\nreachable(R,D,O,I+DI,T) :- reachable(R,D,O,I,T), not blocked(R,D,O,I+DI,T), dl(D,DI), dim(I+DI).\n\n:- go(R,D,O,T), pos(R,O,I,T-1), blocked(R,D,O,I+DI,T), dl(D,DI).\n:- go(R,D,O,T), go(R,DD,O,T-1).\n\npos(R,O,I,T) :- reachable(R,D,O,I,T), not reachable(R,D,O,I+DI,T), dl(D,DI).\npos(R,O,I,T) :- pos(R,O,I,T-1), not go_(R,O,T), step(T).\n\nselectDir(O,T) :- selectDir(D,O,T).\n\n:- target(R,I,_), not pos(R,1,I,X), length(X).  %:- target(R,I,_), not pos(R,row,I,X), length(X).\n:- target(R,_,J), not pos(R,-1,J,X), length(X). %:- target(R,_,J), not pos(R,col,J,X), length(X).\n"
    },
    "Sokoban": {
        "problem_id": "45",
        "encoding": "% GENERATE  >>>>>\n1 <= { pushtonongoal( P,S,Ppos,From,To,Dir,T ) : \n\tmovedir( Ppos,From,Dir ) ,\n\tmovedir( From,To,Dir ) , \n\tisnongoal( To ) , \n\tplayer( P ) , \n\tstone( S ) , Ppos != To , Ppos != From , From != To; \n    move( P,From,To,Dir,T ) : \n\tmovedir( From,To,Dir ) , \n\tplayer( P ) , From != To;\n    pushtogoal( P,S,Ppos,From,To,Dir,T ) : \n\tmovedir( Ppos,From,Dir ) , \n\tmovedir( From,To,Dir ) , \n\tisgoal( To ) , player( P ) , stone( S ) , Ppos != To , Ppos != From , From != To;\n    noop(T) } <= 1 :- step(T).\n\n% <<<<<  GENERATE\n% \n\n% \n%\n% Initial state\nat(P,To,0) :- at(P,To).\nclear(P,0) :- clear(P).\natgoal(S,0) :- isgoal(L), stone(S), at(S,L).\n \n% EFFECTS APPLY  >>>>>\n\n% push-to-nongoal/7, effects\ndel( at( P,Ppos ),Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), \n                          movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\ndel( at( S,From ),Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\ndel( clear( To ),Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\nat( P,From,Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\nat( S,To,Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\nclear( Ppos,Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\ndel( atgoal( S ),Ti ) :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\n\n% move/5, effects\ndel( at( P,From ),Ti ) :- move( P,From,To,Dir,Ti ), movedir( From,To,Dir ), player( P ), From != To.\ndel( clear( To ),Ti ) :- move( P,From,To,Dir,Ti ), movedir( From,To,Dir ), player( P ), From != To.\nat( P,To,Ti ) :- move( P,From,To,Dir,Ti ), movedir( From,To,Dir ), player( P ), From != To.\nclear( From,Ti ) :- move( P,From,To,Dir,Ti ), movedir( From,To,Dir ), player( P ), From != To.\n\n% push-to-goal/7, effects\ndel( at( P,Ppos ),Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                          movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\ndel( at( S,From ),Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                          movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\ndel( clear( To ),Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                         movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\nat( P,From,Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                   movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\nat( S,To,Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                 movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\nclear( Ppos,Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                    movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\natgoal( S,Ti ) :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), \n                  stone( S ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\n% <<<<<  EFFECTS APPLY\n% \n\n% \n% \n% INERTIA  >>>>>\nclear( L,Ti ) :- clear( L,Ti-1 ), not del( clear( L ),Ti  ), step(Ti).\natgoal( S,Ti ) :- atgoal( S,Ti-1 ), not del( atgoal( S ),Ti ), stone( S ), step(Ti).\nat( T,L,Ti ) :- at( T,L,Ti-1 ), not del( at( T,L ) ,Ti  ), step(Ti).\n% <<<<<  INERTIA\n% \n\n% \n% \n% PRECONDITIONS HOLD  >>>>>\n\n% push-to-nongoal/6, preconditions\n :- pushtonongoal( P,S,Ppos,From,To,Dir,Ti ), not preconditions_png( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To.\npreconditions_png( P,S,Ppos,From,To,Dir,Ti ) :- at( P,Ppos,Ti-1 ), at( S,From,Ti-1 ), clear( To,Ti-1 ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isnongoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To, step(Ti).\n\n% move/4, preconditions\n :- move( P,From,To,Dir,Ti ), not preconditions_m( P,From,To,Dir,Ti ), movedir( From,To,Dir ), player( P ), From != To.\npreconditions_m( P,From,To,Dir,Ti ) :- at( P,From,Ti-1 ), clear( To,Ti-1 ), movedir( From,To,Dir ), movedir( From,To,Dir ), player( P ), From != To, step(Ti).\n\n% push-to-goal/6, preconditions\n :- pushtogoal( P,S,Ppos,From,To,Dir,Ti ), not preconditions_pg( P,S,Ppos,From,To,Dir,Ti ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To, step(Ti).\npreconditions_pg( P,S,Ppos,From,To,Dir,Ti ) :- at( P,Ppos,Ti-1 ), at( S,From,Ti-1 ), clear( To,Ti-1 ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), movedir( Ppos,From,Dir ), movedir( From,To,Dir ), isgoal( To ), player( P ), stone( S ), Ppos != To, Ppos != From, From != To, step(Ti).\n\n% <<<<<  PRECONDITIONS HOLD\n% \n%\n% Goal Reached check \n%\ngoalreached :- step(T), N = #count{ X : atgoal(X,T) , goal(X) }, N = #count{ X1 : goal(X1) }.\n:- not goalreached.\n\n% Gringo directives to show / hide particular literals\n%#hide.\n%#show pushtonongoal/7.\n%#show move/5.\n%#show pushtogoal/7.\n"
    },
    "Stable Marriage": {
        "problem_id": "30",
        "encoding": "% guess matching\nmatch(M,W) :- manAssignsScore(M,Fv1,Fv2), womanAssignsScore(W,Fv3,Fv4), not nonMatch(M,W).\nnonMatch(M,W) :- manAssignsScore(M,Fv1,Fv2), womanAssignsScore(W,Fv3,Fv4), not match(M,W).\n\n% no polygamy\n:- match(M1,W), match(M,W), M <> M1.\n:- match(M,W), match(M,W1), W <> W1.\n\n% no singles\njailed(M) :- match(M,Fv1).\n:- manAssignsScore(M,Fv1,Fv2), not jailed(M).\n\n% strong stability condition\n:- match(M,W1), manAssignsScore(M,W,Smw), W1 <> W, manAssignsScore(M,W1,Smw1),   Smw >  Smw1,\n   match(M1,W), womanAssignsScore(W,M,Swm),        womanAssignsScore(W,M1,Swm1), Swm >= Swm1."
    },
    "Valves Location Problem": {
        "problem_id": "44",
        "encoding": "%Symmetric pipe\nsymm_pipe(A,B):- pipe(A,B).\nsymm_pipe(B,A):- pipe(A,B).\n\t\t%We need a lexicographic order (there may be more than one worst isolation cases)\nless_ico(pipe(A,B), pipe(C,D)):- pipe(A,B), pipe(C,D), A<C.\nless_ico(pipe(A,B), pipe(C,D)):- pipe(A,B), pipe(C,D), A = C, B<D.\n\n%Adjacency of pipes (common junction and unshared junctions)\n%adj(pipe(X,Y), pipe(W,Z), COM, U1, U2) :- symm_pipe(COM,U1), symm_pipe(COM,U2), U1!=U2, not tank(COM),\n%\t\t\t\tpipe(X,Y), pipe(W,Z), \n%                                2 {COM=W, COM=Z, COM=X, COM=Y} 2,\n%\t\t\t\t1 {U1=W, U1=Z, U1=X, U1=Y} 1,\n%\t\t\t\t1 {U2=W, U2=Z, U2=X, U2=Y} 1.\n%adj(pipe(X,Y), pipe(W,Z), COM, U1, U2) :- symm_pipe(COM,U1), symm_pipe(COM,U2), U1!=U2, not tank(COM),\n%\t\t\t\tpipe(X,Y), pipe(W,Z), \n%                                2 = #count {COM : COM=W; COM : COM=Z; COM : COM=X; COM : COM=Y},\n%\t\t\t\t1 = #count {U1 : U1=W; U1 : U1=Z; U1 : U1=X; U1 : U1=Y},\n%\t\t\t\t1 = #count {U2 : U2=W; U2 : U2=Z; U2 : U2=X; U2 : U2=Y}.\n% \n% Fix Mar 24th. 2013. Removed cumbersome definition for adj predicate.\n%\nswap(pipe(A,B),pipe(A,B)):- pipe(A,B).\nswap(pipe(A,B),pipe(B,A)):- pipe(A,B).\n                %Adjacency of pipes (common junction and unshared junctions)\nadj(pipe(A,B),pipe(C,D),COM,U1,U2):-\n                swap(pipe(A,B),pipe(COM,U1)),\n                swap(pipe(C,D),pipe(COM,U2)),\n                U1!=U2, not tank(COM).\n\n\n\n\t\t%\n\t\t%There are some valves that are closed to isolate the broken pipe\n1 <= { closed_valve(v(X,Y), broken(A,B)) : symm_pipe(X,Y) } <= Nv :- pipe(A,B), valves_number(Nv).\n\n\t\t%\n\t\t%If a valve is closed for some pipes, then it must be installed!!\nvalve(A,B) :- closed_valve(v(A,B), _).\n\n\t\t%\n\t\t%There should always be installed valves near the tanks\nvalve(A,B) :- symm_pipe(A,B), tank(A).\n\n\t\t%\n\t\t%Valves must be at most Nv\n:- valves_number(Nv), not Nv = #count{ X,Y : valve(X,Y) , pipe(X,Y); Y,X : valve(Y,X) , pipe(X,Y)}.\n\n\t\t%\n\t\t%At most X valves per pipe must be allowed (either 1 or 2)\n:- valves_per_pipe(1), pipe(A,B), valve(A,B), valve(B,A).\n\n\t\t%\n\t\t%some symmetry breaking on valves\n:- junction(X), not tank(X), symm_pipe(X,A), symm_pipe(X,B),\n\t\t2 = #count{ X,Y : symm_pipe(X,Y) }, A>B, valve(X,A).\n\n\t\t%\n\t\t%A pipe adjacent to the tank is reached, when a generic pipe is broken iff there is no valve between them.\nreached(pipe(A,B), broken(X,Y)):- tank(A), pipe(X,Y), pipe(A,B), not closed_valve(v(A,B), broken(X,Y)).\nreached(pipe(A,B), broken(X,Y)):- tank(B), pipe(X,Y), pipe(A,B), not closed_valve(v(B,A), broken(X,Y)).\n\n\t\t%\n\t\t%Can we recursively reach any tank??\nreached(pipe(A,B), broken(X,Y)) :- adj(pipe(A,B), pipe(C,D), COM, U1, U2), %COM is not a tank! \n\t\t\t\tnot closed_valve(v(COM,U1), broken(X,Y)),\n\t\t\t\tnot closed_valve(v(COM,U2), broken(X,Y)),\n\t\t\t\treached(pipe(C,D), broken(X,Y)).\n\n\t\t%\n\t\t%The broken pipe must be unreachable!\n:- pipe(A,B), reached(pipe(A,B), broken(A,B)).\n\n\t\t%\n\t\t% Pair-wise comparisons between delivered demand pipe isolation cases\n%lower(pipe(X,Y), pipe(W,Z)) :- pipe(X,Y), pipe(W,Z),\n%\t\t#sum [ \treached(pipe(A,B), broken(X,Y))=Dn: dem(A,B,Dn),\n%\t\t\treached(pipe(C,D), broken(W,Z))=-Dm: dem(C,D,Dm) ] 0.\n%lower(pipe(X,Y), pipe(W,Z)) :- pipe(X,Y), pipe(W,Z),\n%\t\tS1 = #sum { Dn,A,B,X,Y : reached(pipe(A,B), broken(X,Y)), dem(A,B,Dn) },\n%               S2 = #sum { Dm,C,D,W,Z : reached(pipe(C,D), broken(W,Z)), dem(C,D,Dm) }, S1 - S2 <= 0.\nlower(pipe(X,Y), pipe(W,Z)) :- pipe(X,Y), pipe(W,Z),\n\t\t#sum { Dn,A,B : reached(pipe(A,B), broken(X,Y)), dem(A,B,Dn);\n                       Dm,C,D : reached(pipe(C,D), broken(W,Z)), dem(C,D,NegDm), Dm = -NegDm } <= 0.\n\n\t\t%\n\t\t%Then the lower are...\nlower_lexico(pipe(X,Y), pipe(W,Z)) :- pipe(X,Y), pipe(W,Z),\n\t\t\t\tlower(pipe(X,Y), pipe(W,Z)), not lower(pipe(W,Z), pipe(X,Y)).\nlower_lexico(pipe(X,Y), pipe(X,Y)) :- pipe(X,Y),\n\t\t\t\tlower(pipe(X,Y), pipe(X,Y)).\nlower_lexico(pipe(X,Y), pipe(W,Z)) :- pipe(X,Y), pipe(W,Z), % with the same delivered demand\n\t\t\t\tlower(pipe(X,Y), pipe(W,Z)), lower(pipe(W,Z),pipe(X,Y)),\n\t\t\t\tless_ico(pipe(X,Y), pipe(W,Z)).\n\n\t\t%\n\t\t%And the worst isolation case is the one for which all lower_lexico are true\n%worst(pipe(X,Y)) :- pipe(X,Y), lower_lexico(pipe(X,Y),pipe(W,Z)) : pipe(W,Z).\nworst(pipe(X,Y)) :- pipe(X,Y), C = #count { W,Z : pipe(W,Z) }, \n                               D = #count{ W,Z : lower_lexico(pipe(X,Y),pipe(W,Z)) , pipe(W,Z)}, C = D.\n\n\nworst_deliv_dem(pipe(A,B), D) :- dem(A,B,D), pipe(X,Y),\n\t\treached(pipe(A,B), broken(X,Y)), worst(pipe(X,Y)).\n\n\t\t%\n\t\t%Worst isolation case' delivered demand maximization\n\n:~ dem(A,B,D),  not worst_deliv_dem(pipe(A,B),D). [D,A,B]\n%#maximize [ worst_deliv_dem(pipe(A,B), D)=D : pipe(A,B) ].\n\n%#hide.\n%#show valve/2.\n%#show worst_deliv_dem/2."
    },
    "VisitAll": {
        "problem_id": "43",
        "encoding": "atrobot(X,0) :- at(X).\n\natrobot(N,T) :- connected(C,N), C != N, step(T), not atother(N,T).\natother(N,T) :- connected(C,N), C != N, step(T), atrobot(O,T), O != N.\n\n% 1 <= { atrobot( Nextpos,T ) : connected( Curpos,Nextpos ), Curpos != Nextpos } <= 1 :- step(T).\n\nmove(C,N,T) :- atrobot(C,T-1), atrobot(N,T), connected(C,N), C != N.\ndone(T)     :- move(C,N,T).\n\n:- step(T), not done(T).\n\nvisited(X) :- atrobot(X,T).\n\n:- visit(X), not visited(X)."
    }
}
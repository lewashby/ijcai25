preprocessing:
- _: |
    Problem description:
    An ubiquitous feature of planning problems is the need to economize limited resources such as fuel or money. While heuristic search, mostly based on relaxation heuristics, is currently the superior method for most varieties of planning, its ability to solve critically resource-constrained problems is limited: relaxation heuristics basically ignore the resource consumption by actions. Nomystery is a nice test domain to study the behavior of planning algorithms in planning problems with resources.
    In Nomystery, a truck moves in a weighted graph where a set of packages must be transported between nodes. Actions move the truck along edges and load/unload packages. Each move consumes the edge weight in fuel. The edge weights are uniformly drawn between 1 and an integer W. The initial fuel supply is set to C * M where M is the minimum required amount of fuel, calculated using a domain-specific optimal solver, and C >= 1 is a (float) input parameter that denotes the ratio between the available fuel vs. the minimum amount required. The closer C to 1, the more constrained the problem. If C=1only the optimal plan solves the problem.
    The authors originally provided two versions of the domain, called Hard and Hard-cost. They differ only in the cost of the actions. In the first one, all the actions have unitary cost, while in the second version the cost of moving a track equals the fuel consumed. According to the author:
    In the Hard encoding, problems with 12 locations and 12 packages become quite challenging for state-of-the-art planners when C is close to 1 [2]. Hard-cost encoding makes the problems easier for the current planners. The reason is that the heuristic functions that consider costs are not any more completely ignorant to the resource consumption of actions. However, this type of encoding is not always feasible for resource planning; there might be several resources and the cost of the plan might be different from the amount of the resource consumption. However, our initial experiments show problems in this encoding with 12 locations and 15 packages become challenging for current planners when C is close to 1.
    From the two versions of the domain only the Hard one (where cost of the plan and resource consumption are not related) has been considered at IPC 2011 (Deterministic Track). As the domain creator said, this was the most difficult one of the two formulations for planning systems. We retained the Hard version of the problem for the ASP Competition 2013. Instances have only one truck.
    
    Format description of the predicates to be extracted:
    In the setting of the ASP competition, input predicates encode the weighted graph at hand, the initial positions of packages and of the truck, the initial fuel available and the final requested destination for packages. In detail input assertions are to be interpreted as follows:
    - fuelcost(c,a,b): the locations a and b are connected and the cost for travelling from a to b is c (for c a positive integer) 
    - at(o,l): the object o (either a package or a truck) is initially at location
    - l fuel(t,l): the initial fuel available for truck t is l (for l a positive integer) 
    - goal(p,l): at the final step, the package p must stay at location
    - l step(s): s is an allowed step, for s a positive integer value
    the predicate step is intended in order to encode the maximum number of allowed steps. It can be assumed that for 1..n the allowed steps, then step(1) .. step(n) assertions hold.
- at(object,location): |
    For each object (an unquoted string), specify its initial location (an unquoted string).
- fuel(truck,quantity): |
    For each truck (an unquoted string), specify the initial quantity of fuel (an integer).
- fuelcost(cost,source,target): |
    For each source location connected to a target location, specify the cost (an integer) to travel between them.
    Locations are unquoted strings.
- goal(package,location): |
    Specify the localtion (an unquoted string) where the package (an unquoted string) must stay at the final step.
- step(value): |
    List all the allowed steps.
    Steps form a sequence starting from 1.

knowledge_base:

postprocessing:
- _: | 
    You are helping a user with their datalog questions.
- load(p,t,l,s): Say that at step 's', the truck 't' loads package 'p', at location 'l'.
- unload(p,t,l,s): Say that at step 's', the truck 't' unloads package 'p', at location 'l'.
- drive(t,l1,l2,s): Say that at step 's', the truck 't' drives from 'l1' to 'l2', reducing thus its fuel level.
